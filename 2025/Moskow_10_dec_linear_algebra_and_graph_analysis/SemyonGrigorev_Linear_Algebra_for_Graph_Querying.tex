%15 min preso!
\documentclass[xcolor=table,aspectratio=169,fleqn]{beamer}
\usepackage{beamerthemesplit}
\usepackage{wrapfig}
\usetheme{SPbGU}
\usepackage{pdfpages}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{indentfirst}
\usepackage{newtxmath}
\usepackage{tikz}
\usepackage{multirow}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{fancyvrb}
\usepackage{hyperref}
\usepackage{nicematrix}
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks,linkcolor=,urlcolor=links}
\usetikzlibrary{calc}
\usetikzlibrary{shapes, backgrounds}
\usetikzlibrary{arrows,automata}
\usetikzlibrary{positioning}
\usetikzlibrary{fit}
\usetikzlibrary{shapes.callouts}
\usetikzlibrary{shapes.misc}
\usepackage{xparse}
\usepackage{fontawesome}

\usepackage{etoolbox,refcount}
\usepackage{multicol}

\usepackage{tabularx}
\newcolumntype{Y}{>{\raggedleft\arraybackslash}X}

\renewcommand{\thealgorithm}{}

\newtheorem{mytheorem}{Theorem}
\renewcommand{\thealgorithm}{}

\newcommand{\tikzmark}[1]{\tikz[overlay,remember picture] \node (#1) {};}
\def\Put(#1,#2)#3{\leavevmode\makebox(0,0){\put(#1,#2){#3}}}

\newcommand{\ltz}{$< 1$}

\tikzset{
    state/.style={
           rectangle,
           rounded corners,
           draw=black, very thick,
           minimum height=1.5em,
           inner sep=2pt,
           text centered,
           },
}

\tikzset{
    invisible/.style={opacity=0,text opacity=0},
    visible on/.style={alt=#1{}{invisible}},
    alt/.code args={<#1>#2#3}{%
      \alt<#1>{\pgfkeysalso{#2}}{\pgfkeysalso{#3}} % \pgfkeysalso doesn't change the path
    },
}

\tikzset{cross/.style={cross out, draw=black, minimum size=2*(#1-\pgflinewidth), inner sep=0pt, outer sep=0pt, ultra thick},
%default radius will be 1pt. 
cross/.default={1pt}}

\NewDocumentCommand{\mycallout}{r<> O{opacity=0.8,text opacity=1} m m m}{%
\tikz[remember picture, overlay]\node[align=center, fill=cyan!20, text width=#5cm,
#2,visible on=<#1>, rounded corners,
draw,rectangle callout,anchor=pointer,callout relative pointer={(290:0.5cm)}]
at (#3) {#4};
}

\NewDocumentCommand{\mycalloutR}{r<> O{opacity=0.8,text opacity=1} m m m}{%
\tikz[remember picture, overlay]\node[align=center, fill=cyan!20, text width=#5cm,
#2,visible on=<#1>, rounded corners,
draw,rectangle callout,anchor=pointer,callout relative pointer={(30:0.8cm)}]
at (#3) {#4};
}

\newcommand\colR{\cellcolor{red!20}}
\newcommand\colB{\cellcolor{blue!20}}
\newcommand\colG{\cellcolor{green!20}}
\definecolor{Gray}{gray}{0.8}

%callout relative pointer={(230:0.5cm)}]

\newcounter{countitems}
\newcounter{nextitemizecount}
\newcommand{\setupcountitems}{%
  \stepcounter{nextitemizecount}%
  \setcounter{countitems}{0}%
  \preto\item{\stepcounter{countitems}}%
}
\makeatletter
\newcommand{\computecountitems}{%
  \edef\@currentlabel{\number\c@countitems}%
  \label{countitems@\number\numexpr\value{nextitemizecount}-1\relax}%
}
\newcommand{\nextitemizecount}{%
  \getrefnumber{countitems@\number\c@nextitemizecount}%
}
\newcommand{\previtemizecount}{%
  \getrefnumber{countitems@\number\numexpr\value{nextitemizecount}-1\relax}%
}
\makeatother    
\newenvironment{AutoMultiColItemize}{%
\ifnumcomp{\nextitemizecount}{>}{3}{\begin{multicols}{2}}{}%
\setupcountitems\begin{itemize}}%
{\end{itemize}%
\unskip\computecountitems\ifnumcomp{\previtemizecount}{>}{3}{\end{multicols}}{}}


\beamertemplatenavigationsymbolsempty

%%%%%%% 40 минут доклад %%%%%%%%%
%GraphBLAS предлагает разреженную линейную алгебру как путь к высокопроизводительному (параллельному) анализу графов. 
%Попробуем поглубже познакомиться с таким подходом. Начнём разговор с рассмотрения базовых связей между задачами анализа 
%графов и линейной алгеброй. Обсудим, как может быть устроена параметризация операций над матрицами и векторами, и причём тут полукольца. 
%Посмотрим на то, как в рамках линейной алгебры можно учитывать не только топологию графа, но атрибуты вершин и рёбер.
%В финале поговорим о том, каких успехов уже удалось добиться мировому сообществу на пути трансляции привычных языков запросов в операции линейной алгебры, 
%и каковы сейчас основные направления развития в этой области.

\title[Линейная алгебра и запросы к графам]{Линейная алгебра как основа для языка запросов к графам}
\institute[СПбГУ]{
Санкт-Петербургский Государственный Университет
}

\author[Семён Григорьев]{Семён Григорьев}

\date{09 декабря 2025}

\begin{document}
{
\begin{frame}[fragile]
  \begin{table}
  \centering  
  \begin{tabularx}{\linewidth}{XcX}
    \hfill
    & 
    & \hfill \includegraphics[height=1.4cm]{pictures/SPbSU_Logo.pdf}
  \end{tabularx}
  \end{table}
  \titlepage
\end{frame}
}

\begin{frame}[fragile]
  \frametitle{Семён Григорьев}
  \begin{minipage}{0.70\textwidth}
  \begin{itemize}    
    \item Доцент кафедры системного программирования Санкт-Петербургского Государственного Университета
    %\item Научный сотрудник лаборатории YADRO
    \item Руководитель исследовательской группы
    \item Области интересов
    \begin{itemize}
      \item \textbf{Высокопроизводительная линейная алгебра} для анализа графов
      \begin{itemize}
        \item \textbf{Обобщённая}: матрицы и вектора параметризованы типом элемента, операции над ними могут быть заданы пользователем
        \item \textbf{Разреженная}: специализированные структуры для хранения матриц и векторов, специализированные алгоритмы для их обработки 
        \item В том числе, с использованием \textbf{графических ускорителей}
      \end{itemize}
      \item \textbf{Высокопроизводительный анализ графов}      
    \end{itemize}
    \end{itemize}
\end{minipage}
\begin{minipage}[t]{0.29\textwidth}
  \begin{center}
\includegraphics[width=0.8\textwidth]{pictures/SemyonGrigorev.jpg}
  \end{center}
  {\scriptsize
\begin{itemize}    
  \item Email: s.v.grigoriev@mail.spbu.ru
  \item GitHub: \href{https://github.com/gsvgit}{gsvgit}
  \item Google Scholar: \href{https://scholar.google.com/citations?hl=ru&user=kP4dqUAAAAAJ&view_op=list_works&sortby=pubdate}{Semyon Grigorev}
  \item DBLP: \href{https://dblp.org/pid/181/9903.html}{Semyon V. Grigorev}
\end{itemize}
  }
\end{minipage}
\end{frame}

\begin{frame}[fragile]
  \frametitle{GraphBLAS\footnote{\url{https://graphblas.org/}}}
  \begin{itemize}
    \item API для создания алгоритмов анализа графов на основе линейной алгебры 
    \begin{itemize}
      \item Различные операции над матрицами и векторами (\underline{\textbf{разреженными}})
      \item Параметризация алгебраическими структурами: полукольцами, моноидами и т.д.
    \end{itemize}
    \item Позволяет выражать \underline{\textbf{различные}} алгоритмы
    \begin{itemize}
      \item Обход в ширину, поиск кратчайших путей, достижимость, \ldots
      \item Подсчёт треугольников, PageRank, остовные деревья, кластеризация, \ldots
      \item Навигационные запросы: \textbf{RPQ, CFPQ,} \ldots
    \end{itemize}
    \item Подробнее
    \begin{itemize}
      %\item The GraphBLAS C API Specification\footnote{\url{https://graphblas.org/docs/GraphBLAS_API_C_v2.1.0.pdf}}
      \item GraphBLAS Pointers\footnote{\url{https://graphblas.org/GraphBLAS-Pointers/}}
      \item \textbf{SuiteSparse:GraphBLAS}\footnote{\url{https://github.com/DrTimothyAldenDavis/GraphBLAS}} --- \underline{\textbf{эталон}} на чистом C
      \item \textbf{LAGraph}\footnote{\url{https://github.com/GraphBLAS/LAGraph}} --- коллекция \underline{\textbf{прикладных}} алгоритмов анализа графов
    \end{itemize}
    \end{itemize}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Отношения и матрицы}  
  \vspace{-0.3cm}
  \begin{minipage}[t]{0.49\textwidth}
    \onslide<1->{
    $R_1 = \{(\textcolor{blue}{a},\textcolor{red}{y});(\textcolor{blue}{b},\textcolor{red}{x});(\textcolor{blue}{b},\textcolor{red}{z})\}$\\
  $R_2 = \{(\textcolor{red}{x},\textcolor{green}{u});(\textcolor{red}{x},\textcolor{green}{w});(\textcolor{red}{y},\textcolor{green}{v});(\textcolor{red}{y},\textcolor{green}{w});(\textcolor{red}{z},\textcolor{green}{u})\}$\\
    }
  \onslide<2->{
  $R_3 = \{ (i,j) \mid (i,k) \in R_1, (k,j) \in R_2 \}$
    }
  \\  
  \vspace{-0.4cm}
      \NiceMatrixOptions{code-for-first-row = \color{red},
                     code-for-first-col = \color{blue},
                     code-for-last-row = \color{red},
                     code-for-last-col = \color{blue}}
\onslide<3->{
$$
\begin{pNiceArray}{ccc}[first-col,first-row,nullify-dots]
  & x & y & z \\
a & 0 & 1 & 0 \\
b & 1 & 0 & 1 \\
\end{pNiceArray}
\times
\NiceMatrixOptions{code-for-first-row = \color{green},
                     code-for-first-col = \color{red}}
\begin{pNiceArray}{ccc}[first-col,first-row,nullify-dots]
    & u & v & w \\
  x & 1 & 0 & 1 \\
  y & 0 & 1 & 1 \\
  z & 1 & 0 & 0 \\
\end{pNiceArray}
=
\NiceMatrixOptions{code-for-first-row = \color{green},
                     code-for-first-col = \color{blue}}
\begin{pNiceArray}{ccc}[first-col,first-row,nullify-dots]
    & u & v & w \\
  a & 0 & 1 & 1 \\
  b & 1 & 0 & 1 \\  
\end{pNiceArray}
$$
}
\vspace{-0.4cm}
\onslide<4->{
\begin{center}
\begin{tikzpicture}[shorten >=1pt,auto]
    \node[state,fill=blue!20] (q_0)                      {$a$};
    \node[state,fill=blue!20] (q_1) [below = of q_0 ]    {$b$};

    \node[state,fill=red!20] (q_2)  [right = of q_0 ]    {$x$};
    \node[state,fill=red!20] (q_3)  [right = of q_1 ]    {$y$};
    \node[state,fill=red!20] (q_4)  [below = of q_3 ]    {$z$};
    
    \node[state,fill=green!20] (q_5)  [right = of q_2 ]    {$u$};
    \node[state,fill=green!20] (q_6)  [right = of q_3 ]    {$v$};
    \node[state,fill=green!20] (q_7)  [right = of q_4 ]    {$w$};

    \onslide<5->
{
    \path[->]
    (q_0) edge  node {} (q_3)
    (q_1) edge  node {} (q_2)
    (q_1) edge  node {} (q_4);
}
\onslide<6->
{
     \path[->]    
    (q_2) edge  node {} (q_5)
    (q_2) edge  node {} (q_7)
    (q_3) edge  node {} (q_6)
    (q_3) edge  node {} (q_7)
    (q_4) edge  node {} (q_5);
}
\onslide<7->
{
 \path[->,red]
   (q_0) edge  node {} (q_6)
   (q_0) edge[bend right=20]  node {} (q_7)
   (q_1) edge  node {} (q_5)
   (q_1) edge[bend right=10]  node {} (q_7)
   ;
}
\end{tikzpicture}
\end{center}
}
  \end{minipage}
  \begin{minipage}[t]{0.45\textwidth}
    \onslide<1->{
    \scriptsize{
    \begin{flalign*}
     &|S_A| = n, |S_B| = k, |S_C| = m  \\
     &\mathcal{N_A}: [0\ldots (n-1)] \to S_A,\text{ биекция} \\
     &\mathcal{N_B}: [0\ldots (k-1)] \to S_B,\text{ биекция} \\
     &\mathcal{N_C}: [0\ldots (m-1)] \to S_C,\text{ биекция} \\
     & R_1 \subseteq S_A \times S_B, R_2 \subseteq S_B \times S_C \\     
     & R_3 = \{ (x,z) \mid (x,y) \in R_1, (y,z) \in R_2 \} \\
     & M_{n \times k}^{R_1} = 1 \iff (\mathcal{N_A}(i),\mathcal{N_B}(j)) \in R_1 \text{, иначе } M^{R_1} = 0 \\
     & M_{k \times m}^{R_2} = 1 \iff (\mathcal{N_B}(i),\mathcal{N_C}(j)) \in R_2 \text{, иначе } M^{R_2} = 0 \\
     & M_{n \times m}^{R_3} = M^{R_1} \times M^{R_2}
    \end{flalign*}
    }    
    }
  \end{minipage}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Умножение матриц и <<полукольца>>}
  %\vspace{-0.5cm}
  \begin{minipage}[t]{0.35\textwidth}
  \vspace{-0.8cm}
  \onslide<1->{
  \begin{align*}
  & C_{n \times n} = A_{n \times n} \times B_{n \times n} \\
  & C[i,j] = \sum_{k=0}^{n-1} A[i,k] * B[k,j] \\
  \end{align*}
  }
  \vspace{-1.5cm}
  \onslide<2->{
  \begin{align*}
  & A: \texttt{Matrix}\langle T_1 \rangle \\
  & B: \texttt{Matrix} \langle T_2 \rangle \\
  & C: \texttt{Matrix}\langle T_3 \rangle \\
  \end{align*}
  \vspace{-1.5cm}
  }
  \onslide<3->{
  \begin{align*}
  & \otimes: T_1 \times T_2 \to T_3 \\
  & \oplus: T_3 \times T_3 \to T_3 \\ 
  & \vmathbb{0}: T_3 \\
  \end{align*}
  }
  \vspace{-1.5cm}
  \onslide<4->{
  \begin{align*}
  & C[i,j] = \bigoplus_{k=0}^{n-1} A[i,k] \otimes B[k,j]
  \end{align*}
  }
  \end{minipage}
  \begin{minipage}[t]{0.55\textwidth}
    \onslide<5->{
  $\otimes: (\texttt{int} \times \texttt{int} \times T_1) 
  \times (\underbrace{\texttt{int} \times \texttt{int}}_{\mathclap{\text{Координаты обрабатываемого элемента}}} \times T_2) \to T_3 $
  }
  \\
  \onslide<1->{
%\vspace{2cm}
  \NiceMatrixOptions{code-for-first-row = \color{red},
                     code-for-first-col = \color{blue},
                     code-for-last-row = \color{red},
                     code-for-last-col = \color{blue}}
$$
\begin{pNiceArray}{cccc}[first-col,last-col,nullify-dots]
  &  & \Cdots &  &  & \\
i & a_{i0} & \Cdots & & a_{i(k-1)} & i \\
  &  & \Cdots &  &  & \\
  &  & \Cdots &  &  & 
\end{pNiceArray}
\times
\begin{pNiceArray}{cccc}[first-row,last-row=5,nullify-dots]
 & & j &                             \\
   &              & b_{0j} &         \\
  \Vdots & \Vdots & \Vdots & \Vdots  \\
   &              &        &         \\
   &              & b_{(k-1)j} &     \\
 & & j &  
\end{pNiceArray}
=
\begin{pNiceArray}{cccc}[first-col,last-col,first-row,last-row=5,nullify-dots]
   &         &        & j       &        &   \\
   &         &         & \Vdots  &        &   \\
 i & \Cdots  & \Cdots  & c_{ij} & \Cdots & i \\
   &          &        & \Vdots &        &  \\
   &          &        & \Vdots &        &  \\
   &         & & j       &        & 
\end{pNiceArray}
$$
}
\begin{center}
\onslide<6->{
\vspace{-0.7cm}
\begin{tikzpicture}[shorten >=1pt,auto]
    \node[state,fill=blue!20] (q_0)                      {$i$};
    \node[state] (q_1) [right = of q_0 ]    {$k_0$};

    \node[state] (q_2)  [below = of q_1 ]    {$k_1$};
    \node[state,fill=red!20] (q_3)  [right = of q_1]    {$j$};    

    \path[->]
    (q_0) edge  node {$a_0$} (q_1)
    (q_0) edge[right]  node {$a_1$} (q_2)
    (q_1) edge  node {$b_0$} (q_3)
    (q_2) edge[right]  node {$b_1$} (q_3);
    \onslide<7->
{
 \path[->,red]
   (q_0) edge[bend left=40]  node {$ a_0 \otimes b_0 \oplus a_1 \otimes b_1 $} (q_3)
   ;
}
\end{tikzpicture}
}
\end{center}
\end{minipage}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Обход в ширину}
  \begin{minipage}{0.2\textwidth}
  \begin{tikzpicture}[shorten >=1pt,auto]
    \node[state] (q_0)                      {$0$};
    \node[state] (q_1) [above right=of q_0] {$1$};
    \node[state,fill=red!20] (q_2) [right=of q_0]       {$2$};
    \node[state] (q_3) [right=of q_2]       {$3$};
    \path[->]
    (q_0) edge  node {} (q_1)
    (q_1) edge  node {} (q_2)
    (q_2) edge  node {} (q_0)
    (q_2) edge[bend left, above]  node {} (q_3)
    (q_3) edge[bend left, below]  node {} (q_2);
    \end{tikzpicture}
  \end{minipage}~\pause
  \tikzmark{xPos}{}
  \begin{minipage}{0.75\textwidth}    
    \begin{equation*}
      \left(\begin{array}{cccc}        
        0  & 0  & \colR 1 & 0 \\        
      \end{array}\right)
      \times    
      \left(\begin{array}{cccc}        
        0 & 1 & 0 & 0 \\
        0 & 0 & 1 & 0 \\
        \rowcolor{red!20}
        1 & 0 & 0 & 1 \\
        0 & 0 & 1 & 0 \\        
      \end{array}\right)
      =      
        \left(\begin{array}{cccc}        
          \colB 1 & 0  & 0 & \colB 1 \\        
        \end{array}\right)
    \end{equation*}
    \mycallout<2->[opacity=1]{$(xPos) + (2.4,0.3)$}{Текущий фронт}{2.5}
    \mycallout<2->[opacity=1]{$(xPos) + (5.6,0.9)$}{Матрица смежности}{3.5}
    \mycallout<2->[opacity=1]{$(xPos) + (8.7,0.3)$}{Новый фронт}{2.5}
    \mycalloutR<2->[opacity=1]{$(xPos) + (3.7,0.08)$}{Полукольцо}{2.1}
    \onslide<2->{  
    \begin{tikzpicture}[overlay,remember picture,auto]
        \draw (6.7, 0.59) node[] {$\left(\begin{array}{cccc}        
        0  & 0  & \colR 1 & 0 \\        
      \end{array}\right)$};
    \end{tikzpicture}
    \mycalloutR<2->[opacity=1]{6.7, 0.62}{Посещённые вершины}{4.4}
    }
  \end{minipage}

  \pause

  \begin{minipage}{0.2\textwidth}
    \begin{tikzpicture}[shorten >=1pt,auto]
      \node[state, fill=blue!20] (q_0)                      {$0$};
      \node[state] (q_1) [above right=of q_0] {$1$};
      \node[state, fill=red!20] (q_2) [right=of q_0]       {$2$};
      \node[state, fill=blue!20] (q_3) [right=of q_2]       {$3$};
      \path[->]
      (q_0) edge  node {} (q_1)
      (q_1) edge  node {} (q_2)
      (q_2) edge  node {} (q_0)
      (q_2) edge[bend left, above]  node {} (q_3)
      (q_3) edge[bend left, below]  node {} (q_2);
      \end{tikzpicture}
    \end{minipage}~
    \begin{minipage}{0.75\textwidth}
    \begin{equation*}
      \left(\begin{array}{cccc}        
        \colB 1 & 0  & 0 & \colB 1 \\        
      \end{array}\right)
      \times
      \left(\begin{array}{cccc}        
        \rowcolor{blue!20}
        0 & 1 & 0 & 0 \\
        0 & 0 & 1 & 0 \\        
        1 & 0 & 0 & 1 \\
        \rowcolor{blue!20}
        0 & 0 & 1 & 0 \\        
      \end{array}\right)
      =      
        \left(\begin{array}{cccc}        
          0 & \colG 1  & \colG 1 & 0 \\        
        \end{array}\right)
    \end{equation*}
    \begin{tikzpicture}[overlay,remember picture,auto]
        \draw (7.87, 0.59) node[] {$\left(\begin{array}{cccc}        
        \colB 1  & 0  & \colR 1 & \colB 1 \\        
      \end{array}\right)$};
    \end{tikzpicture}
    \pause     
    \begin{tikzpicture}[overlay,remember picture,auto]
        \draw (8.0, 1.39) node[cross=10pt, color=red] {};
    \end{tikzpicture}
    \pause 
    %\vfill
    $$\text{result: } \left(\begin{array}{cccc}        
        \colB 1  & \colG 1  & \colR 1 & \colB 1 \\        
      \end{array}\right)$$
  \end{minipage}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Обход в ширину с построением дерева обхода}
  \onslide<2->{  
  $p \otimes (i,j,\_) = i$: получаем предка\\
  $i_1 \oplus i_2 = i_1$: из нескольких возможных предков возьмём первого \\
  }
  \begin{minipage}{0.2\textwidth}
  \begin{tikzpicture}[shorten >=1pt,auto]
    \node[state] (q_0)                      {$0$};
    \node[state] (q_1) [above right=of q_0] {$1$};
    \node[state,fill=red!20] (q_2) [right=of q_0]       {$2$};
    \node[state] (q_3) [right=of q_2]       {$3$};
    \path[->]
    (q_0) edge  node {} (q_1)
    (q_1) edge  node {} (q_2)
    (q_2) edge  node {} (q_0)
    (q_2) edge[bend left, above]  node {} (q_3)
    (q_3) edge[bend left, below]  node {} (q_2);
    \end{tikzpicture}
  \end{minipage}~\pause
  \tikzmark{xPos}{}
  \begin{minipage}{0.75\textwidth}    
    \begin{equation*}
      \left(\begin{array}{cccc}        
        \_  & \_  & \colR -1 & \_ \\        
      \end{array}\right)
      \times    
      \left(\begin{array}{cccc}        
        0 & 1 & 0 & 0 \\
        0 & 0 & 1 & 0 \\
        \rowcolor{red!20}
        1 & 0 & 0 & 1 \\
        0 & 0 & 1 & 0 \\        
      \end{array}\right)
      =      
        \left(\begin{array}{cccc}        
          \colB 2 & \_  & \_ & \colB 2 \\        
        \end{array}\right)
    \end{equation*}
    \mycallout<2->[opacity=1]{$(xPos) + (2.6,0.3)$}{У стартовой нет предка}{4.5}
    %\mycallout<2-4>[opacity=1]{$(xPos) + (5.9,1.1)$}{Матрица смежности}{3.5}
    \mycallout<2->[opacity=1]{$(xPos) + (9.65,0.3)$}{Стартовая --- предок}{3.5}
    \mycalloutR<2->[opacity=1]{$(xPos) + (3.65,-0.1)$}{<<Нейтральный элемент>>}{3.2}
    \onslide<2->{  
    \begin{tikzpicture}[overlay,remember picture,auto]
        \draw (7.45, 0.59) node[] {$\left(\begin{array}{cccc}        
        \_  & \_  & \colR -1 & \_ \\        
      \end{array}\right)$};
    \end{tikzpicture}
    }
  \end{minipage}

  \pause

  \begin{minipage}{0.2\textwidth}
    \begin{tikzpicture}[shorten >=1pt,auto]
      \node[state, fill=blue!20] (q_0)                      {$0$};
      \node[state] (q_1) [above right=of q_0] {$1$};
      \node[state, fill=red!20] (q_2) [right=of q_0]       {$2$};
      \node[state, fill=blue!20] (q_3) [right=of q_2]       {$3$};
      \path[->]
      (q_0) edge  node {} (q_1)
      (q_1) edge  node {} (q_2)
      (q_2) edge  node {} (q_0)
      (q_2) edge[bend left, above]  node {} (q_3)
      (q_3) edge[bend left, below]  node {} (q_2);
      \end{tikzpicture}
    \end{minipage}~
    \begin{minipage}{0.75\textwidth}
    \begin{equation*}
      \left(\begin{array}{cccc}        
        \colB 2 & \_  & \_ & \colB 2 \\        
      \end{array}\right)
      \times
      \left(\begin{array}{cccc}        
        \rowcolor{blue!20}
        0 & 1 & 0 & 0 \\
        0 & 0 & 1 & 0 \\        
        1 & 0 & 0 & 1 \\
        \rowcolor{blue!20}
        0 & 0 & 1 & 0 \\        
      \end{array}\right)
      =      
        \left(\begin{array}{cccc}        
          \_ & \colG 0  & \colG 3 & \_ \\        
        \end{array}\right)
    \end{equation*}
    \begin{tikzpicture}[overlay,remember picture,auto]
        \draw (8.21, 0.59) node[] {$\left(\begin{array}{cccc}        
        \colB 2  & 0  & \colR -1 & \colB 2 \\        
      \end{array}\right)$};
    \end{tikzpicture}
    \pause     
    \begin{tikzpicture}[overlay,remember picture,auto]
        \draw (8.32, 1.39) node[cross=10pt, color=red] {};
    \end{tikzpicture}
  \end{minipage}
  \pause
  \vspace{-0.3cm}
  \begin{center}
   $$ \text{result: } \left(\begin{array}{cccc}
         \colB 2  & \colG 0  & \colR -1 & \colB 2 \\        
      \end{array}\right)$$ 
  \end{center}
  \pause
  \begin{tikzpicture}[overlay,remember picture,auto]
        \draw [->] (7.9, 0.55) to [bend left=45] (7.35, 0.55)  {};
  \end{tikzpicture}
  \pause
  \begin{tikzpicture}[overlay,remember picture,auto]
        \draw [->] (7.35, 1.01) to [bend left=45] (8.45, 1.01)  {};
  \end{tikzpicture}
    
\end{frame}

\begin{frame}[fragile]
  \frametitle{Выбор входящих и исходящих (инцидентных) рёбер}  
    Выбор входящих рёбер --- умножение на диагональную матрицу справа\\
    \begin{minipage}{0.2\textwidth}  
    \begin{tikzpicture}[shorten >=1pt,auto]
      \node[state, fill=blue!20] (q_0)                      {$0$};
      \node[state] (q_1) [above right=of q_0] {$1$};
      \node[state, fill=red!20] (q_2) [right=of q_0]       {$2$};
      \node[state] (q_3) [right=of q_2]       {$3$};
      \path[->]
      (q_0) edge  node {} (q_1)
      (q_1) edge  node {} (q_2)
      (q_2) edge  node {} (q_0)
      (q_2) edge[bend left, above]  node {} (q_3)
      (q_3) edge[bend left, below]  node {} (q_2);
      \onslide<2->
      {
        \path[->, red, thick]
        (q_1) edge node {} (q_2)
        (q_2) edge  node {} (q_0)
        (q_3) edge[bend left, below]  node {} (q_2);
      }
      \end{tikzpicture}      
    \end{minipage}
    \begin{minipage}{0.75\textwidth}
      $$
     \left(\begin{array}{>{\columncolor{blue!20}}cc>{\columncolor{red!20}}cc}
        0 & 1 & 0 & 0 \\
        0 & 0 & 1 & 0 \\
        1 & 0 & 0 & 1 \\
        0 & 0 & 1 & 0 \\
      \end{array}\right)
      \times
       \left(\begin{array}{>{\columncolor{blue!20}}cc>{\columncolor{red!20}}cc}
        1 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 \\
        0 & 0 & 1 & 0 \\
        0 & 0 & 0 & 0 \\
      \end{array}\right)
      =
      \onslide<2->{
      \left(\begin{array}{cccc}
        0 & 0 & 0 & 0 \\
        0 & 0 & \cellcolor{red!20}{1} & 0 \\
        \cellcolor{blue!20}{1} & 0 & 0 & 0 \\
        0 & 0 & \cellcolor{red!20}{1} & 0 \\
      \end{array}\right)
      }              
    $$
  \end{minipage}\\ 
  \vfill
  \onslide<3->{ 
    Выбор исходящих рёбер --- умножение на диагональную матрицу слева\\
    \begin{minipage}{0.2\textwidth}  
    \begin{tikzpicture}[shorten >=1pt,auto]
      \node[state, fill=blue!20] (q_0)                      {$0$};
      \node[state] (q_1) [above right=of q_0] {$1$};
      \node[state, fill=red!20] (q_2) [right=of q_0]       {$2$};
      \node[state] (q_3) [right=of q_2]       {$3$};
      \path[->]
      (q_0) edge  node {} (q_1)
      (q_1) edge  node {} (q_2)
      (q_2) edge  node {} (q_0)
      (q_2) edge[bend left, above]  node {} (q_3)
      (q_3) edge[bend left, below]  node {} (q_2);
      \onslide<4->
      {
        \path[->, red, thick]
        (q_0) edge  node {} (q_1)
        (q_2) edge  node {} (q_0)
      (q_2) edge[bend left, above]  node {} (q_3);
      }
      \end{tikzpicture}      
    \end{minipage}
    \begin{minipage}{0.75\textwidth}
      $$
     \left(\begin{array}{cccc}
        \rowcolor{blue!20}
        1 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 \\
        \rowcolor{red!20}
        0 & 0 & 1 & 0 \\
        0 & 0 & 0 & 0 \\
      \end{array}\right)
      \times
      \left(\begin{array}{cccc}
        \rowcolor{blue!20}
        0 & 1 & 0 & 0 \\
        0 & 0 & 1 & 0 \\
        \rowcolor{red!20}
        1 & 0 & 0 & 1 \\
        0 & 0 & 1 & 0 \\
      \end{array}\right)      
      =
      \onslide<4->{
      \left(\begin{array}{cccc}
        0 & \cellcolor{blue!20}{1} & 0 & 0 \\
        0 & 0 & 0 & 0 \\
        \cellcolor{red!20}{1} & 0 & 0 & \cellcolor{red!20}{1} \\
        0 & 0 & 0 & 0 \\
      \end{array}\right)}              
    $$
  \end{minipage} 
  } 
\end{frame}

\begin{frame}[fragile]
  \frametitle{Пример\footnote{Код и описание: \url{https://github.com/SparseLinearAlgebra/PageRankBenchmark}}}
  \begin{itemize}
    \item Граф с двумя типами вершин: пользователи и карты
    \begin{itemize}
      \item \ <<Пользователь>>: пол, возраст
      \item \ <<Карта>>: тип (МИР, VISA, MASTERCARD), лимит средств
    \end{itemize}
    \pause
    \item Два типа ориентированных рёбер
    \begin{itemize}
      \item \ <<Перевод>>: соединяет две карты (откуда и куда перевод)
      \begin{itemize}
        \item Метка: общая сумма и <<количество транзакций>>
      \end{itemize}
      \item  \ <<Владеет>>: соединяет пользователя и карту (от владельца карты к карте)
      \begin{itemize}
        \item Не имеет меток
      \end{itemize}
    \end{itemize}
  \end{itemize}
  \vfill\pause
  \begin{enumerate}
    \item Выбрать хотим все карты системы <<МИР>>, которыми владеют люди старше заданного возраста
    \item Посчитать PageRank на подграфе, заданном переводами между отобранными картами
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]
  %\frametitle{Пример графа}
  \begin{center}
  \includegraphics[width=0.95\textwidth]{pictures/Graph.pdf}
  \end{center}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Представление графа}
  \begin{itemize}[<+->]
    \item Пользовательские типы (структуры) для описания пользователя, карты, информации о переводах: \texttt{User}, \texttt{Card}, \texttt{Trans}
    \item Булева матрица $\texttt{Own\_Edges}_{12 \times 12}$ задаёт отношение <<Владеет>>
    \item Матрица $\texttt{Trans\_Edges}_{12 \times 12}$ типа \texttt{Matrix<Trans>} задаёт отношение <<Перевод>>
    \item Вектор пользователей $\texttt{Users}_{12}$ хранит данные о пользователях
    \item Вектор карт $\texttt{Cards}_{12}$ хранит данные о картах
  \end{itemize}
\end{frame}

%\begin{frame}[fragile]
%  \frametitle{Шаги}
%  
%  \begin{itemize}
%    \item<2-> Выбираем пользователей старше 30 лет 
%    \begin{itemize}
%      \item \texttt{s\_users = Select(filter, Users)}
%      \item \texttt{filter} --- пользовательский предикат
%    \end{itemize} 
%    \item<3-> Выбираем карты пользователей
%    \begin{itemize}
%      \item Один шаг обхода в ширину
%      \item \texttt{s\_cards = s\_users * Owns\_Edges}
%      \item \texttt{s\_cards} --- не сами карты, а их индексы
%    \end{itemize} 
%    \item<4-> Выбираем карты <<МИР>>
%    \begin{itemize}
%      \item \texttt{s\_cards} используем как маску
%      \item \texttt{s\_cards' = Mask(s\_cards, Select(filter', Cards))}
%    \end{itemize} 
%    \item<5-> Выбираем переводы между отобранными картами
%    \begin{itemize}
%      \item Рёбра, идущие \textbf{только} между выбранными картами
%      \item \texttt{cards\_subgraph = Diag(s\_cards') * Trans * Diag(s\_cards')}
%    \end{itemize} 
%  \end{itemize}
%  
%  \begin{tikzpicture}[remember picture, overlay]
%        \node (mybox) at ([xshift=-5.0cm,yshift=-3.8cm]current page.north east) { % Position the box
%            \begin{minipage}{0.6\textwidth} % Define the box content area
%                \centering
%                \only<1>{\includegraphics[width=0.95\textwidth]{pictures/Graph.pdf}}
%                \only<2>{\includegraphics[width=0.95\textwidth]{pictures/Graph_select_users.pdf}}
%                \only<3>{\includegraphics[width=0.95\textwidth]{pictures/Graph_select_cards_1.pdf}}
%                \only<4>{\includegraphics[width=0.95\textwidth]{pictures/Graph_select_cards_MIR.pdf}}
%                \only<5>{\includegraphics[width=0.95\textwidth]{pictures/Graph_select_subgraph.pdf}}
%            \end{minipage}
%        };
%    \end{tikzpicture}
%
%  
%
%\end{frame}
%
%
%\begin{frame}[fragile]
%  \frametitle{Шаги}
%  
%  \begin{itemize}
%    \item<2-> Выбираем пользователей старше 30 лет 
%    \begin{itemize}
%      \item \texttt{s\_users = Select(filter, Users)}
%      \item \texttt{filter} --- пользовательский предикат
%    \end{itemize} 
%    \item<3-> Выбираем карты пользователей
%    \begin{itemize}
%      \item Один шаг обхода в ширину
%      \item \texttt{s\_cards = s\_users * Owns\_Edges}
%      \item \texttt{s\_cards} --- не сами карты, а их индексы
%    \end{itemize} 
%    \item<4-> Выбираем карты <<МИР>>
%    \begin{itemize}
%      \item \texttt{s\_cards} используем как маску
%      \item \texttt{s\_cards' = Mask(s\_cards, Select(filter', Cards))}
%    \end{itemize} 
%    \item<5-> Выбираем переводы между отобранными картами
%    \begin{itemize}
%      \item Рёбра, идущие \textbf{только} между выбранными картами
%      \item \texttt{cards\_subgraph = Diag(s\_cards') * Trans * Diag(s\_cards')}
%    \end{itemize} 
%  \end{itemize}
%  
%  \begin{tikzpicture}[remember picture, overlay]
%        \node (mybox) at ([xshift=12.0cm,yshift=-3.8cm]current page.north west) { % Position the box
%            \begin{minipage}{0.6\textwidth} % Define the box content area
%                \centering
%                \only<1>{\includegraphics[width=0.95\textwidth]{pictures/Graph.pdf}}
%                \only<2>{\includegraphics[width=0.95\textwidth]{pictures/Graph_select_users.pdf}}
%                \only<3>{\includegraphics[width=0.95\textwidth]{pictures/Graph_select_cards_1.pdf}}
%                \only<4>{\includegraphics[width=0.95\textwidth]{pictures/Graph_select_cards_MIR.pdf}}
%                \only<5>{\includegraphics[width=0.95\textwidth]{pictures/Graph_select_subgraph.pdf}}
%            \end{minipage}
%        };
%    \end{tikzpicture}
%
%  
%
%\end{frame}

\begin{frame}[fragile]
  \frametitle{Построение подграфа}
  \begin{minipage}{0.5\textwidth}\vspace{-4.2cm}
  \begin{itemize}
    \item<2-> Выбираем пользователей старше 30 лет 
    \begin{itemize}
      \item \texttt{s\_users = Choose(filter, Users)}
      \item \texttt{filter} --- пользовательский предикат
    \end{itemize} 
    \item<3-> Выбираем карты пользователей
    \begin{itemize}
      \item Один шаг обхода в ширину
      \item \texttt{s\_cards = s\_users * Owns\_Edges}
      \item \texttt{s\_cards} --- не карты, а их индексы
    \end{itemize} 
  \end{itemize}
  \end{minipage}    
  \begin{minipage}[t]{0.48\textwidth}    
  \begin{center}
  \only<1>{\includegraphics[width=\textwidth]{pictures/Graph.pdf}}
  \only<2>{\includegraphics[width=\textwidth]{pictures/Graph_select_users.pdf}}
  \only<3>{\includegraphics[width=\textwidth]{pictures/Graph_select_cards_1.pdf}}
  \only<4>{\includegraphics[width=\textwidth]{pictures/Graph_select_cards_MIR.pdf}}
  \only<5>{\includegraphics[width=\textwidth]{pictures/Graph_select_subgraph.pdf}}
  \end{center}
  \vfill
\end{minipage}
\begin{itemize}
\item<4-> Выбираем карты <<МИР>>
    \begin{itemize}
      \item \texttt{s\_cards} используем как маску
      \item \texttt{s\_cards' = Mask(s\_cards, Choose(filter', Cards))}
    \end{itemize} 
    \item<5-> Выбираем переводы между отобранными картами
    \begin{itemize}
      \item Рёбра, идущие \textbf{только} между выбранными картами
      \item \texttt{cards\_subgraph = Diag(s\_cards') * Trans\_Edges * Diag(s\_cards')}
    \end{itemize} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Получение матрицы весов по данным о переводах}
  \begin{itemize}[<+->]
    \item Преобразовываем структуры (метки рёбер) в веса: $f(w) = \frac{w.Sum}{w.Count * 1000}$
    \item Сумма весов исходящих рёбер равна 1: $SoftMax (\overrightarrow{z})_{i}={\frac {e^{f(z_{i})}}{\displaystyle \sum _{k\mathop {=} 1}^{K}e^{f(z_{k})}}}$
    \item Знаменатель: \texttt{W = ReduceRows(+, Map(f,cards\_subgraph))}
    \item Элементы \texttt{W} на нужных местах: \texttt{D = Mask(cards\_subgraph, $M_W \times M_1$)}
    $$ \texttt{Mask} \left(
    \begin{pNiceArray}{ccc}[nullify-dots]
 0 & c_0 & 0 \\
 c_2 & 0 & c_1 \\
 c_3 & 0 & 0  \\
\end{pNiceArray}
,
    \begin{pNiceArray}{ccc}[first-row,nullify-dots]
   W &  &  \\
   w_0 & 0 & 0 \\
   w_1 & 0 & 0 \\
   w_2 & 0 & 0 \\
\end{pNiceArray}
\times
\begin{pNiceArray}{ccc}[nullify-dots]
1 & 1 & 1 \\
0 & 0 & 0 \\
0 & 0 & 0 \\
\end{pNiceArray}
\right)
= \begin{pNiceArray}{ccc}[nullify-dots]

 0 & w_0 & 0 \\
 w_1 & 0 & w_1 \\
 w_2 & 0 & 0  \\
\end{pNiceArray}
$$
    \item Матрица весов $\mathcal{W}$ --- поэлементное деление матриц: \texttt{Map(f,cards\_subgraph)/D}
    \end{itemize}

%\onslide<4->{
%  \begin{tikzpicture}[overlay,remember picture,auto]
%        \draw [->,red,thick] (12.5, 4.01) to [bend right=1] (9.0, 3.20)  {};
%        \draw [->,red,thick] (11.6, 4.01) to [bend right=1] (7.05, 3.20)  {};
%        \draw [->,red,thick] (8.8, 4.01) to [bend right=5] (5.35, 3.20)  {};
%    \end{tikzpicture}
%}

\end{frame}

\begin{frame}[fragile]
  \frametitle{PageRank}
  \begin{itemize}
  \item Что: ранжирование вершин по их <<важности>>
  \begin{itemize}
    \item Оригинальная идея: вероятность попасть в вершину при случайном блуждании по графу
  \end{itemize}
  \pause
  \item Зачем (например): выделение <<подозрительных>> вершин в графе транзакций
  \pause
  \item Как: по определению
  \begin{itemize}
    \item Матрица весов рёбер: $\mathcal{W}$
    \item Вектор (столбец) весов вершин: $v$
    \item Итерируем $v = \mathcal{W} \times v$ пока изменения $v$ значимы
  \end{itemize}
\end{itemize}
\end{frame}

%\begin{frame}[fragile]
%  \frametitle{Шаги}
%  \begin{minipage}{0.6\textwidth}
%  \begin{itemize}
%    \item<2-> Выбираем пользователей старше 30 лет 
%    \begin{itemize}
%      \item \texttt{s\_users = Select(filter, Users)}
%      \item \texttt{filter} --- пользовательский предикат
%    \end{itemize} 
%    \item<3-> Выбираем карты пользователей
%    \begin{itemize}
%      \item Один шаг обхода в ширину
%      \item \texttt{s\_cards = s\_users * Owns\_Edges}
%      \item \texttt{s\_cards} --- не сами карты, а их индексы
%    \end{itemize} 
%    \item<4-> Выбираем карты <<МИР>>
%    \begin{itemize}
%      \item \texttt{s\_cards} используем как маску
%      \item \texttt{s\_cards' = Mask(s\_cards, Select(filter', Cards))}
%    \end{itemize} 
%    \item<5-> Выбираем переводы между отобранными картами
%    \begin{itemize}
%      \item Рёбра, идущие \textbf{только} между выбранными картами
%      \item \texttt{cards\_subgraph = Diag(s\_cards') * Trans * Diag(s\_cards')}
%    \end{itemize} 
%  \end{itemize}
%  \end{minipage}
%  \vspace{-0.5cm}
%  \begin{minipage}[t]{0.38\textwidth}
%    \vspace{-3cm}
%  \begin{center}
%  \only<1>{\includegraphics[width=0.99\textwidth]{pictures/Graph.pdf}}
%  \only<2>{\includegraphics[width=0.99\textwidth]{pictures/Graph_select_users.pdf}}
%  \only<3>{\includegraphics[width=0.99\textwidth]{pictures/Graph_select_cards_1.pdf}}
%  \only<4>{\includegraphics[width=0.99\textwidth]{pictures/Graph_select_cards_MIR.pdf}}
%  \only<5>{\includegraphics[width=0.99\textwidth]{pictures/Graph_select_subgraph.pdf}}
%  \end{center}
%  \vfill
%\end{minipage}
%\end{frame}
%
%\newcommand{\e}[2]{\Block[l]{}{\{\\ \ Sum: {#1} \\ \ Count: {#2} \\ \}}}
%
%\begin{frame}[fragile]
%  \frametitle{Пример графа}
%  %\resizebox{.5\textwidth}{!}{
%  \tiny{
%$$
%  \begin{pNiceArray}{cccccccccccc}[first-col,first-row, nullify-dots]
%   & 0 & 1 & 2 & 3 & 4              & 5               & 6 & 7 & 8 & 9 & 10 & 11  \\
%0  &   &   &   &   &                &                 &   &   &   &   &    &     \\
%1  &   &   &   &   &                &                 &   &   &   &   &    &     \\
%2  &   &   &   &   &                &                 &   &   &   &   &    &     \\
%3  &   &   &   &   &                &                 &   &   &   &   &    &     \\ 
%4  &   &   &   &   &                & \e{23412}{6}    &   &   & \e{62412}{9} &   & \e{99999.1}{5} &     \\ 
%5  &   &   &   &   & \e{13214.1}{5} &                 & \e{81312}{7} &   & \e{92223}{9} &   &  \e{19999.1}{6} &     \\
%6  &   &   &   &   &                &                 &   &   &   &   &    & \e{8999.1}{7} \\
%7  &   &   &   &   &                &                 &   &   &   &   &    &     \\
%8  &   &   &   &   & \e{16325.99}{5}&                 &   &   &   &   &    & \e{49999.1}{12} \\
%9  &   &   &   &   &                &                 &   &   &   &   &    &     \\
%10 &   &   &   &   & \e{79999.1}{15}   & \e{69999.1}{16} &   &   &   &   &    &     \\
%11 &   &   &   &   &                &                 & \e{59999.1}{12} &   & \e{999999.1}{9} &   &    &    
%\end{pNiceArray}
%$$
%  }
%  %}
%\end{frame}



\begin{frame}[fragile]
  \frametitle{Линейная алгебра и языки запросов}
  \begin{itemize}
    \item FalkorDB и Cypher
    \begin{itemize}
      \item \href{https://www.falkordb.com/}{FalkorDB} --- графовая БД на основе линейной алгебры (SuiteSparse:GraphBLAS)
      \item Поддерживает подмножество Cypher
      \item Транслятор подмножества Cypher в операции линейной алгебры
    \end{itemize}
    \pause
    \item Разное про SQL
    \begin{itemize}
      \item \href{https://ieeexplore.ieee.org/document/10363601}{TenSQL: An SQL Database Built on GraphBLAS}
      \item \href{https://dl.acm.org/doi/abs/10.1145/3514221.3517869}{TCUDB: Accelerating Database with Tensor Processors}
      \item \ldots
    \end{itemize}
    \pause
    \item Линейная алгебра как основа для анализа данных
    \begin{itemize}
      \item \href{https://www.di.uminho.pt/~jno/ps/infoblender16sl.pdf}{Towards a linear algebra semantics for SQL}
      \item \href{https://dl.acm.org/doi/10.1145/3318464.3380607}{Fast Join Project Query Evaluation using Matrix Multiplication}
      \item \href{https://dl.acm.org/doi/10.1145/3651599}{Fast Matrix Multiplication for Query Processing}
      \item \href{https://dl.acm.org/doi/10.1007/s00165-014-0316-9}{A linear algebra approach to OLAP}
      \item \href{https://dl.acm.org/doi/abs/10.1145/3452021.3458314}{Expressive Power of Linear Algebra Query Languages}
      \item \href{https://www.sciencedirect.com/science/article/abs/pii/S0304397522005308}{On the expressiveness of Lara: A proposal for unifying linear and relational algebra}
    \end{itemize}
    %\item !!! Ещё Что-то??? !!!!
    \end{itemize}
\end{frame}



\end{document}
