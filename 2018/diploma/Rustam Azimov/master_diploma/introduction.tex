% У введения нет номера главы
\section*{Introduction}

Graph data models are widely used in many areas, for example, graph databases~\cite{graphDB}, bioinformatics~\cite{Bio}, static analysis~\cite{zhang2013fast, kodumal2004set}, etc. In these areas, it is often required to process queries for large graphs. The most common type of graph queries is navigational query. The result of a query evaluation is a set of implicit relations between the nodes of the graph, i.e. a set of paths. A natural way to specify these relations is to specify the paths using some form of formal grammars (regular expressions, context-free grammars) over the alphabet of edge labels. Context-free grammars are actively used in graph querying because of the limited expressive power of regular expressions. For example, classical \emph{same-generation queries}~\cite{FndDB} cannot be expressed using regular expressions.

The result of a context-free path query (CFPQ) evaluation is usually a set of triples \mbox{$(A, m, n)$}, such that there is a path from the node $m$ to the node $n$, whose labeling is derived from a non-terminal $A$ of the given context-free grammar. This type of query is evaluated using the \emph{relational query semantics}~\cite{hellingsRelational}. Another example of path query semantics is the \textit{single-path query semantics}~\cite{hellingsPathQuerying} which requires presenting a single path from the node $m$ to the node $n$ whose labeling is derived from a non-terminal $A$ for all triples $(A, m, n)$ evaluated using the relational query semantics. There is a number of algorithms for CFPQ evaluation using these semantics~\cite{RDF, GLL, hellingsRelational, hellingsPathQuerying, GraphQueryWithEarley}.

The existing algorithms for CFPQ evaluation w.r.t. these semantics demonstrate a poor performance when applied to large graphs. The algorithms for context-free language recognition had a similar problem until Valiant~\cite{valiant} proposed a parsing algorithm, which computes a recognition table by computing matrix transitive closure. The algorithm works for a linear input and has the complexity, which is essentially the same as for Boolean matrix multiplication. One of the hard open problems is to generalize Valiant's matrix-based approach for context-free path query evaluation.

Proposing the first matrix-based algorithm for CFPQ evaluation using these semantics makes it possible to efficiently apply such computing techniques as \emph{GPGPU} (General-Purpose computing on Graphics Processing Units) and parallel computation~\cite{matricesOnGPGPU}. From a practical point of view, matrix multiplication can be performed on different GPUs independently. It can help to utilize the power of multi-GPU systems and increase the performance of context-free path querying. Also, the algorithms for distributed-memory matrix multiplication make it possible to handle graph sizes inherently larger, than the memory available on the GPU~\cite{choi1994pumma, hetero_multi-GPU, MM_on_multi-GPU}.

Also, there are conjunctive grammars~\cite{okhotinConjAndBool}, which have more expressive power than context-free grammars. Path querying with conjunctive grammars is known to be undecidable~\cite{hellingsRelational}. Although there is an algorithm~\cite{zhang2017context} for path querying with linear conjunctive grammars~\cite{okhotinConjAndBool} which is used in static analysis and provides an over-approximation of the result. However, there is no algorithm for path querying with conjunctive grammars of an arbitrary form.




