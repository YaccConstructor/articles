\clearpage 

\section{Доказательство корректности алгоритма}
\textsc{Теорема 1.} 
\textit{Алгоритм завершает работу для любых входных данных.}

\textsc{Доказательство.}
С каждой вершиной внутреннего представления графа входного конечного автомата ассоциировано не более $N$ вершин графа GSS, где $N$~--- количество состояний синтаксического анализатора. Таким образом, количество вершин в графе GSS ограничено сверху числом $N \times n$, где $n$~--- количество вершин графа входного автомата. Так как в GSS нет кратных рёбер, количество его рёбер~--- $O((N \times n)^{2})$. На каждой итерации основного цикла алгоритм извлекает из очереди $Q$ и обрабатывает одну вершину внутреннего графа. Вершины добавляются в очередь $Q$ только, когда происходит добавление нового ребра в GSS. Так как количество рёбер в GSS конечно, алгоритм завершает работу для любых входных данных. $\square$

Для того, чтобы доказать корректность построения конечного представления леса 
разбора, нам потребуется следующее определение. 

\textsc{Определение 1.} 
\emph{Корректное дерево}~--- это упорядоченное дерево со следующими свойствами.
\begin{enumerate}
  \item Корень дерева соответствует стартовому нетерминалу грамматики $G$.
  \item Листья соответствуют терминалам грамматики $G$. Упорядоченная последовательность листьев соответствует некоторому пути во входном графе.
  \item Внутренние узлы соответствуют нетерминалам грамматики $G$. Дети внутреннего узла (для нетерминала $N$) соответствуют символам правой части некоторой продукции для $N$ в грамматике $G$.
\end{enumerate}

Неформально корректное дерево~--- это дерево вывода некоторой цепочки из 
регулярного множества в эталонной грамматике. Далее нам необходимо доказать, 
во-первых, что конечное представление леса разбора SPPF содержит только 
корректные деревья, и во-вторых, что для каждой корректной относительно 
эталонной грамматики цепочки существует корректное дерево вывода в SPPF. 

\textsc{Лемма.}
\textit{Для каждого ребра GSS $(v_{t}, v_{h})$ такого, что $v_{t} \in V_{t}.processed$, $v_{h} \in V_{h}.processed$, терминалы ассоциированного поддерева соответствуют некоторому пути во входном графе из вершины $V_{h}$ в $V_{t}$.}

\textsc{Доказательство.}
Будем строить доказательство при помощи индукции по высоте дерева вывода. База: либо 
$\varepsilon$-дерево, либо дерево, состоящее из единственной вершины-терминала. 
$\varepsilon$-дерево соответствует пути длины $0$; начальная и конечная вершины 
ребра, соответствующего такому дереву, совпадают, поэтому утверждение верно. 
Дерево, состоящее из одной вершины, соответствует терминалу, считанному с 
некоторого ребра $(V_{h}, V_{t})$ внутреннего графа, поэтому утверждение верно.

Корнем дерева высоты $k$ является некий нетерминал $N$. По третьему пункту 
определения корректного дерева существует некоторое правило эталонной 
грамматики $N \rightarrow A_{0}, A_{1}, \dots, A_{n}$, где $A_{0}, A_{1}, 
\dots, A_{n}$ являются детьми корневого узла. Поддерево $A_{i}$ 
ассоциировано с ребром $(v_{t}^{i}, v_{h}^{i})$ графа GSS и, так как его 
высота равна $k-1$, то по индукционному предположению существует путь во 
внутреннем графе из вершины $V_{h}^{i}$ в вершину $V_{t}^{i}$. Вершина 
$V_{t}^{i} = V_{h}^{i+1}$, так как $v_{t}^{i} = v_{h}^{i+1}$, поэтому во 
внутреннем графе существует путь из вершины $V_{h}^{0}$ в вершину 
$V_{t}^{n}$, соответствующий рассматриваемому корректному дереву. $\square$

\textsc{Теорема 2.} 
\textit{Любое дерево, сгенерированное из SPPF, является корректным.}

\textsc{Доказательство.}
Рассмотрим произвольное сгенерированное из SPPF дерево и докажем, что оно 
удовлетворяет определению 1. Первый и третий пункт определения корректного дерева следует из определения SPPF. Второй пункт определения следует из \textsc{леммы}, если применить её к рёбрам GSS, начало которых лежит на последнем уровне стека и помечено принимающим состоянием, а конец~--- в вершинах на уровне 0. $\square$

\textsc{Теорема 3.} 
\textit{Для каждой корректной относительно эталонной грамматики строки, соответствующей пути $p$ во входном графе, из SPPF может быть порождено корректное дерево, соответствующее пути $p$.}

\textsc{Доказательство.}
Рассмотрим произвольное корректное дерево и докажем, что оно может быть порождено из SPPF. Доказательство повторяет доказательство корректности для RNGLR-алгоритма, за исключением следующего момента. RNGLR-алгоритм строит граф GSS по слоям: гарантируется, что $\forall j \in [0..i-1], j-$ый уровень GSS будет зафиксирован на момент построения $i-$ого уровня. В нашем случае это свойство не верно, что может приводить к возможному порождению новых путей для свёрток, которые уже были ранее обработаны. Единственный возможный способ добавления такого нового пути~--- это добавление ребра $(v_{t}, v_{h})$, где вершина $v_{t}$ ранее присутствовала в GSS и имела входящие ребра. Так как алгоритм сохраняет информацию о том, какие свёртки проходили через вершины GSS, достаточно продолжить свёртки, проходящие через вершину $v_{t}$, и это ровно то, что делает функция \emph{applyPassingReductions}. $\square$

\textsc{Замечание.} Построение леса разбора осуществляется одновременно с построением GSS, при этом дерево вывода нетерминала ассоциируется с ребром GSS каждый раз при обработке соответствующей свёртки, вне зависимости от того, было ли ребро в графе до этого, либо добавлено на данном шаге. Это обстоятельство позволяет утверждать, что если все возможные редукции были выполнены, то и лес разбора содержит все деревья для всех корректных цепочек из аппроксимации.