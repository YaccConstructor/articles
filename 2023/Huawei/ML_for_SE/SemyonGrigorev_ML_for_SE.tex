\section{}

LLMs which pretend to understand text in both natural and programming languages.

Graph neural networks

...

\section{}

While LLMs shows performance in natural language processing tasks and can be applied to wide range of software engineering related tasks, they a limited in code understanding. Even <network!!!!> solves this problem extensively: just to increase network's memory to fit more code. It is unlikely possible to handle huge real-world projects with complex dependencies with long-standing dependent parts this way. 

Moreover, it was shown that LLMs does not really understand such basic program analysis concepts as graphs and trees. It is significant limitation because graphs allows one to represent sufficient information about programs in native structural way. Data flow graph, control flow graph, call graph, many other. Huge number of software analysis problems can be naturally formulated in terms of graph, but it is very nontrivial to formulate them if we operates source code only. 

To brake through this limitation one can use Graph Neural Networks (GNNs) which designed to handle graph structured data. Being able to handle more reach representation of programs, graph neural networks shows promising performance in different software development related tasks. !!!

Even more, precalculated nontrivial information, being added to graph, improves performance of neural networks. To do it one requires classical code analysis algorithms.

Finally, precise solution impossible using NNs!!!

Thus, it is unlikely possible to replace traditional tools with neural networks, but right direction is to combine traditional tools with AI to improve each other.

\section{Directions of Work}

Dataset creation requires classical tools for both data extraction and data!!! (ground truth generation, labelling) 

To learn heuristics for undesidable problems. Symbolic machine navigation. 



Code model to train networks

Networks to improve solutions