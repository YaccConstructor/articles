% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\label{sec:relatedworks}
В данном разделе приводится терминология используемая в работе, представляются основные подходы для решения задачи поиска путей с регулярными ограничениями.

\subsection{Основы теории формальных языков}

В этой секции вводятся ключевые понятия из теории формальных языков, которые нужны для введения ограничений на пути в графе с помощью регулярных языков.

\begin{rudefinition} \emph{Формальной грамматикой} называется четверка \\ $\langle V_N, V_T, P, S \rangle$, где
    \begin{itemize}
        \item $V_N, V_T$ --- конечные и непересекающиеся алфавиты нетерминалов и терминалов соответственно;
        \item $P$ --- конечное множество правил;
        \item $S$ --- стартовый нетерминал.
    \end{itemize}
\end{rudefinition}

\begin{rudefinition} \emph{Праволинейной грамматикой} называется формальная грамматика, правила которой могут быть заданы как $A \rightarrow aB$, $A \rightarrow a$, $A \rightarrow \epsilon$.
\end{rudefinition}

\begin{rudefinition}
    \emph{Детерминированным конечным автоматом без эпсилон-переходов} называется пятерка $\langle Q, \Sigma, P, Q_{s}, F \rangle$, где
    \begin{itemize}
        \item $Q$ --- конечное непустое множество состояний;
        \item $\Sigma$ --- конечный входной алфавит;
        \item $P$ --- отображение $Q \times \Sigma \rightarrow Q$;
        \item $Q_{s} \subseteq Q$ --- множество начальных состояний;
        \item $F \subseteq Q$ --- множество конечных состояний.
    \end{itemize}
\end{rudefinition}

Далее, будем называть детерминированный конечный автомат без эпсилон-переходов --- конечным автоматом.

\begin{rudefinition} \emph{Регулярным выражением} над алфавитом $\Sigma$ называется
    \begin{itemize}
        \item $a$, если $a$ --- пустая строка, или $a \in \Sigma$;
        \item $e$ $\cdot$ $f$ (конкатенация), если $e$ и $f$ --- регулярные выражения;
        \item $e$ | $f$ (перечисление), если $e$ и $f$ --- регулярные выражения;
        \item $e^*$ (звезда Клини), если $e$ --- регулярное выражение.
    \end{itemize}
\end{rudefinition}

Для любого регулярного выражения существует представление в виде конечного автомата. Этот факт используется при построении алгоритмов, основанных на выражении регулярных ограничений с помощью конечных автоматов.

\subsection{Основные термины из теории графов}

\begin{rudefinition}\emph{Матрицей смежности} графа $\mathcal{G}$ называется матрица $M^{n \times n}$, где $n$ --- число вершин в графе, ячейка $M[i, j]$ имеет значение $l$, если существует ребро $e$ между вершинами $i$, $j$ с меткой $l$.
\end{rudefinition}

Заметим, что по каждой метке $l$ графа $\mathcal{G}$ можно построить матрицу смежности $\mathcal{M}^l$. Тогда ячейки матрицы $\mathcal{M}^l$ будут отражать факт наличия ребра $e$ с конкретной меткой $l$. Такое представление называется булевой декомпозицией матриц смежности графа. Оно позволяет хранить граф в виде набора булевых матриц, которыми удобно оперировать при построении алгоритмов на основе операций линейной алгебры.

Теперь можно сформулировать задачу поиска путей в графе с ограничениями, которые заданы с помощью регулярных языков. В частности, в данной работе рассматривается один из типов задачи поиска путей --- задача достижимости. Сформулируем эту задачу двумя способами. Они
отличаются в постановке результата, который ожидается в ходе решения задачи достижимости.

\begin{rudefinition} \emph{Задача достижимости с ограничениями в виде регулярных языков}. Пусть имеются:
    \begin{itemize}
        \item граф $\mathcal{G} = \langle V, E, L\rangle$;
        \item регулярный язык $\mathcal{L}$;
        \item множество стартовых $V_s \subseteq V$ и финальных $V_f \subseteq V$ вершин.
    \end{itemize}
    Рассмотрим пути $\pi = (v_0, e_0, \dots, e_n, v_n), e_k = (v_{k-1}, l_k, v_{k})$. Сопоставим каждому пути слово $W(\pi)=(l_0l_1 \dots l_{n-1}) \in \mathcal{L}$. Необходимо:

    \begin{itemize}
        \item Найти \textit{множество}, состоящее из вершин $v_n \in V$, для которых существует хотя бы один путь $\pi$ с началом в $v_0 \in V$ такой, что $W(\pi) \in \mathcal{L}$, $v_0 \in V_s$, $v_n \in V_f$.
        \item Найти все \textit{пары} вершин $v_0, v_n \in V$, для которых существует хотя бы один путь $\pi$ такой, что $W(\pi) \in \mathcal{L}$, $v_0 \in V_s$, $v_n \in V_f$.
    \end{itemize}
\end{rudefinition}

\subsection{Существующие решения}

В литературе выделяют несколько основных подходов к решению задачи поиска путей с ограничениями в виде регулярных языков. Они включают в себя подходы на основе конечных автоматов, использование программ на языке Datalog, построение индекса путей в графе для последующего исполнения регулярного запроса на основе индекса. Каждый из этих подходов будет подробнее рассмотрен в этой части обзора.

Алгоритмы для решения задачи PRQ на основе конечных автоматов строятся следующим образом. Входные данные в виде графа и регулярного языка представляются с помощью конечных автоматов. Для начала строится конечный автомат, который будет задавать регулярный язык. Далее, входной граф представляется в виде конечного автомата, у которого все состояния являются стартовыми и финальными. В итоге задачу поиска путей в графе с ограничениями, заданными с помощью регулярных языков, можно свести к задаче нахождения пересечения двух конечных автоматов.

Также вычислить пересечение конечных автоматов можно с использованием произведения Кронекера, которое применяется к матрицам из булевых декомпозиций матриц смежности для входного графа и представления конечного автомата в виде другого графа. Подробнее, использование матричных операций и произведения Кронекера рассматривается в разделе~\ref{2.4matr}.

\subsubsection{Подход с использованием языка Datalog}

Программа на Datalog представляет собой конечное множество правил. Правило --- это выражение следующей формы.

\begin{center}
    $h :$-- $p_1, p_2, \dots, p_n.$
\end{center}

Выражения $h, p_1, \dots, p_n$ представляют собой формулы вида \\$R(t_1, \dots, t_k)$, где $t_i$ может быть либо константой, либо переменной. Выражение $p_i$ --- факт, если все его $t_i$ являются константами.

    Для того, чтобы исполнять регулярные запросы с помощью программ на языке логического программирования Datalog, нужно представить граф в виде списка фактов о его ребрах.
    \begin{align*}
        edge(u_1 & ,l_1, v_1) \\
        edge(u_2 & ,l_2, v_2) \\
                 & \dots      \\
        edge(u_n & ,l_n, v_n)
    \end{align*}
    Где каждое ребро c меткой $l_i$, соединяет вершины $u_i$ $v_i$.

    Пример запроса $l^*$, который вычисляет транзитивное замыкание графа, содержащее рёбра с меткой $l$ можно описать следующим образом.

    \begin{center}
        $path(x, y) :$-- $edge(x, l, z), path(z, y).$\\
        $path(x, y) :$-- $edge(x, l, y).$
    \end{center}

    Имея представление запроса в виде регулярного выражения, можно получить программу на языке Datalog, которая будет исполнять этот запрос. Для этого нужно представить регулярное выражение с помощью правил грамматики, после чего транслировать грамматику во множество правил Datalog.

    Так, регулярное выражение $l^*$ может быть представлено правилами $S \rightarrow l$ $S$ и $S \rightarrow \epsilon$, которые легко транслируются в представленные выше правила Datalog.

Таким образом, для выполнения сравнения с этим подходом необходимо реализовать трансляцию регулярных выражений в программы на Datalog.

\subsubsection{Подход, основанный на построении индекса}

Существует множество работ на тему построения индекса путей в графе. Одни из них предлагают запоминать ключевые структуры в графе~\cite{related_frequent_fragments}, как, например, часто встречающиеся подграфы или другие фрагменты, описывающие основные свойства графа. Другой подход основан на индексировании путей и используется в работе~\cite{related_fletcher}, где авторы хранят пути размера не больше k, k --- целочисленная константа небольшого значения. Такой индекс позволяет исполнить любой регулярный запрос, состоящий не более чем из k меток, за один просмотр. Для запросов большего размера пути разделяются на части, длина которых кратна k, после чего запрос исполняется за несколько просмотров индекса.

Основным преимуществом построения индекса является то, что он позволяет быстро исполнить запрос по уже построенному пути. Однако использование индекса сказывается на размере потребляемой памяти во время работы алгоритма. Так, в исследовании~\cite{related_fletcher} самый большой граф имеет 131828 вершин, и для него авторы не смогли построить индекс, длина пути которого больше 2, в виду ограничений по памяти.

\subsection{Поиск путей с ограничениями с помощью операций над матрицами}\label{2.4matr}

Алгоритмы на основе матричных операций представляют еще один класс решений описанной задачи. Существует ряд алгоритмов, которые решают более общую задачу --- задачу КС-достижимости, однако они могут быть применены к регулярным ограничения на пути в том числе.

\subsubsection{Тензорный алгоритм}

Один из таких алгоритмов основан на произведении Кронекера~\cite{related_kron}. Он использует операции матричного умножения и не требует модификации изначальной контекстно-свободной грамматики.

На вход алгоритму подается конечный автомат, описывающий граф. Вторым аргументом алгоритм получает рекурсивный автомат, описывающий ограничения на пути в графе. Аналогично тому, как регулярное выражение может быть записано в виде конечного автомата, КС-грамматика может быть выражена с помощью рекурсивного автомата. Рекурсивный автомат может быть представлен в виде графа. Тогда, благодаря тензорному произведению, можно вычислить пересечение конечного автомата, соответствующего входному графу и рекурсивного автомата, соответствующего КС-ограничениям. После чего полученный автомат пересечения транзитивно замыкается. Эти операции применяются в цикле для булевой декомпозиции матриц смежности автомата, соответствующего КС-ограничениям, пока любая из матриц булевой декомпозиции меняется.

Операции вычисления транзитивного замыкания и тензорного произведения находят пути в графе для всех пар вершин. В случае, когда имеется множество стартовых вершин, производительность этого алгоритма может упасть, так как все вершины графа буду считаться начальными, и для всех них посчитаются пути до других вершин.
