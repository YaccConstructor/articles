@article{demand_driven_alias_analysis,
    author = {Zheng, Xin and Rugina, Radu},
    title = {Demand-Driven Alias Analysis for C},
    year = {2008},
    issue_date = {January 2008},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {43},
    number = {1},
    issn = {0362-1340},
    url = {https://doi.org/10.1145/1328897.1328464},
    urldate = "10.10.2021",
    doi = {10.1145/1328897.1328464},
    abstract = {This paper presents a demand-driven, flow-insensitive analysisalgorithm for answering
    may-alias queries. We formulate thecomputation of alias queries as a CFL-reachability
    problem, and use this formulation to derive a demand-driven analysis algorithm. The
    analysis uses a worklist algorithm that gradually explores the program structure and
    stops as soon as enough evidence is gathered to answer the query. Unlike existing
    techniques, our approach does not require building or intersecting points-to sets.Experiments
    show that our technique is effective at answering alias queries accurately and efficiently
    in a demand-driven fashion. For a set of alias queries from the SPEC2000 benchmarks,
    an implementation of our analysis is able to accurately answer 96% of the queries
    in 0.5 milliseconds per query on average, using only 65 KB of memory. Compared to
    a demand-driven points-to analysis that constructs and intersects points-to sets on
    the fly, our alias analysis can achieve better accuracy while running more than 30
    times faster. The low run-time cost and low memory demands of the analysis make it
    a very good candidate not only for compilers, but also for interactive tools, such
    as program understanding tools or integrated development environments (IDEs).},
    journal = {SIGPLAN Not.},
    month = {1},
    pages = {197–208},
    numpages = {12},
    keywords = {pointer analysis, alias analysis, memory disambiguation, CFL reachability, demand-driven analysis}
}
@inproceedings{rustam_algorithm,
    author = {Azimov, Rustam and Grigorev, Semyon},
    title = {Context-Free Path Querying by Matrix Multiplication},
    year = {2018},
    isbn = {9781450356954},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3210259.3210264},
    urldate = "10.10.2021",
    doi = {10.1145/3210259.3210264},
    abstract = {Context-free path querying is a technique, which recently gains popularity in many
    areas, for example, graph databases, bioinformatics, static analysis, etc. In some
    of these areas, it is often required to query large graphs, and existing algorithms
    demonstrate a poor performance in this case. The generalization of matrix-based Valiant's
    context-free language recognition algorithm for graph case is widely considered as
    a recipe for efficient context-free path querying; however, no progress has been made
    in this direction so far.We propose the first generalization of matrix-based Valiant's
    algorithm for context-free path querying. Our generalization does not deliver a truly
    sub-cubic worst-case complexity algorithm, whose existence still remains a hard open
    problem in the area. On the other hand, the utilization of matrix operations (such
    as matrix multiplication) in the process of context-free path query evaluation makes
    it possible to efficiently apply a wide class of optimizations and computing techniques,
    such as GPGPU (General-Purpose computing on Graphics Processing Units), parallel processing,
    sparse matrix representation, distributed-memory computation, etc. Indeed, the evaluation
    on a set of conventional benchmarks shows, that our algorithm outperforms the existing
    ones.},
    booktitle = {Proceedings of the 1st ACM SIGMOD Joint International Workshop on Graph Data Management Experiences \& Systems (GRADES) and Network Data Analytics (NDA)},
    articleno = {5},
    numpages = {10},
    keywords = {graph databases, context-free path querying, transitive closure, matrix multiplication, context-free grammar, GPGPU},
    location = {Houston, Texas},
    series = {GRADES-NDA '18}
}
@InProceedings{tensor_algorithm,
    author = {Orachev, Egor and Epelbaum, Ilya and Azimov, Rustam and Grigorev, Semyon},
    editor = {Darmont, J{\'e}r{\^o}me and Novikov, Boris and Wrembel, Robert},
    title = {Context-Free Path Querying by Kronecker Product},
    booktitle = {Advances in Databases and Information Systems},
    year = {2020},
    publisher = {Springer International Publishing},
    address= {Cham},
    pages = {49--59},
    abstract = {Context-free path queries (CFPQ) extend the regular path queries (RPQ) by allowing context-free grammars to be used as constraints for paths. Algorithms for CFPQ are actively developed, but J. Kuijpers et al. have recently concluded, that existing algorithms are not performant enough to be used in real-world applications. Thus the development of new algorithms for CFPQ is justified. In this paper, we provide a new CFPQ algorithm which is based on such linear algebra operations as Kronecker product and transitive closure and handles grammars presented as recursive state machines. Thus, the proposed algorithm can be implemented by using high-performance libraries and modern parallel hardware. Moreover, it avoids grammar growth which provides the possibility for queries optimization.},
    isbn = {978-3-030-54832-2}
}
@misc{incremental_tensor_algorithm,
      title={One Algorithm to Evaluate Them All: Unified Linear Algebra Based Approach to Evaluate Both Regular and Context-Free Path Queries}, 
      author={Ekaterina Shemetova and Rustam Azimov and Egor Orachev and Ilya Epelbaum and Semyon Grigorev},
      year={2021},
      eprint={2103.14688},
      archivePrefix={arXiv},
      primaryClass={cs.DB}
}

@inproceedings{java_pt,
    author = {Dietrich, Jens and Hollingum, Nicholas and Scholz, Bernhard},
    title = {Giga-Scale Exhaustive Points-to Analysis for Java in under a Minute},
    year = {2015},
    isbn = {9781450336895},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/2814270.2814307},
    urldate = "10.10.2021",
    doi = {10.1145/2814270.2814307},
    abstract = { Computing a precise points-to analysis for very large Java programs remains challenging
    despite the large body of research on points-to analysis. Any approach must solve
    an underlying dynamic graph reachability problem, for which the best algorithms have
    near-cubic worst-case runtime complexity, and, hence, previous work does not scale
    to programs with millions of lines of code. In this work, we present a novel approach
    for solving the field-sensitive points-to problem for Java with the means of (1) a
    transitive-closure data-structure, and (2) a pre-computed set of potentially matching
    load/store pairs to accelerate the fix-point calculation. Experimentation on Java
    benchmarks validates the superior performance of our approach over the standard context-free
    language reachability implementations. Our approach computes a points-to index for
    the OpenJDK with over 1.5 billion tuples in under a minute. },
    booktitle = {Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications},
    pages = {535–551},
    numpages = {17},
    keywords = {Points-to Analysis, Context-free Language, Transitive Closure, Java},
    location = {Pittsburgh, PA, USA},
    series = {OOPSLA 2015}
}
@inproceedings{matrix_ms_algorithm,
    author = {Terekhov, Arseniy and Pogozhelskaya, Vlada and Abzalov, Vadim and Zinnatulin, Timur and Grigorev, Semyon},
    title = {Multiple-Source Context-Free Path Querying in Terms of Linear Algebra},
    year = {2021},
    isbn = {978-3-89318-084-4},
    booktitle = {Advances in Database Technology - EDBT 2021, 24th International Conference on Extending Database Technology, Nicosia, Cyprus, March 23 - 26, Proceedings},
    url = {https://openproceedings.org/2021/conf/edbt/proceedings.pdf},
    urldate = "10.10.2021",
    pages = {487-492},
    numpages = {6},
}
@article{rsm,
    author = {Alur, Rajeev and Benedikt, Michael and Etessami, Kousha and Godefroid, Patrice and Reps, Thomas and Yannakakis, Mihalis},
    title = {Analysis of Recursive State Machines},
    year = {2005},
    issue_date = {July 2005},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {27},
    number = {4},
    issn = {0164-0925},
    url = {https://doi.org/10.1145/1075382.1075387},
    doi = {10.1145/1075382.1075387},
    journal = {ACM Trans. Program. Lang. Syst.},
    pages = {786–818},
    numpages = {33},
    keywords = {context-free languages, temporal logic, program analysis, Software verification, recursive state machines, model checking, pushdown automata}
}

@inproceedings{eval_cfpq,
    author = {Mishin, Nikita and Sokolov, Iaroslav and Spirin, Egor and Kutuev, Vladimir and Nemchinov, Egor and Gorbatyuk, Sergey and Grigorev, Semyon},
    title = {Evaluation of the Context-Free Path Querying Algorithm Based on Matrix Multiplication},
    year = {2019},
    isbn = {9781450367899},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3327964.3328503},
    urldate = "10.10.2021",
    doi = {10.1145/3327964.3328503},
    abstract = {Recently proposed matrix multiplication based algorithm for context-free path querying
    (CFPQ) offloads the most performance-critical parts onto boolean matrices multiplication.
    Thus, it is possible to achieve high performance of CFPQ by means of modern parallel
    hardware and software. In this paper, we provide results of empirical performance
    comparison of different implementations of this algorithm on both real-world data
    and synthetic data for the worst cases.},
    booktitle = {Proceedings of the 2nd Joint International Workshop on Graph Data Management Experiences \& Systems (GRADES) and Network Data Analytics (NDA)},
    articleno = {12},
    numpages = {5},
    keywords = {Context-free path querying, boolean matrix, CUDA, transitive closure, matrix multiplication, graph databases, context-free grammar, GPGPU},
    location = {Amsterdam, Netherlands},
    series = {GRADES-NDA'19}
}
@inproceedings{alias_analysis,
    author = {Palix, Nicolas and Thomas, Ga\"{e}l and Saha, Suman and Calv\`{e}s, Christophe and Lawall, Julia and Muller, Gilles},
    title = {Faults in Linux: Ten Years Later},
    year = {2011},
    isbn = {9781450302661},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/1950365.1950401},
    urldate = "10.10.2021",
    doi = {10.1145/1950365.1950401},
    abstract = {In 2001, Chou et al. published a study of faults found by applying a static analyzer
    to Linux versions 1.0 through 2.4.1. A major result of their work was that the drivers
    directory contained up to 7 times more of certain kinds of faults than other directories.
    This result inspired a number of development and research efforts on improving the
    reliability of driver code. Today Linux is used in a much wider range of environments,
    provides a much wider range of services, and has adopted a new development and release
    model. What has been the impact of these changes on code quality? Are drivers still
    a major problem?To answer these questions, we have transported the experiments of
    Chou et al. to Linux versions 2.6.0 to 2.6.33, released between late 2003 and early
    2010. We find that Linux has more than doubled in size during this period, but that
    the number of faults per line of code has been decreasing. And, even though drivers
    still accounts for a large part of the kernel code and contains the most faults, its
    fault rate is now below that of other directories, such as arch (HAL) and fs (file
    systems). These results can guide further development and research efforts. To enable
    others to continually update these results as Linux evolves, we define our experimental
    protocol and make our checkers and results available in a public archive.},
    booktitle = {Proceedings of the Sixteenth International Conference on Architectural Support for Programming Languages and Operating Systems},
    pages = {305–318},
    numpages = {14},
    keywords = {linux, fault-finding tools},
    location = {Newport Beach, California, USA},
    series = {ASPLOS XVI}
}

@inproceedings{dataflow_analysis_via_graph_reachability,
    author = {Reps, Thomas and Horwitz, Susan and Sagiv, Mooly},
    title = {Precise Interprocedural Dataflow Analysis via Graph Reachability},
    year = {1995},
    isbn = {0897916921},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/199448.199462},
    urldate = "10.10.2021",
    doi = {10.1145/199448.199462},
    abstract = {The paper shows how a large class of interprocedural dataflow-analysis problems can
    be solved precisely in polynomial time by transforming them into a special kind of
    graph-reachability problem. The only restrictions are that the set of dataflow facts
    must be a finite set, and that the dataflow functions must distribute over the confluence
    operator (either union or intersection). This class of probable problems includes—but
    is not limited to—the classical separable problems (also known as “gen/kill” or “bit-vector”
    problems)—e.g., reaching definitions, available expressions, and live variables. In
    addition, the class of problems that our techniques handle includes many non-separable
    problems, including truly-live variables, copy constant propagation, and possibly-uninitialized
    variables.Results are reported from a preliminary experimental study of C programs
    (for the problem of finding possibly-uninitialized variables).},
    booktitle = {Proceedings of the 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
    pages = {49–61},
    numpages = {13},
    location = {San Francisco, California, USA},
    series = {POPL '95}
}
@article{program_analysis_via_graph_reachability,
    title = {Program analysis via graph reachability1An abbreviated version of this paper appeared as an invited paper in the Proceedings of the 1997 International Symposium on Logic Programming [84].1},
    journal = {Information and Software Technology},
    volume = {40},
    number = {11},
    pages = {701-726},
    year = {1998},
    issn = {0950-5849},
    doi = {https://doi.org/10.1016/S0950-5849(98)00093-7},
    url = {https://www.sciencedirect.com/science/article/pii/S0950584998000937},
    urldate = "10.10.2021",
    author = {Thomas Reps},
    abstract = {This paper describes how a number of program-analysis problems can be solved by transforming them to graph-reachability problems. Some of the program-analysis problems that are amenable to this treatment include program slicing, certain dataflow-analysis problems, one version of the problem of approximating the possible “shapes” that heap-allocated structures in a program can take on, and flow-insensitive points-to analysis. Relationships between graph reachability and other approaches to program analysis are described. Some techniques that go beyond pure graph reachability are also discussed.}
}
@article{precise_interprocedural_dataflow_analysis,
    title = {Precise interprocedural dataflow analysis with applications to constant propagation},
    journal = {Theoretical Computer Science},
    volume = {167},
    number = {1},
    pages = {131-170},
    year = {1996},
    issn = {0304-3975},
    doi = {https://doi.org/10.1016/0304-3975(96)00072-2},
    url = {https://www.sciencedirect.com/science/article/pii/0304397596000722},
    urldate = "10.10.2021",
    author = {Mooly Sagiv and Thomas Reps and Susan Horwitz},
    abstract = {This paper concerns interprocedural dataflow-analysis problems in which the dataflow information at a program point is represented by an environment (i.e., a mapping from symbols to values), and the effect of a program operation is represented by a distributive environment transformer. We present two efficient algorithms that produce precise solutions: an exhaustive algorithm that finds values for all symbols at all program points, and a demand algorithm that finds the value for an individual symbol at a particular program point. Two interesting problems that can be handled by our algorithms are (decidable) variants of the interprocedural constant-propagation problem: copy-constant propagation and linear-constant propagation. The former interprets program statements of the form x ≔ 7 and x ≔ y. The latter also interprets statements of the form x ≔ 5 * y + 17. Experimental results on C programs have shown that•Although solving constant-propagation problems precisely (i.e., finding the meet-over-all-valid-paths solution, rather than the meet-over-all-paths solution) resulted in a slowdown by a factor ranging from 2.2 to 4.5, the precise algorithm found additional constants in 7 of 38 test programs.•In contrast to previous results for numeric Fortran programs, linear-constant propagation found more constants than copy-constant propagation in 6 of 38 test programs.•The demand algorithm, when used to demand values for all uses of scalar integer variables, was faster than the exhaustive algorithm by a factor ranging from 1.14 to about 6.}
}
@inproceedings{context_sensitive_points_to_analysis_for_java,
    author = {Sridharan, Manu and Bod\'{\i}k, Rastislav},
    title = {Refinement-Based Context-Sensitive Points-to Analysis for Java},
    year = {2006},
    isbn = {1595933204},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/1133981.1134027},
    urldate = "10.10.2021",
    doi = {10.1145/1133981.1134027},
    abstract = {We present a scalable and precise context-sensitive points-to analysis with three
    key properties: (1) filtering out of unrealizable paths, (2) a context-sensitive heap
    abstraction, and (3) a context-sensitive call graph. Previous work [21] has shown
    that all three properties are important for precisely analyzing large programs, e.g.,
    to show safety of downcasts. Existing analyses typically give up one or more of the
    properties for scalability. We have developed a refinement-based analysis that succeeds
    by simultaneously refining handling of method calls and heap accesses, allowing the
    analysis to precisely analyze important code while entirely skipping irrelevant code.
    The analysis is demanddriven and client-driven, facilitating refinement specific to
    each queried variable and increasing scalability. In our experimental evaluation,
    our analysis proved the safety of 61% more casts than one of the most precise existing
    analyses across a suite of large benchmarks. The analysis checked the casts in under
    13 minutes per benchmark (taking less than 1 second per query) and required only 35MB
    of memory, far less than previous approaches.},
    booktitle = {Proceedings of the 27th ACM SIGPLAN Conference on Programming Language Design and Implementation},
    pages = {387–400},
    numpages = {14},
    keywords = {points-to analysis, demand-driven analysis, refinement, context-sensitive analysis},
    location = {Ottawa, Ontario, Canada},
    series = {PLDI '06}
}

@inproceedings{cfpq_algo_1,
    author = {Medeiros, Ciro M. and Musicante, Martin A. and Costa, Umberto S.},
    title = {An Algorithm for Context-Free Path Queries over Graph Databases},
    year = {2020},
    isbn = {9781450389433},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3427081.3427087},
    urldate = "10.10.2021",
    doi = {10.1145/3427081.3427087},
    abstract = {Path queries are used to specify paths inside a data graph to match a given pattern.
    Query languages such as SPARQL usually include support for regular path patterns defined
    by means of regular expressions. Context-free path queries define a path whose language
    can be defined by a context-free grammar. This kind of query is interesting in practice
    in domains such as genetics, data science, or source code analysis. In this paper,
    we present a novel algorithm for context-free path query processing. Our algorithm
    works by looking for localized paths, allowing us to process subgraphs, in contrast
    to other approaches that have to process the whole graph. It also takes any context-free
    grammar as input, avoiding the use of normal forms that are more problematic in practice.
    The output of our algorithm provides enough information to reconstruct the paths matching
    the query. We prove the correctness of our approach and show its runtime and memory
    complexity. We show the viability of our approach by means of a prototype implemented
    in Go. We run experiments proposed in recent works, which include both synthetic and
    real RDF databases. Our algorithm shows some performance gains when compared with
    other algorithms implemented using single-thread programs.},
    booktitle = {Proceedings of the 24th Brazilian Symposium on Context-Oriented Programming and Advanced Modularity},
    pages = {40–47},
    numpages = {8},
    keywords = {context-free grammars, RDF, graph path queries},
    location = {Natal, Brazil},
    series = {SBLP '20}
}
@article{cfpq_algo_2,
    author = {Petteri Sevon and Lauri Eronen},
    doi = {doi:10.1515/jib-2008-100},
    url = {https://doi.org/10.1515/jib-2008-100},
    urldate = "10.10.2021",
    title = {Subgraph Queries by Context-free Grammars},
    journal = {Journal of Integrative Bioinformatics},
    number = {2},
    volume = {5},
    year = {2008},
    pages = {157--172}
}
@article{cfpq_algo_3,
      title={Querying for Paths in Graphs using Context-Free Path Queries}, 
      author={Jelle Hellings},
      year={2016},
      eprint={1502.02242},
      archivePrefix={arXiv},
      primaryClass={cs.DB}
}
@book{automata_theory,
    author = {Hopcroft, John E. and Motwani, Rajeev and Ullman, Jeffrey D.},
    title = {Introduction to Automata Theory, Languages, and Computation (3rd Edition)},
    year = {2006},
    isbn = {0321455363},
    publisher = {Addison-Wesley Longman Publishing Co., Inc.},
    address = {USA}
}
