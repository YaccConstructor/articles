\section{Обзор}

Данный раздел содержит ряд базовых определений из теории формальных языков, а далее --- краткое описание алгоритмов поиска путей с контекстно-свободными ограничениями.

\subsection{Базовые определения из теории формальных языков}
Введем базовые определения из теории формальных языков, которые будут использоваться в дальнейшем.

\begin{rudefinition}
     \emph{Контекстно-свободная грамматика} --- это четверка $\mathbb{G} = \langle N, \Sigma, P, S \rangle $, где
     \begin{itemize}
          \item $N$ --- конечное множество нетерминальных символов;
          \item $\Sigma$ --- конечное множество терминальных символов, $ \Sigma \cap N = \varnothing $;
          \item $P$ --- конечное множество правил или продукций вида $A \rightarrow \alpha$, где $A \in N$ и $\alpha  \in \{ \Sigma \cup N \}^*$ или $\alpha = \varepsilon$;
          \item $S \in N$ --- стартовый нетерминал.
     \end{itemize}
\end{rudefinition}

Важную роль в данной работе играет понятие \emph{выводимости слова в контекстно-свободной грамматике}.
Необходимые определения приведены ниже.

\begin{rudefinition}
    \emph{Шаг вывода в контекстно-свободной грамматике} $\mathbb{G} = \langle N, \Sigma, P, S \rangle$ --- это переход $\gamma A \beta \Rightarrow \gamma \alpha \beta$, где $\gamma, \beta \in \{ \Sigma \cup N \}^*$ и $(A \rightarrow \alpha) \in P$
\end{rudefinition}

\begin{rudefinition}
    Слово $w \in \Sigma^*$ \emph{выводимо в контекстно-свободной грамматике} $\mathbb{G} = \langle N, \Sigma, P, S \rangle$, если существует последовательность шагов вывода в грамматике $\mathbb{G}$: $S \Rightarrow \beta_0 \Rightarrow \beta_1 \Rightarrow \dots \Rightarrow \beta_{n - 1} \Rightarrow w$.
    Будем обозначать это как $S \xRightarrow[]{*} w$.
\end{rudefinition}

\begin{rudefinition}
     \emph{Язык, задаваемый контекстно-свободной грамматикой} $\mathbb{G} = \langle N, \Sigma, P, S \rangle$ --- это множество слов, выводимых в грамматике $$L(\mathbb{G}) = \{ w \in \Sigma^* | S \xRightarrow[]{*} w\}$$
\end{rudefinition}

Наравне с контекстно-свободными грамматиками в этой работе также используются рекурсивные автоматы, поэтому введем соответствующие определения.

\begin{rudefinition}
    \emph{Детерминированный конечный автомат} --- это пятерка $\langle Q, \Sigma, \sigma, Q_{0}, Q_{F}\rangle$:
    \begin{itemize}
        \item $Q$ --- конечное множество состояний;
        \item $\Sigma$ --- конечное множество входных символов;
        \item $\sigma ~:~ Q \times \Sigma \rightarrow Q$ --- функция переходов, аргументами которой являются текущее состояние и входной символ, а значением --- новое состояние;
        \item $Q_{0}$ --- начальное состояние, $Q_{0} \in Q$;
        \item $Q_{F}$ --- множество допускающих состояний, $Q_{F} \subseteq Q$.
    \end{itemize}
\end{rudefinition}

Рекурсивный автомат является обобщением детерминированного конечного автомата и позволяет задавать те же языки, что задаются контекстно-свободными грамматиками.

\begin{rudefinition}
    \emph{Рекурсивный автомат} --- это семерка $$\mathbb{A} = \langle Q, \Sigma, N, \sigma, Q_{S}, Q_{F}, S\rangle$$
    \begin{itemize}
        \item $Q$ --- конечное множество состояний, каждое состояние помечено нетерминалом;
        \item $N$ --- конечное множество нетерминальных символов;
        \item $\Sigma$ --- конечное множество терминальных символов, $\Sigma \cap N = \varnothing$;
        \item $\sigma ~:~ Q \times (\Sigma \cup N) \rightarrow Q$ --- функция переходов, аргументами которой являются текущее состояние и символ из $\Sigma \cup N$, а значением --- новое состояние;
        \item $Q_{S}$ --- множество начальных состояний, $Q_{S} \subseteq Q$;
        \item $Q_{F}$ --- множество допускающих состояний, $Q_{F} \subseteq Q$;
        \item $S$ --- стартовый нетерминал, $S \in N$.
    \end{itemize}
\end{rudefinition}

Рекурсивный автомат отличается от детерминированного конечного автомата тем, что:
\begin{itemize}
    \item вместо одного конечного автомата, рекурсивный автомат может состоять из нескольких конечных автоматов, каждый из который помечен своим уникальным нетерминалом;
    \item переходы по терминальным символам осуществляются также, как и в детерминированном конечном автомате, однако переходы по нетерминальным символам осуществляются тогда и только тогда, когда рекурсивный спуск в конечный автомат, стартовое состояние которого помечено нетерминальным символом перехода, завершается в допускающем состоянии соответствующего автомата.
\end{itemize}

\begin{ruexample}
    Рассмотрим язык $\mathbb{L}_0 = \{a^n b^n ~|~ n \in \mathbb{N}\}$.
    Язык $\mathbb{L}_0$ представляет собой конкатенацию $n$ букв "$a$" и $n$ букв "$b$", где $n$ --- натуральное число.
\end{ruexample}
Этот язык может быть задан с помощью контекстно-свободной грамматики.

\begin{ruexample}
    \emph{Контекстно-свободная грамматика $\mathbb{G}_0 $, задающая язык $\mathbb{L}_0$}.
    $$S \rightarrow a S b$$
    $$S \rightarrow a b$$
\end{ruexample}

\begin{ruexample}
    \emph{Пример вывода слова $aaabbb \in \mathbb{L}_0$ в грамматике $\mathbb{G}_0$}.
    $$S \Rightarrow a S b \Rightarrow a a S b b \Rightarrow a a a b b b$$
\end{ruexample}

Этот же язык возможно задать с помощью рекурсивного автомата.

\begin{ruexample}
    \emph{Рекурсивный автомат $\mathbb{A}_0$, задающий язык $\mathbb{L}_0$}.

    \begin{align}
    \label{rsm0}
        \begin{tikzpicture}[node distance=2.5cm,shorten >=1pt,on grid,auto]
           \node[state, initial] (q_0)   {$0 \{S\}$};
           \node[state] (q_1) [right=of q_0] {$1 \{S\}$};
           \node[state] (q_2) [right=of q_1] {$2 \{S\}$};
           \node[state, accepting] (q_3) [right=of q_2] {$3 \{S\}$};
            \path[->]
            (q_0) edge  node {a} (q_1)
            (q_1) edge  node {S} (q_2)
            (q_2) edge  node {b} (q_3)
            (q_1) edge[bend left, above]  node {b} (q_3);
        \end{tikzpicture}
    \end{align}
    
\end{ruexample}

\begin{ruexample}
    \emph{Пример вывода слова $aaabbb \in \mathbb{L}_0$ в рекурсивном автомате $\mathbb{A}_0$}.
    $$0 \xRightarrow[]{a} 1 \xRightarrow[\text{rec}\downarrow]{S} 0 \xRightarrow[]{a} 1 \xRightarrow[\text{rec}\downarrow]{S} 0 \xRightarrow[]{a} 1 \xRightarrow[]{b} 3 \xRightarrow[\text{rec}\uparrow]{S} 2 \xRightarrow[]{b} 3 \xRightarrow[\text{rec}\uparrow]{S} 2 \xRightarrow[]{b} 3$$

    Здесь $\text{rec}\downarrow$ обозначает рекурсивный спуск в рекурсивном автомате, а $\text{rec}\uparrow$ возврат из рекурсивного спуска.
\end{ruexample}


\subsection{Базовые определения из теории графов}

Введем базовые определения из теории графов, которые будут использоваться в дальнейшем.

\begin{rudefinition} \emph{Помеченный ориентированный граф} --- это тройка $\mathbb{D} = \langle V, E, T \rangle$, где
\begin{itemize}
    \item $V$ --- конечное множество вершин, не умаляя общности пронумеруем вершины натуральными числами от $0$ до $|V|-1$;
    \item $T$ --- конечное множество меток на ребрах;
    \item $E \subseteq V \times T \times V$ --- конечное множество ребер.
\end{itemize}
\end{rudefinition}

\begin{rudefinition}
 \emph{Путь $\pi$ в графе} $\mathbb{D} = \langle V, E, T \rangle$ --- это конечная последовательность ребер $(e_0, e_1, ..., e_{n-1})$, где $\forall~ j,~ 0 \leq j \leq n - 1: e_j=(v_j,t_j,v_{j+1}) \in E$.
Определим множество всех путей в графе $\mathbb{D}$ как $\pi(\mathbb{D})$.
\end{rudefinition}

\begin{rudefinition}
    \emph{Слово, соответствующее пути} $\pi = (e_0, e_1, ..., e_{n-1})$, определим как последовательную конкатенацию меток ребер пути $l(\pi) = t_0 t_1 \dots t_{n - 1}$.
\end{rudefinition}

\subsection{Задачи поиска путей с контекстно-свободными ограничениями}
Теперь мы можем приступить к формальным определениям задач поиска путей с контекстно-свободными ограничениями.

Пусть даны:
\begin{itemize}
      \item контекстно-свободная грамматика $\mathbb{G} = \langle N, \Sigma, P, S \rangle$;
      \item помеченный ориентированный граф $\mathbb{D} = \langle V, E, T \rangle$;
      \item  множество стартовых вершин $V_S \subseteq V$ и множество финальных вершин \mbox {$V_F \subseteq V$}.
\end{itemize}

В введенных обозначениях могут быть сформулированы cледующие задачи.

\begin{itemize}
    \item \textbf{Задача поиска путей в графе с контекстно-свободными ограничениями} состоит в нахождении всех путей в графе таких что $l(\pi) \in L(\mathbb{G})$ и $v_0 \in V_S, ~v_n \in V_F$.
    \item \textbf{Задача поиска достижимостей в графе с контекстно-сво-бодными ограничениями} заключается в поиске множества пар вершин, для которых существует такой путь с началом и концом в этих вершинах, что слово, составленное из меток рёбер пути, принадлежит заданному языку: $\{(v_i, v_j ) ~|~ \exists ~l(\pi): ~l(\pi) \in L(\mathbb{G})$ и $v_0 \in V_S, ~v_n \in V_F\}$.
\end{itemize}

\subsection{Обобщенный LL алгоритм}
Одной из наиболее популярных техник синтаксического разбора является LL(k)-парсер, который представляет собой алгоритм нисходящего анализа с предпросмотром. 
Это означает, что решение о том, какая из продукций контекстно-свободной грамматики должна быть применена, базируется на предпросмотре $k$ следующих от текущего символов.
Для выбора правильной продукции поддерживается специальная таблица, в которой хранится информация для разбора текущего символа.
Однако, этот алгоритм может быть применен лишь к небольшому подмножеству контекстно-свободных грамматик.
Например, данный алгоритм неприменим к неоднозначным грамматикам или грамматикам с непосредственной левой рекурсией.

Алгоритмы нисходящего анализа относительно проще реализовывать и отлаживать, чем алгоритмы восходящего анализа, так как они полностью соотносятся со структурой грамматики.
По этой причине для того, чтобы поддержать весь класс контекстно-свободных грамматик, был предложен обобщенный вариант LL(k) алгоритма --- GLL (Generalized LL)~\cite{intro}. 
В случае LL(k) алгоритма может возникнуть такая ситуация, что невозможно определить, какая продукция должна быть выбрана в текущем состоянии синтаксического разбора.
Для решения данной проблемы в GLL вместо выбора одной продукции выбираются все допустимые продукции.
Такой подход позволяет во время работы алгоритма рассмотреть все возможные переходы из одного состояния разбора в другое.

Процесс работы GLL можно рассматривать как процесс обхода грамматики, управляемый входной строкой.
В каждый момент времени работы алгоритма GLL поддерживается дескриптор, состоящий из следующих объектов: $\langle A \rightarrow \alpha, c_{\alpha} \rangle$ --- \emph{позиция в грамматике}, $c_{i}$ --- \emph{позиция во входной строке}, $c_{u}$ --- \emph{текущая вершина GSS}, $c_{N}$ --- \emph{текущая вершина SPPF}.

\begin{rudefinition}
    \emph{Позиция в грамматике} --- это пара $\langle A \rightarrow \alpha, c_{\alpha} \rangle$, содержащая текущую продукцию в грамматике $A \rightarrow \alpha$ и индекс текущего символа в продукции соответственно.
    Наряду с обозначением $\langle A \rightarrow \alpha, c_{\alpha} \rangle$ примем обозначение $A \rightarrow \alpha \cdot X \beta$, где $c_{\alpha}$ соответствует индексу символа $X$, который может быть как терминальным, так и нетерминальным.
\end{rudefinition}

\begin{rudefinition}
    \emph{Позиция во входной строке} $c_{i}$ --- это индекс текущего символа во входной строке.
\end{rudefinition}

\begin{rudefinition}
    \emph{GSS} или \emph{графо-структурированный стек} --- граф, предназначенный для замены стека из LL(k)-парсера, вершины которого представляют пары $\langle \mathbb{L}, c_{i} \rangle$, что соответствует позиции в грамматике и позиции во входной строке на момент создания вершины, то есть некоторому состоянию разбора, а ребра обозначают рекурсивные переходы по грамматике и помечены соответствующими SPPF вершинами.
\end{rudefinition}

\begin{rudefinition}
    \emph{SPPF} --- сжатое представление леса разбора, которое содержит в себе все деревья вывода входной строки. 
\end{rudefinition}

Четверка $\langle \langle A \rightarrow \alpha, c_{\alpha} \rangle, c_{u}, c_{i}, c_{N} \rangle$ --- называется дескриптором.
В ходе работы GLL алгоритма поддерживается два множества:
\begin{itemize}
    \item $\mathbb{R}$ --- множество всех еще необработанных дескрипторов, представленное в виде очереди;
    \item $\mathbb{U}$ --- множество всех уже обработанных дескрипторов.
\end{itemize}
Изначально $\mathbb{R} = \{ \langle \langle S, 0 \rangle, c_{u}^{\varnothing}, 0, c_{N}^{\varnothing} \rangle \}$ и $\mathbb{U} = \varnothing$,
где $c_{u}^{\varnothing}$ --- специальная стартовая GSS вершина, $c_{N}^{\varnothing}$ --- пустое SPPF дерево.
Когда GLL алгоритм встречает терминальный символ на текущей позиции в грамматике $\langle A \rightarrow \alpha, c_{\alpha} \rangle$, если он совпадает с текущим символом входной строки, то в $\mathbb{R}$ добавляется дескриптор $\langle \langle A \rightarrow \alpha, c_{\alpha} + 1 \rangle, c_{u}, c_{i} + 1, c_{N}^{new} \rangle$, где $c_{N}^{new}$ является SPPF деревом разбора подстроки $0 \dots c_{i} + 1$, иначе, если символ на текущей позиции в грамматике не совпадает с текущим символом входной строки, то осуществляеся переход к следующему дескриптору в очереди $\mathbb{R}$.
Когда GLL алгоритм встречает нетерминальный символ на текущей позиции в грамматике $A \rightarrow \alpha \cdot X \beta$, создается вершина GSS $c_{u}^{new}$, содержащая текущее состояние разбора, и для каждой продукции $(X \rightarrow \gamma) \in P$ в $\mathbb{R}$ добавляются дескрипторы вида $\langle \langle X \rightarrow \gamma, 0 \rangle, c_{u}^{new}, c_{i}, c_{N}^{\varnothing} \rangle$, которых еще нет в $\mathbb{U}$.
GLL алгоритм завершается тогда, когда $\mathbb{R} = \varnothing$.

\subsection{Алгоритм выполнения контекстно-свободных запросов, базирующийся на GLL}
Как было сказано выше, алгоритмы на основе нисходящего анализа могут быть использованы для решения задачи поиска путей с контекстно-свободными ограничениями.
Более того, GLL алгоритм довольно естественным путем обобщается на входные данные в виде графов~\cite{GLL2}: вместо того, чтобы позициями входа считать индексы линейного входа, теперь будем считать ими вершины графа. 

Для сохранения корректности работы алгоритма вносятся следующие изменения. 

\begin{itemize}
\item Запрос теперь представляет собой тройку: множество стартовых вершин, множество финальных вершин и грамматику.
\item \emph{Позиция во входной строке} заменяется на вершину графа.
\item Начальное множество дескрипторов инициализируется дескрипторами, каждый из которых содержит стартовую вершину запроса.
\item На шаге перехода в грамматике обрабатываются все переходы по исходящим ребрам текущей вершины графа;
\item Если разбор завершен, необходимо проверить принадлежность вершины, на которой алгоритм остановился, к множеству финальных вершин графа.
\end{itemize}

Так же, как и в случае стандартного GLL алгоритма, данная модификация способна обрабатывать произвольные контекстно-свободные грамматики. 