\chapter{Experimental study}\label{ch:ch5}
The correctness of the proposed algorithms is formally proved in previous chapters. However, their performance requires experimental evaluation and comparison with existing solutions on real data.

\section{Experimental Setup}\label{sec:ch5/sect1}

In this work, it has been shown how the proposed approach can be used to obtain CFPQ algorithms and their implementations. The \textit{goal} of this experimental study is to answer the following \textit{questions}.

\begin{enumerate}
    \item [\textbf{[Q1]}] What is the performance of the obtained CFPQ implementations for the reachability query semantics compared to existing solutions on real data?
    \item [\textbf{[Q2]}] What is the performance of the obtained CFPQ implementations for the single-path and all-path query semantics compared to existing solutions on real data?
    \item [\textbf{[Q3]}] What are the overhead costs of storing information about the found paths in the obtained implementations compared to the obtained reachability implementations?
    \item [\textbf{[Q4]}] What is the performance of the obtained CFPQ implementations that do not require a transformation of the input CFG compared to other proposed implementations?
\end{enumerate}

To answer these questions, it is necessary to calculate the following two
\textit{metrics}:

\begin{enumerate}
    \item [\textbf{[M1]}] the implementation running time,
    \item [\textbf{[M2]}] the implementation memory consumption.
\end{enumerate}

In this experimental study, we select graphs obtained from real RDF data and from \texttt{C/C++} programs. Graph characteristics are presented in Tables~\ref{tab:RDFgraphs} and~\ref{tab:Cgraphs}. These tables contain the graph number; the number of graph vertices and edges; and the number of some edges with labels that later appear in the context-free path constraints.

\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{Graph characteristics for the RDF analysis~\cite{zhang2016context}\tnote{*}}\label{tab:RDFgraphs}%
        \begin{tabular}{| p{1cm} || p{3cm} | p{2.2cm} | p{2.2cm} | p{3cm} | p{3cm}l |}
            \hline
            \hline
            \centering \textnumero & \centering Graph   &  \centering $|V|$ & \centering $|E|$ & \centering  $\#\textit{subClassOf}$ & \centering  $\#\textit{type}$ &\\
            \hline
            %\centering 1 & atom &  \centering	291 & \centering	425 & \centering	122 & \centering	138 & \\
            %\centering 2 & biomedical &  \centering	341 & \centering	459 & \centering	122 & \centering	130& \\
            %\centering 3 & core  & \centering	1,323 & \centering	2,752 & \centering	178 & \centering	706& \\
            \centering 1 & eclass &  \centering	239,111 & \centering	360,248 & \centering	90,962 & \centering	72,517& \\
            %\centering 5 & enzyme & \centering	48,815 & \centering	86,543 & \centering	8,163 & \centering	14,989& \\
            %\centering 6 & foaf & \centering	256 & \centering	631 & \centering	10 & \centering	174& \\
            %\centering 7 & funding & \centering	778 & \centering	1,086 & \centering	90 & \centering	304& \\
            %\centering 8 & generations & \centering	129 & \centering	273 & \centering	0 & \centering	78& \\
            \centering 2 & go & \centering	582,929 & \centering	1,437,437 & \centering	94,514 & \centering	226,481& \\
            \centering 3 & go\_h & \centering	45,007 & \centering	490,109 & \centering	490,109 & \centering	0& \\
            %\centering 11 & pathways & \centering	6,238 & \centering	12,363 & \centering	3,117 & \centering	3,118& \\
            %\centering 12 & people & \centering	337 & \centering	640 & \centering	33 & \centering	161& \\
            %\centering 13 & pizza & \centering	671 & \centering	1,980 & \centering	259 & \centering	365& \\
            %\centering 14 & skos & \centering	144 & \centering	252 & \centering	1 & \centering	70& \\
            \centering 4 & taxonomy & \centering	5,728,398 & \centering	14,922,125 & \centering	2,112,637 & \centering	2,508,635& \\
            \centering 5 & taxonomy\_h & \centering	2,112,625 & \centering	32,876,289 & \centering	32,876,289 & \centering	0& \\
            %\centering 17 & travel & \centering	131 & \centering	277 & \centering	30 & \centering	90& \\
            %\centering 18 & univ & \centering	179 & \centering	293 & \centering	36 & \centering	84& \\
            %\centering 19 & wine & \centering	733 & \centering	1,839 & \centering	126 & \centering	485& \\
            \hline
            \hline
        \end{tabular}
        \small{
        \begin{tablenotes}
            \item[*] $|V|$ is a number of graph vertices, $|E|$ is a number of graph edges, $\#\textit{subClassOf}$ and $\#\textit{type}$ are number of edges with labels $\textit{subClassOf}$ and $\textit{type}$ respectively.
        \end{tablenotes}    }
    \end{threeparttable}
\end{table}

\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{Graph characteristics for the static program analysis~\cite{graspan}\tnote{*}}\label{tab:Cgraphs}%
        \begin{tabular}{| p{1cm} || p{4.5cm} | p{2.2cm} | p{2.2cm} | p{2.2cm} | p{2.2cm}l |}
            \hline
            \hline
            \centering \textnumero & \centering Graph & \centering $|V|$ & \centering $|E|$ & \centering  $\#a$ & \centering  $\#d$ &\\
            \hline
            \centering 6 & apache\_httpd\_ptg & \centering	1,721,418 & \centering	1,510,411 & \centering	362,799 & \centering	1,147,612 & \\
            \centering 7 & arch\_after\_inline & \centering	3,448,422 & \centering	2,970,242 & \centering	671,295 & \centering	2,298,947 & \\
            \centering 8 & block\_after\_inline & \centering	3,423,234 & \centering	2,951,393 & \centering	669,238 & \centering	2,282,155 & \\
            \centering 9 & crypto\_after\_inline & \centering	3,464,970 & \centering	2,988,387 & \centering	678,408 & \centering	2,309,979 & \\
            \centering 10 & drivers\_after\_inline & \centering	4,273,803 & \centering	3,707,769 & \centering	858,568 & \centering	2,849,201 & \\
            \centering 11 & fs\_after\_inline & \centering	4,177,416 & \centering	3,609,373 & \centering	824,430 & \centering	2,784,943 & \\
            \centering 12 & init\_after\_inline & \centering	2,446,224 & \centering	2,112,809 & \centering	481,994 & \centering	1,630,815 & \\
            \centering 13 & ipc\_after\_inline & \centering	3,401,022 & \centering	2,931,498 & \centering	664,151 & \centering	2,267,347 & \\
            \centering 14 & kernel\_after\_inline & \centering	11,254,434 & \centering	9,484,213 & \centering	1,981,258 & \centering	7,502,955 & \\
            \centering 15 & lib\_after\_inline & \centering	3,401,355 & \centering	2,931,880 & \centering	664,311 & \centering	2,267,569 & \\
            \centering 16 & mm\_after\_inline & \centering	2,538,243 & \centering	2,191,079 & \centering	498,918 & \centering	1,692,161 & \\
            \centering 17 & net\_after\_inline & \centering	4,039,470 & \centering	3,500,141 & \centering	807,162 & \centering	2,692,979 & \\
            \centering 18 & postgre\_sql\_ptg & \centering	5,203,419 & \centering	4,678,543 & \centering	1,209,597 & \centering	3,468,946 & \\
            \centering 19 & security\_after\_inline & \centering	3,479,982 & \centering	3,003,326 & \centering	683,339 & \centering	2,319,987 & \\
            \centering 20 & sound\_after\_inline & \centering	3,528,861 & \centering	3,049,732 & \centering	697,159 & \centering	2,352,573 & \\
            \hline
            \hline
        \end{tabular}
        \small{
        \begin{tablenotes}
            \item[*] $|V|$ is a number of graph vertices, $|E|$ is a number of graph edges, $\#a$ and $\#d$ are number of edges with labels $a$ and $d$ respectively.
        \end{tablenotes}    }
    \end{threeparttable}
\end{table}

This experimental study will perform two analyses: RDF data analysis~\cite{zhang2016context} and pointer analysis of \texttt{C/C++} programs~\cite{graspan}. Both analyses use languages describing different balanced bracket sequences with two types of brackets as path constraints. The derivation rules of the CFG $G_{\textit{RDF}}$ for the RDF analysis are as follows.
\[
	\begin{array}{rcclcrccl}
	0: & S & \rightarrow & \overline{\text{\emph{subClassOf}}} \ S \ \text{\emph{subClassOf}}  & \quad & 2: & S & \rightarrow & \overline{\text{\emph{type}}} \ S \ \text{\emph{type}}    \\
	1: & S & \rightarrow & \overline{\text{\emph{subClassOf}}} \ \text{\emph{subClassOf}}      & \quad & 3: & S & \rightarrow & \overline{\text{\emph{type}}} \ \text{\emph{type}}  \\
	
	\end{array}
\]

Also, the derivation rules of the CFG $G_{C}$ for the pointer analysis of \texttt{C/C++} programs are as follows.
	\[
	\begin{array}{rcclcrccl}
	0: & S & \rightarrow & \overline{\text{\emph{d}}} \ V \ \text{\emph{d}}  & \quad & 4: & V_3 & \rightarrow & \text{\emph{a}} \ V_2 \ V_3   \\
	1: & V & \rightarrow & V_1 \ V_2 \ V_3    & \quad & 5: & V_1 & \rightarrow & \varepsilon  \\
	2: & V_1 & \rightarrow & V_2 \ \overline{\text{\emph{a}}} \ V_1      & \quad & 6: &  V_2 & \rightarrow & \varepsilon \\
	3: & V_2 & \rightarrow & S     & \quad & 7: & V_3 & \rightarrow & \varepsilon  \\
	
	\end{array}
	\]

The CFL generated by the grammar $G_{\textit{RDF}}$ describes constraints for finding graph vertices that are on the same level of some hierarchy~\cite{zhang2016context}, and the language generated by the grammar $G_{C}$ allows one to find a set of heap objects that can flow to pointer variables~\cite{zheng2008demand}.

Note that these grammars also use labels $\overline{\text{\emph{subClassOf}}}$, $\overline{\text{\emph{type}}}$, $\overline{text{\emph{a}}}$, and $\overline{\text{\emph{d}}}$. Because for described analyses it is necessary to visit paths in a graph with inverse edges. Therefore, for all graph edges $(i, x, j)$ we explicitly add the inverse edges $(j, \overline{x}, i)$ where $x \in \{\text{\emph{subClassOf}}, \text{\emph{type}}, \text{\emph{a}}, \text{\emph{d}}\}$. All graphs and corresponding grammars are available as part of the dataset $\textit{CFPQ\_Data}\footnote{\text{CFPQ\_Data} is the dataset for CFPQ problem: https://jetbrains-research.github.io/CFPQ\_Data/ (date of access: 14.01.2022).}$.

The proposed implementations are described in sections~\ref{sec:ch3/sect5} and~\ref{sec:ch4/sect5}. Also, for described analyses we use existing open-source solutions that we were able to run. The complete list of notations for the implementations used in this experimental study is given below.

\begin{itemize}
    \item $\textbf{MRC}$ is the $\textit{MtxReach}_{\textit{CPU}}$ implementation of the proposed matrix-based CFPQ algorithm for the reachability query semantics.
    \item $\textbf{MRG}$ is the $\textit{MtxReach}_{\textit{GPU}}$ GPU implementation of the proposed matrix-based CFPQ algorithm for the reachability query semantics.
    \item $\textbf{MSC}$ is the $\textit{MtxSingle}_{\textit{CPU}}$ implementation of the proposed matrix-based CFPQ algorithm for the single-path query semantics.
    \item $\textbf{MAC}$ is the $\textit{MtxAll}_{\textit{CPU}}$ implementation of the proposed matrix-based CFPQ algorithm for the all-path query semantics.
    \item $\textbf{KAC}$ is the $\textit{KronAll}_{\textit{CPU}}$ implementation of the proposed Kronecker product-based CFPQ algorithm for the all-path query semantics.
    \item $\textbf{KAG}$ is the $\textit{KronAll}_{\textit{GPU}}$ GPU implementation of the proposed Kronecker product-based CFPQ algorithm for the all-path query semantics.
    \item $\textbf{Graspan}\footnote{\textit{Graspan} is a disk-based highly parallel interprocedural static analysis engine: https://github.com/Graspan/Graspan-C (date of access: 14.01.2022).}$ is a disk-based highly parallel interprocedural static analysis engine~\cite{graspan}. This implemenation is CPU-based and written in \texttt{C++}. Note that there is also a GPU \textit{Graspan} implementation, but we were unsuccessful in running it.
    \item $\textbf{LL}\footnote{\textit{LL} is the implementation of the CFPQ algorithm for the reachability query semantics based on the LL parsing algorithm: https://gitlab.com/ciromoraismedeiros/rdf-ccfpq (date of access: 14.01.2022).}$ is the implementation of the CFPQ algorithm~\cite{medeiros2018efficient} for the reachability query semantics based on the LL parsing algorithm. This implemenation is CPU-based and written in \texttt{Go} language.
    \item $\textbf{GLL}_{\textbf{R}}$ and $\textbf{GLL}_{\textbf{A}}\footnote{\textit{GLL\textsubscript{R}} and \textit{GLL\textsubscript{A}} are the implementations of the CFPQ algorithm for the single-path and all-path query semantics based on the GLL parsing algorithm: https://github.com/JetBrains-Research/GLL4Graph (date of access: 14.01.2022).}$ the implementations of the CFPQ algorithm~\cite{grigorev2017context} for the single-path and all-path query semantics based on the GLL parsing algorithm. These implemenations are CPU-based and written in \texttt{Java}. While the $\textit{GLL}_{\textit{A}}$ implementation constructs the SPPF to solve the CFPQ problem with all-path query semantics, the $\textit{GLL}_{\textit{R}}$ implementation solves the CFPQ problem with the reachability query semantics and omits this construction.
\end{itemize}

In addition, these implementations use different context-free path constraints representations. For some implementations the CFGs $G_{\textit{RDF}}$ and $G_C$ were converted to the WCNF, and for some implementations the corresponding recursive automata were constructed. Note that a transformation of the grammar $G_{\textit{RDF}}$ into the WCNF increased the number of nonterminals from 1 to 7 and the number of derivation rules from 4 to 10, while such a transformation of the the grammar $G_C$ increased the number of nonterminals from 5 to 13 and the number of derivation rules from 8 to 34.

To compare the performance of the discussed implementations, the average running time for 5 runs according to \textbf{[M1]} were calculated, as well as the consumed memory according to \textbf{[M2]}. For the single-path and all-path query semantics the path extraction time was not measured. The type of information about the paths to be extracted, as well as the choice from the variety of ways to obtain this information strongly depends on the application areas. For evaluation, we use a PC with Ubuntu 18.04 installed. In has Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz, DDR4 64GB RAM, a 64GB swap file, and GeForce GTX 1070 GPU with 8GB DDR5 memory.

\section{Results}\label{sec:ch5/sect2}

\paragraph{[Q1].} To answer the first question, we compared all the implementations that can solve the CFPQ problem with the reachability query semantics for the RDF analysis and the static program analysis. For the Kronecker product-based algorithm there is no specialized implementation for solving the reachability problem, and for this comparison the implementations $\textit{KronAll}_{\textit{CPU}}$ and $\textit{KronAll}_{\textit{GPU}}$ were used. For other algorithms only implementations specialized for solving the CFPQ problem with the reachability query semantics were chosen. According to \textbf{[M1]}, the average running time in seconds of the discussed implementations for the RDF analysis is presented in Table~\ref{tab:RDFresults}, and for pointer analysis in \texttt{C/C++} programs~--- in Table~\ref{tab:Cresults}. These tables contain the graph numbers and the size of the resulting set for the CFPQ problem with the reachability query semantics. That is, $\#\textit{result}$ is the number of pairs of vertices $(i, j)$ such that there exists at least one path from the vertex $i$ to the vertex $j$ that forms a word from the language generated by CFGs $G_{\textit{RDF}}$ and $G_C$. In addition, the smallest analysis time for each graph is highlighted.

\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{The running time in seconds of the CFPQ algorithms with the reachability query semantics for the RDF analysis~\cite{zhang2016context}\tnote{*}}\label{tab:RDFresults}%
        \begin{tabular}{| p{0.6cm} || p{2cm} | p{1.7cm} | p{1.7cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{0.9cm} l |}
            \hline
            \hline
            \centering \textnumero   & \centering $\#\textit{result}$ & \centering $\textit{Graspan}$ & \centering  $\textit{LL}$ & \centering  $\textit{GLL}_{\textit{R}}$ & \centering  $\textit{MRC}$ & \centering  $\textit{MRG}$ & \centering  $\textit{KAC}$ & \centering  $\textit{KAG}$ &\\
            \hline
            %\centering 1 & \centering	6 & \centering	\textbf{0.0}  & \centering	0.008 & \centering	0.008 & \centering	0.001 & \centering	0.005 & \centering	0.001 & \\
            %\centering 2 & \centering	47 & \centering	0.025 & \centering	0.008 & \centering	0.009 & \centering	\textbf{0.001} & \centering	0.006 & \centering	\textbf{0.001} & \\
            %\centering 3 & \centering	204 & \centering	0.025  & \centering	0.039 & \centering	0.019 & \centering	\textbf{0.001} & \centering	0.01 & \centering	0.004 & \\
            \centering 1 & \centering	90,994 & \centering	2.5  & \centering	9.3 & \centering	1.5 & \centering	\textbf{0.1} & \centering	\textbf{0.1} & \centering	0.3 & \centering 0.2 &\\
            %\centering 5 & \centering	396 & \centering	0.125  & \centering	1.157 & \centering	0.221 & \centering	\textbf{0.006} & \centering	0.016 & \centering	0.03 & \\
            %\centering 6 & \centering	36 & \centering	\textbf{0.0} & \centering	0.005 & \centering	0.006 & \centering	0.001 & \centering	0.005 & \centering	0.001 & \\
            %\centering 7 & \centering	58 & \centering	\textbf{0.0} & \centering	0.014 & \centering	0.012 & \centering	0.001 & \centering	0.006 & \centering	0.002 & \\
            %\centering 8 & \centering	12 & \centering	0.025  & \centering	0.003 & \centering	0.005 & \centering	\textbf{0.0} & \centering	0.003 & \centering	0.001 & \\
            \centering 2 & \centering	640,316 & \centering	12.8  & \centering	46.0 & \centering	5.6 & \centering	1.2 & \centering	\textbf{0.8} & \centering	3.2 & \centering 3.1 &\\
            \centering 3 & \centering	588,976 & \centering	0.9  & \centering	51.4 & \centering	3.7 & \centering	\textbf{0.1} & \centering	0.2 & \centering	0.2 & \centering 0.2 &\\
            %\centering 11 & \centering	884 & \centering	0.075  & \centering	0.292 & \centering	0.068 & \centering	\textbf{0.004} & \centering	0.009 & \centering	0.016 & \\
            %\centering 12 & \centering	51 & \centering	\textbf{0.0}	 &\centering	0.008 & \centering	0.007 & \centering	0.001 & \centering	0.009 & \centering	0.002 & \\
            %\centering 13 & \centering	1,356 & \centering	\textbf{0.0}  & \centering	0.037 & \centering	0.015 & \centering	0.001 & \centering	0.01 & \centering	0.004 & \\
            %\centering 14 & \centering	30 & \centering	\textbf{0.0}  & \centering	0.002 & \centering	0.005 & \centering	0.001 & \centering	0.005 & \centering	0.001 & \\
            \centering 4 & \centering	151,706 & \centering	3,938.0 & \centering	253.1 & \centering	45.5 & \centering	\textbf{1.0} & \centering	\textbf{1.0} & \centering	6.0 & \centering 3.9 &\\
            \centering 5 & \centering	5,351,657 & \centering	3,817.1  & \centering	3,023.8 & \centering	OOT & \centering	\textbf{10.9} & \centering	OOM & \centering	11.7 & \centering OOM &\\
            %\centering 17 & \centering	52 & \centering	0.033  & \centering	0.005 & \centering	0.006 & \centering	\textbf{0.001} & \centering	0.009 & \centering	\textbf{0.001} & \\
            %\centering 18 & \centering	25 & \centering	\textbf{0.0} & \centering	0.004 & \centering	0.006 & \centering	0.001 & \centering	0.009 & \centering	0.001 & \\
            %\centering 19 & \centering	565 & \centering	0.033  & \centering	0.037 & \centering	0.013 & \centering	\textbf{0.001} & \centering	0.009 & \centering	0.004 & \\
            \hline
            \hline
        \end{tabular}
        \small{
        \begin{tablenotes}
            \item[*] $\#\textit{result}$ is the size of resulting set; $\textit{Graspan}$ is a static program analysis tool~\cite{graspan}; $\textit{LL}$ is the implementation of the algorithm~\cite{medeiros2018efficient} based on the LL parsing algorithm; $\textit{GLL}_{\textit{R}}$ is the reachability implementation of the algorithm~\cite{grigorev2017context} based on the GLL parsing algorithm; $\textit{MRC}$ and $\textit{MRG}$ are CPU and GPU reachability implementations of the proposed matrix-based algorithm; $\textit{KAC}$ and $\textit{KAG}$ are CPU and GPU implementations of the proposed Kronecker product-based algorithm for the all-path query semantics.
        \end{tablenotes}    }
    \end{threeparttable}
\end{table}


\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{The running time in seconds of the CFPQ algorithms with the reachability query semantics for the static program analysis~\cite{graspan}\tnote{*}}\label{tab:Cresults}%
        \begin{tabular}{| p{0.6cm} || p{2.2cm} | p{1.7cm} | p{1.6cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{0.9cm}l |}
            \hline
            \hline
            \centering \textnumero   & \centering $\#\textit{result}$ & \centering $\textit{Graspan}$ & \centering  $\textit{LL}$ & \centering  $\textit{GLL}_{\textit{R}}$ & \centering  $\textit{MRC}$ & \centering  $\textit{MRG}$ & \centering  $\textit{KAC}$ & \centering  $\textit{KAG}$ &\\
            \hline
            \centering 6 & \centering	92,806,768 & \centering	2,619.1	 & \centering 8,390.4 & \centering	OOT & \centering	536.7 & \centering	\textbf{135.0} & \centering	6,165.0 & \centering OOM &\\
            \centering 7 & \centering	5,339,563 & \centering	49.8 & \centering	928.2 & \centering	130.8 & \centering	119.9 & \centering	\textbf{34.5} & \centering	307.1 & \centering 96.7 &\\
            \centering 8 & \centering	5,351,409	 & \centering 51.3 & \centering	924.9	 & \centering 113.0 & \centering	123.9 & \centering	\textbf{34.4} & \centering	311.7 & \centering 96.8 &\\
            \centering 9 & \centering	5,428,237 & \centering	52.4 & \centering	935.4 & \centering	128.8 & \centering	122.1 & \centering	\textbf{34.7} & \centering	314.2 & \centering 98.0 &\\
            \centering 10 & \centering	18,825,025 & \centering	330.2 & \centering	3,660.7 & \centering	371.2 & \centering	279.4 & \centering	\textbf{69.8} & \centering	1,381.5 & \centering OOM &\\
            \centering 11 & \centering	9,646,475 & \centering	95.4 & \centering	2,000.8 & \centering	167.7 & \centering	105.7 & \centering	\textbf{49.6} & \centering	533.1 & \centering 148.4 &\\
            \centering 12 & \centering	3,783,769	 & \centering 39.2 & \centering	644.4	 & \centering 87.2 & \centering	45.8 & \centering	\textbf{24.6} & \centering	215.9 & \centering 68.7 &\\
            \centering 13 & \centering	5,249,389	 & \centering 55.3  & \centering 898.5 & \centering	109.4	 & \centering 79.5 & \centering	\textbf{34.0} & \centering	301.3 & \centering 95.6 &\\
            \centering 14 & \centering	16,747,731 & \centering	161.7  & \centering OOM & \centering	614.0	 & \centering 378.1	 & \centering \textbf{104.8}	 & \centering 978.8 & \centering 292.9 &\\
            \centering 15 & \centering 	5,276,303 & \centering 	52.9  & \centering 	900.2 & \centering 	111.1 & \centering 	121.8	 & \centering \textbf{34.1} & \centering 	300.7 & \centering 96.0 &\\
            \centering 16	 & \centering 3,990,3	 & \centering 39.1 & \centering	671.3 & \centering	77.9 & \centering	84.1 & \centering	\textbf{25.5} & \centering	226.6 & \centering 71.8 &\\
            \centering 17 & \centering	8,833,403 & \centering	95.2 & \centering	1,851.0 & \centering	160.6 & \centering	206.3	 & \centering \textbf{55.2} & \centering	684.7 & \centering 176.1 &\\
            \centering 18 & \centering	90,661,446 & \centering	1,711.9 & \centering	OOM & \centering	OOT & \centering	969.9 & \centering	\textbf{170.4} & \centering	5,072.0 & \centering OOM &\\
            \centering 19 & \centering	5,593,387 & \centering	56.4 & \centering	942.7 & \centering	115.8 & \centering	181.7 & \centering	\textbf{35.1} & \centering	320.7 & \centering 99.2 &\\
            \centering 20 & \centering	6,085,269 & \centering	58.9 & \centering	968.8	 & \centering 120.1 & \centering	133.6	 & \centering \textbf{36.1} & \centering	339.5& \centering 103.9 &\\
            \hline
            \hline
        \end{tabular}
        \small{
        \begin{tablenotes}
            \item[*] $\#\textit{result}$ is the size of resulting set; $\textit{Graspan}$ is a static program analysis tool~\cite{graspan}; $\textit{LL}$ is the implementation of the algorithm~\cite{medeiros2018efficient} based on the LL parsing algorithm; $\textit{GLL}_{\textit{R}}$ is the reachability implementation of the algorithm~\cite{grigorev2017context} based on the GLL parsing algorithm; $\textit{MRC}$ and $\textit{MRG}$ are CPU and GPU reachability implementations of the proposed matrix-based algorithm; $\textit{KAC}$ and $\textit{KAG}$ are CPU and GPU implementations of the proposed Kronecker product-based algorithm for the all-path query semantics.
        \end{tablenotes}    }
    \end{threeparttable}
\end{table}

The RDF analysis results presented in Table~\ref{tab:RDFresults}. The smallest analysis time was demonstrated by the implementations $\textit{MtxReach}_{\textit{CPU}}$ ($\textit{MRC}$) and $\textit{MtxReach}_{\textit{GPU}}$ ($\textit{MRG}$) of the proposed matrix-based algorithm. Note that all implementations $\textit{MtxReach}_{\textit{CPU}}$, $\textit{MtxReach}_{\textit{GPU}}$, $\textit{KronAll}_{\textit{CPU}}$ ($\textit{KAC}$), and $\textit{KronAll}_{\textit{GPU}}$ ($\textit{KAG}$) demonstrate smaller running time than existing solutions. The implementations $\textit{LL}$ and $\textit{GLL}_{\textit{R}}$ demonstrate comparable running time to the $\textit{Graspan}$ tool. While the proposed implementations analyze these graphs up to 277 times faster than the best considered existing solution. Note that for this analysis, the most time-consuming is the graph $\textit{taxonomy\_h}$ with number 5 and with more than 5 million pairs of vertices in the resulting set. The implementation $\textit{GLL}_{\textit{R}}$ did not complete the analysis in 5 hours and this is marked by OOT (Out Of Time) in the table, while the implementations $\textit{MtxReach}_{\textit{GPU}}$ and $\textit{KronAll}_{\textit{GPU}}$ terminate because of out of memory error and this is marked by OOM.

To compare implementations using larger graphs with millions of vertices and edges, as well as using more time-consuming analysis with tens of millions pairs of vertices in the resulting sets, the results presented in Table~\ref{tab:Cresults} are more revealing. For pointer analysis in \texttt{C/C++} programs, the GPU implementation $\textit{MtxReach}_{\textit{GPU}}$ of the proposed matrix-based algorithm showed the best results on all graphs. Such results can be explained by the fact that for time-consuming analysis of large graphs the data exchange between CPU and GPU for implementing high-performance parallel analysis on GPU is reasonable. Therefore, the implementation $\textit{MtxReach}_{\textit{GPU}}$ allows one to perform this analysis on selected graphs up to 19 times faster than the best considered existing solution, i.e. the $\textit{Graspan}$ tool. Another proposed GPU implementation $\textit{KronAll}_{\textit{GPU}}$ demonstrates longer running time since this implementation is not specialized for the CFPQ problem with the reachability query semantics and computes redundant information, which is sufficient to construct any number of paths found. If we consider only CPU implementations, the proposed implementation $\textit{MtxReach}_{\textit{CPU}}$ shows comparable results to the $\textit{Graspan}$ tool, and for the most time-consuming graphs (with numbers 6, 10, and 18) it achieves almost a 5 times faster analysis. This is an impressive result, taking into account that the $\textit{Graspan}$ tool specializes for this type of graph analysis. The running time of the $\textit{GLL}_{\textit{R}}$ implementation is comparable to the running time of the $\textit{MtxReach}_{\textit{CPU}}$ implementation, but the former lacked 5 hours to analyze the two most time-consuming graphs with numbers 6 and 18. The longest running time was shown by the implementations $\textit{LL}$ and $\textit{KronAll}_{\textit{CPU}}$. However, the $\textit{KronAll}_{\textit{CPU}}$ implementation is not specialized in solving the CFPQ problem with the reachability query semantics. In this analysis, the computation of redundant information significantly affected the running time of the $\textit{KronAll}_{\textit{CPU}}$ implementation.

According to \textbf{[M2]}, we also compared the memory consumption of the discussed implementations. The results of this comparison are presented in Tables~\ref{tab:RDFmemory} and~\ref{tab:Cmemory}, where for each graph the lowest memory consumption is highlighted. For the RDF analysis, the $\textit{Graspan}$ tool shows the lowest memory consumption that can be seen in Table~\ref{tab:RDFmemory}. For this analysis, the proposed implementations consume up to 6 times more memory than the $\textit{Graspan}$ tool, but significantly less memory than other existing solutions $\textit{LL}$ and $\textit{GLL}_{\textit{R}}$. For the pointer analysis in $\texttt{C/C++}$ programs, the $\textit{MtxReach}_{\textit{GPU}}$ implementation of the proposed matrix-based algorithm has the lowest memory consumption as shown in Table~\ref{tab:Cmemory}. Also, the $\textit{MtxReach}_{\textit{CPU}}$ implementation consumes a comparable amount of memory to the $\textit{Graspan}$ tool. Thus, for this analysis, the proposed implementations reduce memory consumption by up to 2 times compared to the best considered existing solution. As expected, the proposed implementations $\textit{KronAll}_{\textit{CPU}}$ and $\textit{KronAll}_{\textit{GPU}}$ consume more memory than the $\textit{Graspan}$ tool due to computing redundant information to the CFPQ problem with the reachability query semantics. However, these implementations consume significantly less memory than other existing solutions $\textit{LL}$ and $\textit{GLL}_{\textit{R}}$.

\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{The memory consumption in megabytes of the CFPQ algorithms with the reachability query semantics for the RDF analysis~\cite{zhang2016context}\tnote{*}}\label{tab:RDFmemory}%
        \begin{tabular}{| p{0.6cm} || p{2cm} | p{1.7cm} | p{1.7cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{1.0cm} l |}
            \hline
            \hline
            \centering \textnumero   & \centering $\#\textit{result}$ & \centering $\textit{Graspan}$ & \centering  $\textit{LL}$ & \centering  $\textit{GLL}_{\textit{R}}$ & \centering  $\textit{MRC}$ & \centering  $\textit{MRG}$ & \centering  $\textit{KAC}$ & \centering  $\textit{KAG}$ &\\
            \hline
            %\centering 1 & \centering	6 & \centering	  & \centering	& \centering	& \centering	& \centering	 & \centering	 & \\
            %\centering 2 & \centering	47 & \centering	 & \centering	 & \centering	 & \centering	 & \centering	 & \centering	 & \\
            %\centering 3 & \centering	204 & \centering	  & \centering	 & \centering	& \centering	 & \centering	& \centering	 & \\
            \centering 1 & \centering	90,994 & \centering	\textbf{101}  & \centering	470 & \centering 1,263	& \centering 240	 & \centering 307	 & \centering 279	 & \centering 357 &\\
            %\centering 5 & \centering	396 & \centering	  & \centering	 & \centering	& \centering	 & \centering	 & \centering	& \\
            %\centering 6 & \centering	36 & \centering	 & \centering	 & \centering	& \centering	 & \centering & \centering	 & \\
            %\centering 7 & \centering	58 & \centering	 & \centering	 & \centering	& \centering	 & \centering	 & \centering & \\
            %\centering 8 & \centering	12 & \centering	  & \centering	& \centering	& \centering	 & \centering	 & \centering	 & \\
            \centering 2 & \centering	640,316 & \centering \textbf{193}	  & \centering 1,406	 & \centering 1,192	& \centering	468 & \centering 	727 & \centering 468 &	\centering 829 & \\
            \centering 3 & \centering	588,976 & \centering \textbf{62}	 & \centering 431	 & \centering 3,177	& \centering 263	 & \centering 387	 & \centering 266 &	\centering 573 & \\
            %\centering 11 & \centering	884 & \centering	  & \centering	 & \centering	& \centering	 & \centering	 & \centering	 & \\
            %\centering 12 & \centering	51 & \centering		 &\centering	 & \centering	& \centering	 & \centering	 & \centering	 & \\
            %\centering 13 & \centering	1,356 & \centering	  & \centering	& \centering	& \centering	 & \centering	 & \centering	 & \\
            %\centering 14 & \centering	30 & \centering	  & \centering	 & \centering	& \centering	 & \centering	 & \centering	 & \\
            \centering 4 & \centering	151,706 & \centering \textbf{1,498}	 & \centering 15,200	 & \centering 9,877	 & \centering 3,229	 & \centering 1,651	 & \centering 3,229 &	\centering 2,463 & \\
            \centering 5 & \centering	5,351,657 & \centering	\textbf{1,098}  & \centering 20,395	 & \centering	OOT & \centering 6,804	 & \centering	OOM & \centering 6,804 & \centering OOM & \\
            %\centering 17 & \centering	52 & \centering	  & \centering	 & \centering	 & \centering	 & \centering	& \centering	 & \\
            %\centering 18 & \centering	25 & \centering	 & \centering	 & \centering	 & \centering	 & \centering	 & \centering	 & \\
            %\centering 19 & \centering	565 & \centering	 & \centering	 & \centering	 & \centering	 & \centering	 & \centering & \\
            \hline
            \hline
        \end{tabular}
        \small{
        \begin{tablenotes}
            \item[*] $\#\textit{result}$ is the size of resulting set; $\textit{Graspan}$ is a static program analysis tool~\cite{graspan}; $\textit{LL}$ is the implementation of the algorithm~\cite{medeiros2018efficient} based on the LL parsing algorithm; $\textit{GLL}_{\textit{R}}$ is the reachability implementation of the algorithm~\cite{grigorev2017context} based on the GLL parsing algorithm; $\textit{MRC}$ and $\textit{MRG}$ are CPU and GPU reachability implementations of the proposed matrix-based algorithm; $\textit{KAC}$ and $\textit{KAG}$ are CPU and GPU implementations of the proposed Kronecker product-based algorithm for the all-path query semantics.
        \end{tablenotes}    }
    \end{threeparttable}
\end{table}

\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{The memory consumption in megabytes of the CFPQ algorithms with the reachability query semantics for the static program analysis~\cite{graspan}\tnote{*}}\label{tab:Cmemory}%
        \begin{tabular}{| p{0.4cm} || p{2.1cm} | p{1.7cm} | p{1.6cm} | p{1.55cm} | p{1.4cm} | p{1.4cm} | p{1.55cm} | p{1.0cm}l |}
            \hline
            \hline
            \centering \textnumero   & \centering $\#\textit{result}$ & \centering $\textit{Graspan}$ & \centering  $\textit{LL}$ & \centering  $\textit{GLL}_{\textit{R}}$ & \centering  $\textit{MRC}$ & \centering  $\textit{MRG}$ & \centering  $\textit{KAC}$ & \centering  $\textit{KAG}$ &\\
            \hline
            \centering 6 & \centering	92,806,768 & \centering	11,094	 & \centering 53,652 & \centering	OOT & \centering 11,619	 & \centering \textbf{5,585}	 & \centering 40,110 & \centering OOM &\\
            \centering 7 & \centering	5,339,563 & \centering 1,643	 & \centering 33,275	 & \centering 30,573	 & \centering 1,342	 & \centering \textbf{863}	 & \centering 2,954	 & \centering 2,209  &\\
            \centering 8 & \centering	5,351,409	 & \centering 1,638  & \centering 33,082		 & \centering 29,866  & \centering 1,331	 & \centering \textbf{849}	 & \centering 2,988	 & \centering 2,219  &\\
            \centering 9 & \centering	5,428,237 & \centering 1,660	 & \centering 33,472	 & \centering 29,317	 & \centering 1,305	 & \centering \textbf{849}	 & \centering 3,052	 & \centering 2,235 &\\
            \centering 10 & \centering	18,825,025 & \centering 3,474	 & \centering 46,060	 & \centering 49,262	 & \centering	3,181 & \centering	 \textbf{2,861} & \centering 9,012	 & \centering OOM  &\\
            \centering 11 & \centering	9,646,475 & \centering 2,330	 & \centering 41,429	 & \centering 31,128	 & \centering 1,958	 & \centering \textbf{1,099}	 & \centering 4,779	& \centering 3,723  &\\
            \centering 12 & \centering	3,783,769	 & \centering 1,170  & \centering 23,478	 & \centering 21,537 & \centering 1,015	 & \centering \textbf{687}	 & \centering 2,205 & \centering 1,649 &\\
            \centering 13 & \centering	5,249,389	 & \centering  1,620  & \centering 32,405 & \centering	29,205	 & \centering 1,268 & \centering \textbf{845}	 & \centering 2,922	 & \centering 2,173 &\\
            \centering 14 & \centering	16,747,731 & \centering	 5,083 & \centering OOM & \centering 41,449	 & \centering  3,466	 & \centering \textbf{1,959}	 & \centering 8,261  & \centering 5,763 &\\
            \centering 15 & \centering 	5,276,303 & \centering 1,624	  & \centering 32,414	 & \centering 29,432	 & \centering 	1,299	 & \centering \textbf{845}  & \centering  2,980	 & \centering 2,271  &\\
            \centering 16	 & \centering 3,990,305	 & \centering 1,219 & \centering	24,338 & \centering 86,190	 & \centering	1,036 & \centering	\textbf{691} & \centering 2,328	 & \centering 1,697  &\\
            \centering 17 & \centering	8,833,403 & \centering 2,271	 & \centering 40,185	 & \centering 31,358	 & \centering	1,888	 & \centering  \textbf{1,111} & \centering 4,680	 & \centering 4,069  &\\
            \centering 18 & \centering	90,661,446 & \centering	11,871 & \centering	OOM & \centering	OOT & \centering	11,018 & \centering	\textbf{5,297} & \centering 36,812	 & \centering OOM &\\
            \centering 19 & \centering	5,593,387 & \centering 1,688	 & \centering 33,689	 & \centering 30,228	 & \centering 1,336	 & \centering \textbf{857}	 & \centering 3,067	 & \centering 2,309  &\\
            \centering 20 & \centering	6,085,269 & \centering 1,763	 & \centering 34,324		 & \centering  31,699 & \centering	1,454	 & \centering  \textbf{887} & \centering	3,308 & \centering 2,415 &\\
            \hline
            \hline
        \end{tabular}
        \small{
        \begin{tablenotes}
            \item[*] $\#\textit{result}$ is the size of resulting set; $\textit{Graspan}$ is a static program analysis tool~\cite{graspan}; $\textit{LL}$ is the implementation of the algorithm~\cite{medeiros2018efficient} based on the LL parsing algorithm; $\textit{GLL}_{\textit{R}}$ is the reachability implementation of the algorithm~\cite{grigorev2017context} based on the GLL parsing algorithm; $\textit{MRC}$ and $\textit{MRG}$ are CPU and GPU reachability implementations of the proposed matrix-based algorithm; $\textit{KAC}$ and $\textit{KAG}$ are CPU and GPU implementations of the proposed Kronecker product-based algorithm for the all-path query semantics.
        \end{tablenotes}    }
    \end{threeparttable}
\end{table}

Thus, the answer to \textbf{[Q1]} is the following. The proposed implementations for the CFPQ problem with the reachability query semantics compared to the best considered existing solutions allow one to:
\begin{itemize}
    \item speed up the RDF analysis time by up to 277 times, while increase memory consumption by up to 6 times;
    \item speed up the pointer analysis of \texttt{C/C++} programs by up to 19 times, while reduce memory consumption by up to 2 times.
\end{itemize}

\paragraph{[Q2].} To answer the second question, the CFPQ implementations for the single-path and all-path query semantics was compared using the RDF analysis and the pointer analysis of \texttt{C/C++} programs. The only existing considered implementation that solves CFPQ problem with these path query semantics is the $\textit{GLL}_{\textit{A}}$ implementation of the algorithm based on the GLL parsing algorithm. According to \textbf{[M1]}, the average running time in seconds of the discussed implementations for the RDF analysis is presented in Table~\ref{tab:RDFpathResults}, and for the pointer analysis in \texttt{C/C++} programs~--- in Table~\ref{tab:CpathResults}. In addition, the smallest analysis time for each graph is highlighted.

\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{The running time in seconds of the CFPQ algorithms with the single-path and all-path query semantics for the RDF analysis~\cite{zhang2016context}\tnote{*}}\label{tab:RDFpathResults}%
        \begin{tabular}{| p{0.6cm} || p{2cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm}l |}
            \hline
            \hline
            \centering \textnumero   & \centering $\#\textit{result}$ & \centering  $\textit{GLL}_{\textit{A}}$ & \centering  $\textit{MSC}$ & \centering  $\textit{MAC}$ & \centering  $\textit{KAC}$ & \centering  $\textit{KAG}$ &\\
            \hline
            %\centering 1 & \centering	6 & \centering	  & \centering	& \centering		 & \centering	 & \\
            %\centering 2 & \centering	47 & \centering	 & \centering	 & \centering		 & \centering	 & \\
            %\centering 3 & \centering	204 & \centering	  & \centering	 & \centering		& \centering	 & \\
            \centering 1 & \centering	90,994 & \centering	3.0  & \centering	0.2 & \centering	\textbf{0.1}	 & \centering 0.3	 & \centering 0.2 &\\
            %\centering 5 & \centering	396 & \centering	  & \centering	 & \centering		 & \centering	& \\
            %\centering 6 & \centering	36 & \centering	 & \centering	 & \centering	 & \centering	 & \\
            %\centering 7 & \centering	58 & \centering	 & \centering	 & \centering		 & \centering & \\
            %\centering 8 & \centering	12 & \centering	  & \centering	& \centering		 & \centering	 & \\
            \centering 2 & \centering	640,316 & \centering	20.1  & \centering	 2.1	 & \centering \textbf{0.5}	 & \centering 3.2	 & \centering 3.1  &\\
            \centering 3 & \centering	588,976 & \centering 140.1	 & \centering	 0.4	 & \centering \textbf{0.2}	 & \centering \textbf{0.2}	 & \centering \textbf{0.2}  &\\
            %\centering 11 & \centering	884 & \centering	  & \centering	 	 & \centering	 & \centering	 & \\
            %\centering 12 & \centering	51 & \centering		 &\centering	 	 & \centering	 & \centering	 & \\
            %\centering 13 & \centering	1,356 & \centering	  & \centering		 & \centering	 & \centering	 & \\
            %\centering 14 & \centering	30 & \centering	  & \centering	 	 & \centering	 & \centering	 & \\
            \centering 4 & \centering	151,706 & \centering	 1,878.4	 & \centering	\textbf{3.0} & \centering 5.0	 & \centering 6.0	 & \centering 3.9 &\\
            \centering 5 & \centering	5,351,657 & \centering	OOT  & \centering	 25.7	 & \centering \textbf{11.0}	 & \centering	11.7	& \centering OOM &\\
            %\centering 17 & \centering	52 & \centering	  & \centering	 	 & \centering	& \centering	 & \\
            %\centering 18 & \centering	25 & \centering	 & \centering	 	 & \centering	 & \centering	 & \\
            %\centering 19 & \centering	565 & \centering	 & \centering	 	 & \centering	 & \centering & \\
            \hline
            \hline
        \end{tabular}
        \small{
        \begin{tablenotes}
            \item[*] $\#\textit{result}$ is the size of resulting set; $\textit{GLL}_{\textit{A}}$ is the implementation of the algorithm~\cite{grigorev2017context} for the all-path query semantics based on the GLL parsing algorithm; $\textit{MSC}$ and $\textit{MAC}$ are implementations of the proposed matrix-based algorithm for the single-path and all-path query semantics; $\textit{KAC}$ and $\textit{KAG}$ are CPU and GPU implementations of the proposed Kronecker product-based algorithm for the all-path query semantics.
        \end{tablenotes}    }
    \end{threeparttable}
\end{table}

\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{The running time in seconds of the CFPQ algorithms with the single-path and all-path query semantics for the static program analysis~\cite{graspan}\tnote{*}}\label{tab:CpathResults}%
        \begin{tabular}{| p{0.6cm} || p{2.2cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm}l |}
            \hline
            \hline
            \centering \textnumero   & \centering $\#\textit{result}$ & \centering  $\textit{GLL}_{\textit{A}}$ & \centering  $\textit{MSC}$ & \centering  $\textit{MAC}$ & \centering  $\textit{KAC}$& \centering  $\textit{KAG}$ &\\
            \hline
            \centering	6 & \centering	92,806,768 & \centering	OOT	  & \centering \textbf{1,611.5}	 & \centering OOM	 & \centering  6,165.0 & \centering OOM&\\
            \centering	7 & \centering	5,339,563 & \centering	728.5	 & \centering	132.8 & \centering 432.5	 & \centering 307.1	 & \centering \textbf{96.7} &\\
            \centering	8 & \centering	5,351,409	 & \centering 771.3 & \centering	111.6	 & \centering OOM & \centering	311.7 	 & \centering \textbf{96.8} &\\
            \centering	9 & \centering	5,428,237 & \centering	 750.2	 & \centering	139.1 & \centering OOM	 & \centering 314.2	 & \centering \textbf{98.0} &\\
            \centering	10 & \centering	18,825,025 & \centering	 1,222.3	 & \centering	\textbf{699.1} & \centering OOM	 & \centering 1,381.5	 & \centering OOM &\\
            \centering	11 & \centering	9,646,475 & \centering	 1,150.9	 & \centering 	\textbf{135.6} & \centering OOM	 & \centering 533.1	& \centering 148.4 &\\
            \centering	12 & \centering	3,783,769	 & \centering  368.9  & \centering	\textbf{53.4} & \centering	261.8 & \centering 215.9 & \centering 68.7 &\\
            \centering	13 & \centering	5,249,389	 & \centering   692.7	 & \centering 166.7 & \centering	405.5 & \centering 301.3	 & \centering \textbf{95.6} &\\
            \centering	14 & \centering	16,747,731 & \centering	 7,923.0  & \centering 474.9	 & \centering OOM	 & \centering 978.8  & \centering \textbf{292.9} &\\
            \centering	15 & \centering 	5,276,303 & \centering 	  712.6  & \centering 	166.0	 & \centering 437.8 & \centering  300.7	 & \centering \textbf{96.0} &\\
            \centering	16	 & \centering 3,990,305	 & \centering 396.8 & \centering	95.6 	 & \centering	301.8 & \centering 226.6	 & \centering \textbf{71.8} &\\
            \centering	17 & \centering	8,833,403 & \centering	1,010.1 & \centering	 \textbf{145.8}		 & \centering OOM & \centering 684.7	 & \centering 176.1 &\\
            \centering	18 & \centering	90,661,446 & \centering	 OOT & \centering	\textbf{2,024.0} & \centering OOM	 & \centering 5,072.0	 & \centering OOM &\\
            \centering	19 & \centering	5,593,387 & \centering	741.1	 & \centering	142.3 & \centering OOM	 & \centering 320.7	 & \centering \textbf{99.2} &\\
            \centering	20 & \centering	6,085,269 & \centering	759.0  & \centering	153.2	 & \centering OOM & \centering 339.5	& \centering \textbf{103.9} &\\
            \hline
            \hline
        \end{tabular}
        \small{
        \begin{tablenotes}
            \item[*] $\#\textit{result}$ is the size of resulting set; $\textit{GLL}_{\textit{A}}$ is the implementation of the algorithm~\cite{grigorev2017context} for the all-path query semantics based on the GLL parsing algorithm; $\textit{MSC}$ and $\textit{MAC}$ are implementations of the proposed matrix-based algorithm for the single-path and all-path query semantics; $\textit{KAC}$ and $\textit{KAG}$ are CPU and GPU implementations of the proposed Kronecker product-based algorithm for the all-path query semantics.
        \end{tablenotes}    }
    \end{threeparttable}
\end{table}

The RDF analysis results presented in Table~\ref{tab:RDFpathResults}. The smallest analysis time was demonstrated by the implementations $\textit{MtxSingle}_{\textit{CPU}}$ ($\textit{MSC}$) and $\textit{MtxAll}_{\textit{CPU}}$ ($\textit{MAC}$) of the proposed matrix-based algorithm. For the RDF analysis, the proposed implementations allow one to solve the CFPQ problem with single-path query semantics up to 1636 times faster compared to the $\textit{GLL}_{\textit{A}}$ implementation since the latter lacked to complete this analysis in 5 hours for the most time-consuming graph with number 5. The same conclusion is correct for the all-path query semantics, because the best analysis time for the graph with number 5 was shown by the implementation $\textit{MtxAll}_{\textit{CPU}}$ that solves the CFPQ problem with the all-path query semantics.

For the single-path query semantics, the smallest time of the pointer analysis of \texttt{C/C++} programs was demonstrated by the proposed implementations $\textit{MtxSingle}_{\textit{CPU}}$ and $\textit{KronAll}_{\textit{GPU}}$ as shown in Table~\ref{tab:CpathResults}. Such results can be explained by the facts that the $\textit{MtxSingle}_{\textit{CPU}}$ implementation is the only considered implementation specialized on the single-path query semantics, and the $\textit{KronAll}_{\textit{GPU}}$ implementation is the only GPU implementation in this comparison. For the all-path query semantics, the proposed implementations allow one to speed up the analysis time by up to 27 times compared to the existing solution $\textit{GLL}_{\textit{A}}$. This result is achieved using GPU implementation $\textit{KronAll}_{\\textit{GPU}}$ to analyze the graph with number 14.

According to \textbf{[M2]}, we also compared the memory consumption of the discussed implementations for the single-path and all-path query semantics. The results of this comparison are presented in Tables~\ref{tab:RDFpathMemory} and~\ref{tab:CpathMemory}, where the lowest memory consumption is highlighted. For the RDF analysis, the lowest memory consumption is demonstrated by the proposed $\textit{MtxAll}_{\textit{CPU}}$ implementation for both query semantics as can be seen in Table~\ref{tab:RDFpathMemory}. The exception is the least time-consuming graph with number 1. Thus, for the single-path and all-path query semantics, the proposed implementations consume for the RDF analysis up to 152 times less memory than the existing solution. Note that the proposed $\textit{MtxSingle}_{\textit{CPU}}$ implementation is specialized for solving the CFPQ problem with the single-path query semantics and consumes more memory than the $\textit{MtxAll}_{\textit{CPU}}$ implementation for the all-path query semantics. This can be explained by the fact that the $\textit{MtxAll}_{\textit{CPU}}$ implementation was written in \texttt{C++} with using its own \texttt{Python} wrapper, and the small number of distinct intermediate vertices in matrix elements from the $\textit{AllPathIndex}$ set can consume less memory than elements from the $\textit{PathIndex}$ set. Also, the proposed implementations consume comparable amount of memory to the existing $\textit{GLL}_{\textit{A}}$ implementation for the pointer analysis of \texttt{C/C++} programs with both query semantics as shown in Table~\ref{tab:CpathMemory}. However, for most of the discussed graphs the lowest memory consumption was shown by the proposed GPU implementation $\textit{KronAll}_{\textit{GPU}}$, while the implementation $\textit{MtxAll}_{\textit{CPU}}$ was terminated because of out of memory error.

\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{The memory consumption in megabytes of the CFPQ algorithms with the single-path and all-path query semantics for the RDF analysis~\cite{zhang2016context}\tnote{*}}\label{tab:RDFpathMemory}%
        \begin{tabular}{| p{0.6cm} || p{2cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm}l |}
            \hline
            \hline
            \centering \textnumero   & \centering $\#\textit{result}$ & \centering  $\textit{GLL}_{\textit{A}}$ & \centering  $\textit{MSC}$ & \centering  $\textit{MAC}$ & \centering  $\textit{KAC}$ & \centering  $\textit{KAG}$ &\\
            \hline
            %\centering	1 & \centering	6 & \centering	  & \centering	& \centering		 & \centering	 & \\
            %\centering	2 & \centering	47 & \centering	 & \centering	 & \centering		 & \centering	 & \\
            %\centering	3 & \centering	204 & \centering	  & \centering	 & \centering		& \centering	 & \\
            \centering	1 & \centering	90,994 & \centering	\textbf{49}  & \centering	257 & \centering 200		 & \centering 279	 & \centering 357 &\\
            %\centering	5 & \centering	396 & \centering	  & \centering	 & \centering		 & \centering	& \\
            %\centering	6 & \centering	36 & \centering	 & \centering	 & \centering	 & \centering	 & \\
            %\centering	7 & \centering	58 & \centering	 & \centering	 & \centering		 & \centering & \\
            %\centering	8 & \centering	12 & \centering	  & \centering	& \centering		 & \centering	 & \\
            \centering	2 & \centering	640,316 & \centering	649  & \centering	 545	 & \centering \textbf{337}	 & \centering 468	 & \centering 829  &\\
            \centering	3 & \centering	588,976 & \centering 30,444	 & \centering	 290	 & \centering \textbf{200}	 & \centering 266	 & \centering 573 &\\
            %\centering	11 & \centering	884 & \centering	  & \centering	 	 & \centering	 & \centering	 & \\
            %\centering	12 & \centering	51 & \centering		 &\centering	 	 & \centering	 & \centering	 & \\
            %\centering	13 & \centering	1,356 & \centering	  & \centering		 & \centering	 & \centering	 & \\
            %\centering	14 & \centering	30 & \centering	  & \centering	 	 & \centering	 & \centering	 & \\
            \centering	4 & \centering	151,706 & \centering	 9,108	 & \centering 3,805	 & \centering \textbf{1,595}	 & \centering 3,229	 & \centering 2,463  &\\
            \centering	5 & \centering	5,351,657 & \centering	 OOT & \centering	8,058 	 & \centering \textbf{2,720}	 & \centering 6,804		& \centering OOM &\\
            %\centering	17 & \centering	52 & \centering	  & \centering	 	 & \centering	& \centering	 & \\
            %\centering	18 & \centering	25 & \centering	 & \centering	 	 & \centering	 & \centering	 & \\
            %\centering	19 & \centering	565 & \centering	 & \centering	 	 & \centering	 & \centering & \\
            \hline
            \hline
        \end{tabular}
        \small{
        \begin{tablenotes}
           \item[*] $\#\textit{result}$ is the size of resulting set; $\textit{GLL}_{\textit{A}}$ is the implementation of the algorithm~\cite{grigorev2017context} for the all-path query semantics based on the GLL parsing algorithm; $\textit{MSC}$ and $\textit{MAC}$ are implementations of the proposed matrix-based algorithm for the single-path and all-path query semantics; $\textit{KAC}$ and $\textit{KAG}$ are CPU and GPU implementations of the proposed Kronecker product-based algorithm for the all-path query semantics.
        \end{tablenotes}    }
    \end{threeparttable}
\end{table}

\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{The memory consumption in megabytes of the CFPQ algorithms with the single-path and all-path query semantics for the static program analysis~\cite{graspan}\tnote{*}}\label{tab:CpathMemory}%
        \begin{tabular}{| p{0.6cm} || p{2.2cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm}l |}
            \hline
            \hline
            \centering \textnumero   & \centering $\#\textit{result}$ & \centering  $\textit{GLL}_{\textit{A}}$ & \centering  $\textit{MSC}$ & \centering  $\textit{MAC}$ & \centering  $\textit{KAC}$ & \centering  $\textit{KAG}$ &\\
            \hline
            \centering	6 & \centering	92,806,768 & \centering	OOT	  & \centering	\textbf{35,666} & \centering OOM	 & \centering 40,110 & \centering OOM &\\
            \centering	7 & \centering	5,339,563 & \centering	6,043	 & \centering	2,651 & \centering	62,423 & \centering 2,954	 & \centering  \textbf{2,209} &\\
            \centering	8 & \centering	5,351,409	 & \centering 5,874 & \centering	2,651	 & \centering OOM & \centering	2,988 	 & \centering  \textbf{2,219}  &\\
            \centering	9 & \centering	5,428,237 & \centering	 6,250	 & \centering 2,676	 & \centering OOM	 & \centering 3,052	 & \centering  \textbf{2,235}  &\\
            \centering	10 & \centering	18,825,025 & \centering	 \textbf{4,608}	 & \centering 8,332	 & \centering OOM	 & \centering 9,012	 & \centering  OOM  &\\
            \centering	11 & \centering	9,646,475 & \centering	 8,629	 & \centering 4,214	 & \centering OOM	 & \centering 4,779	& \centering  \textbf{3,723}  &\\
            \centering	12 & \centering	3,783,769	 & \centering  4,242  & \centering	1,964 & \centering	62,404 & \centering 2,205 & \centering  \textbf{1,649}  &\\
            \centering	13 & \centering	5,249,389	 & \centering   5,992	 & \centering 2,589 & \centering 62,384	 & \centering 2,922	 & \centering  \textbf{2,173} &\\
            \centering	14 & \centering	16,747,731 & \centering	 \textbf{5,136}  & \centering 	7,156 & \centering OOM	 & \centering 8,261 & \centering 5,763  &\\
            \centering	15 & \centering 	5,276,303 & \centering 	 6,094   & \centering 	2,632	 & \centering 62,421 & \centering 2,980	 & \centering \textbf{2,271}  &\\
            \centering  16	 & \centering 3,990,305	 & \centering 4,545 & \centering	 2,073	 & \centering 62,453	 & \centering 2,328	 & \centering  \textbf{1,697} &\\
            \centering	17 & \centering	8,833,403 & \centering	9,346 & \centering	 	4,201	 & \centering OOM & \centering 4,680 & \centering  \textbf{4,069} &\\
            \centering	18 & \centering	90,661,446 & \centering	 OOT & \centering \textbf{32,635}	 & \centering OOM	 & \centering 36,812	 & \centering  OOM  &\\
            \centering	19 & \centering	5,593,387 & \centering	6,157	 & \centering 2,759	 & \centering OOM	 & \centering 3,067	 & \centering  \textbf{2,309}  &\\
            \centering	20 & \centering	6,085,269 & \centering	6,842  & \centering	2,991	 & \centering OOM & \centering 3,308	& \centering  \textbf{2,415} &\\
            \hline
            \hline
        \end{tabular}
        \small{
        \begin{tablenotes}
            \item[*] $\#\textit{result}$ is the size of resulting set; $\textit{GLL}_{\textit{A}}$ is the implementation of the algorithm~\cite{grigorev2017context} for the all-path query semantics based on the GLL parsing algorithm; $\textit{MSC}$ and $\textit{MAC}$ are implementations of the proposed matrix-based algorithm for the single-path and all-path query semantics; $\textit{KAC}$ and $\textit{KAG}$ are CPU and GPU implementations of the proposed Kronecker product-based algorithm for the all-path query semantics.
        \end{tablenotes}    }
    \end{threeparttable}
\end{table}

According to the obtained results, \textbf{[Q2]} can be answered as follows. The proposed CFPQ implementations for the single-path and all-path query semantics compared to the considered existing solution allow one to:
\begin{itemize}
    \item speed up RDF analysis time by up to 1636 times, while reduce memory consumption by up to 152 times;
    \item speed up the pointer analysis of \texttt{C/C++} programs by up to 27 times, while consume comparable amount of memory.
\end{itemize}

\paragraph{[Q3].} To answer the third question, all proposed CFPQ implementations was compared. According to \textbf{[M1]}, the average running time in seconds of the proposed implementations for the RDF analysis is presented in Table~\ref{tab:RDFlaResults}, and for the pointer analysis of \texttt{C/C++} programs~--- in Table~\ref{tab:ClaResults}.

\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{The running time in seconds of the proposed CFPQ algorithms for the RDF analysis~\cite{zhang2016context}\tnote{*}}\label{tab:RDFlaResults}%
        \begin{tabular}{| p{0.6cm} || p{2cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{0.9cm}l |}
            \hline
            \hline
            \centering \textnumero   & \centering $\#\textit{result}$ & \centering  $\textit{MRC}$ & \centering  $\textit{MRG}$ & \centering  $\textit{MSC}$ & \centering  $\textit{MAC}$ & \centering  $\textit{KAC}$ & \centering  $\textit{KAG}$ &\\
            \hline
            %\centering 1 & \centering	6 & \centering	0.005  & \centering 0.001  & \centering 	& \centering		 & \centering 0.001	 & \\
            %\centering 2 & \centering	47 & \centering	 0.006 & \centering	0.001 & \centering & \centering		 & \centering 0.001	 & \\
            %\centering 3 & \centering	204 & \centering 0.01	  & \centering 0.001	 & \centering & \centering		& \centering 0.004	 & \\
            \centering 1 & \centering	90,994 & \centering	0.1  & \centering	0.1 & \centering 0.2 & \centering	0.1	 & \centering 0.3	 & \centering  0.2 &\\
            %\centering 5 & \centering	396 & \centering	0.016  & \centering	0.006 & \centering & \centering		 & \centering 0.03	& \\
            %\centering 6 & \centering	36 & \centering	 0.005 & \centering	0.001 & \centering & \centering	 & \centering	0.001 & \\
            %\centering 7 & \centering	58 & \centering	 0.006 & \centering	 0.001 & \centering & \centering		 & \centering 0.002 & \\
            %\centering 8 & \centering	12 & \centering	 0.003 & \centering	0.0 & \centering & \centering		 & \centering 0.001	 & \\
            \centering 2 & \centering	640,316 & \centering 1.2	  & \centering 0.8 & \centering	 2.1	 & \centering 0.5 & \centering	 3.2	 & \centering  3.1  & \\
            \centering 3 & \centering	588,976 & \centering 0.1	 & \centering 0.2 & \centering	 0.4	 & \centering 0.2	 & \centering 0.2	 & \centering 0.2  &\\
            %\centering 11 & \centering	884 & \centering 0.009	  & \centering 0.004	 	 & \centering & \centering	 & \centering	0.016 & \\
            %\centering 12 & \centering	51 & \centering	 0.009	 &\centering 0.001	 	 & \centering	 & \centering & \centering	0.002 & \\
            %\centering 13 & \centering	1,356 & \centering	0.01  & \centering 0.001		 & \centering	 & \centering & \centering 0.004	 & \\
            %\centering 14 & \centering	30 & \centering	 0.005  & \centering 0.001	 	 & \centering	 & \centering & \centering	0.001 & \\
            \centering 4 & \centering	151,706 & \centering 1.0	 	 & \centering 1.0	 & \centering 3.0	 & \centering 5.0 & \centering	6.0 & \centering 3.9  &\\
            \centering 5 & \centering	5,351,657 & \centering	10.9   & \centering	OOM	 & \centering 25.7	 & \centering 11.0 & \centering	11.7	& \centering  OOM &\\
            %\centering 17 & \centering	52 & \centering	 0.009 & \centering	 0.001	 & \centering	& \centering & \centering	0.001 & \\
            %\centering 18 & \centering	25 & \centering	0.009 & \centering	 0.001	 & \centering	 & \centering & \centering	0.001 & \\
            %\centering 19 & \centering	565 & \centering 0.009	 & \centering 0.001	 	 & \centering	 & \centering & \centering 0.004 & \\
            \hline
            \hline
        \end{tabular}
        \small{
        \begin{tablenotes}
            \item[*] $\#\textit{result}$ is the size of resulting set; $\textit{MRC}$ and $\textit{MRG}$ are CPU and GPU reachability implementations of the proposed matrix-based algorithm; $\textit{MSC}$ and $\textit{MAC}$ are implementations of the proposed matrix-based algorithm for the single-path and all-path query semantics; $\textit{KAC}$ and $\textit{KAG}$ are CPU and GPU implementations of the proposed Kronecker product-based algorithm for the all-path query semantics.
        \end{tablenotes}    }
    \end{threeparttable}
\end{table}

\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{The running time in seconds of the proposed CFPQ algorithms for the static program analysis~\cite{graspan}\tnote{*}}\label{tab:ClaResults}%
        \begin{tabular}{| p{0.6cm} || p{2.2cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{0.9cm}l |}
            \hline
            \hline
            \centering \textnumero   & \centering $\#\textit{result}$ & \centering  $\textit{MRC}$ & \centering  $\textit{MRG}$ & \centering  $\textit{MSC}$ & \centering  $\textit{MAC}$ & \centering  $\textit{KAC}$ & \centering  $\textit{KAG}$ &\\
            \hline
            \centering 6 & \centering	92,806,768 & \centering	536.7	  & \centering 135.0 & \centering 1,611.5	 & \centering OOM & \centering 6,165.0 & \centering  OOM &\\
            \centering 7 & \centering	5,339,563 & \centering	119.9	 & \centering 34.5	 & \centering 132.8	 & \centering 432.5 & \centering	307.1 & \centering  96.7 &\\
            \centering 8 & \centering	5,351,409	 & \centering 123.9 & \centering 34.4		 & \centering 111.6  & \centering OOM	 & \centering 311.7	 & \centering 96.8 &\\
            \centering 9 & \centering	5,428,237 & \centering	 122.1	 & \centering 34.7	 & \centering 139.1	 & \centering OOM & \centering	314.2 & \centering 98.0 &\\
            \centering 10 & \centering	18,825,025 & \centering	 279.4	 & \centering 69.8	 & \centering 699.1	 & \centering OOM & \centering 1,381.5	 & \centering  OOM &\\
            \centering 11 & \centering	9,646,475 & \centering	 105.7	 & \centering 49.6	 & \centering 135.6	 & \centering OOM & \centering 533.1	& \centering 148.4 &\\
            \centering 12 & \centering	3,783,769	 & \centering  45.8  & \centering 24.6	 & \centering 53.4	 & \centering  261.8 & \centering 215.9 & \centering 68.7 &\\
            \centering 13 & \centering	5,249,389	 & \centering   79.5		 & \centering 34.0  & \centering 166.7	 & \centering 405.5 & \centering	301.3 & \centering 95.6 &\\
            \centering 14 & \centering	16,747,731 & \centering	 378.1  & \centering 104.8	 & \centering 474.9	 & \centering OOM & \centering  978.8 & \centering 292.9 &\\
            \centering 15 & \centering 	5,276,303 & \centering 	 121.8  	 & \centering 34.1		 & \centering 166.0 & \centering 437.8 & \centering 300.7	 & \centering 96.0 &\\
            \centering 16	 & \centering 3,990,305	 & \centering  84.1 & \centering 25.5	 	 & \centering 95.6	 & \centering 301.8 & \centering 226.6	 & \centering  71.8 &\\
            \centering 17 & \centering	8,833,403 & \centering	206.3 & \centering	  55.1		 & \centering 145.8 & \centering OOM	  & \centering 684.7 & \centering 176.1 &\\
            \centering 18 & \centering	90,661,446 & \centering	 969.9 & \centering 170.4	 & \centering 2,024.0	 & \centering OOM  & \centering	5,072.0 & \centering OOM &\\
            \centering 19 & \centering	5,593,387 & \centering	181.7	 & \centering 35.1	 & \centering 142.3	 & \centering OOM & \centering	320.7 & \centering  99.2 &\\
            \centering 20 & \centering	6,085,269 & \centering	133.6  & \centering 36.1		 & \centering 153.2  & \centering OOM & \centering 339.5	& \centering 103.9 &\\
            \hline
            \hline
        \end{tabular}
        \small{
        \begin{tablenotes}
            \item[*] $\#\textit{result}$ is the size of resulting set; $\textit{MRC}$ and $\textit{MRG}$ are CPU and GPU reachability implementations of the proposed matrix-based algorithm; $\textit{MSC}$ and $\textit{MAC}$ are implementations of the proposed matrix-based algorithm for the single-path and all-path query semantics; $\textit{KAC}$ and $\textit{KAG}$ are CPU and GPU implementations of the proposed Kronecker product-based algorithm for the all-path query semantics.
        \end{tablenotes}    }
    \end{threeparttable}
\end{table}

The proposed implementations demonstrate comparable RDF analysis time as shown in Table~\ref{tab:RDFlaResults}. Note that storing information about the found paths in the proposed implementations slows down the analysis time by up to 3 times for the single-path query semantics, and by up to 4 times for the all-path query semantics. In turn, the results of the pointers analysis of \texttt{C/C++} programs presented in Table~\ref{tab:ClaResults} show that the $\textit{MtxReach}_{\textit{GPU}}$ implementation has the lowest running time compared to other proposed implementations. For both query semantics, the implementation $\textit{KronAll}_{\textit{GPU}}$ shows the lowest running time in most cases and slows down the analysis time by up to 3 times compared to the best proposed reachability implementation. The exceptions are the most time-consuming graphs with numbers 6, 10, and 18. For these graphs the $\textit{KronAll}_{\textit{GPU}}$ implementation terminates due to out of memory error. For these graphs, the proposed implementations solved the CFPQ problem with the single-path query semantics up to 12 times longer than the CFPQ problem with the reachability query semantics, and the CFPQ problem with the all-path query semantics~--- up to 46 times longer.

According to \textbf{[M2]}, we also compared the memory consumption of the proposed implementations. The results of this comparison are presented in Tables~\ref{tab:RDFlaMemory} and~\ref{tab:ClaMemory}. For the RDF analysis, the $\textit{MtxAll}_{\textit{CPU}}$ implementation for the all-path query semantics showed the lowest memory consumption. Therefore, for this analysis on the selected graphs using the proposed implementations there is no increase in memory consumption when storing information about the found paths. At the same time, for the pointer analysis of \texttt{C/C++} programs, the $\textit{MtxReach}_{\textit{GPU}}$ implementation that solves the reachability problem showed the lowest memory consumption. For the single-path and all-path query semantics, the lowest memory consumption is shown by the $\textit{KronAll}_{\textit{GPU}}$ implementation in most cases. This implementation consume up to 4 times more memory compared to the best reachability implementation. The exceptions are the three most time-consuming graphs. For these graphs, the proposed implementations consumed up to 6 times more memory for the single-path query semantics than for the reachability query semantics, and up to 7 times more memory for the all-path query semantics.

\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{The memory consumption in megabytes of the proposed CFPQ algorithms for the RDF analysis~\cite{zhang2016context}\tnote{*}}\label{tab:RDFlaMemory}%
        \begin{tabular}{| p{0.6cm} || p{2cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{0.9cm}l |}
            \hline
            \hline
            \centering \textnumero   & \centering $\#\textit{result}$ & \centering  $\textit{MRC}$ & \centering  $\textit{MRG}$ & \centering  $\textit{MSC}$ & \centering  $\textit{MAC}$ & \centering  $\textit{KAC}$ & \centering  $\textit{KAG}$ &\\
            \hline
            %\centering 1 & \centering	6 & \centering	  & \centering & \centering	& \centering		 & \centering	 & \\
            %\centering 2 & \centering	47 & \centering	 & \centering	 & \centering & \centering		 & \centering	 & \\
            %\centering 3 & \centering	204 & \centering	  & \centering	 & \centering & \centering		& \centering	 & \\
            \centering 1 & \centering	90,994 & \centering	 240 & \centering 307	 & \centering 257 & \centering	200	 & \centering 279	 & \centering 357	&\\
            %\centering 5 & \centering	396 & \centering	  & \centering	 & \centering & \centering		 & \centering	& \\
            %\centering 6 & \centering	36 & \centering	 & \centering	 & \centering & \centering	 & \centering	 & \\
            %\centering 7 & \centering	58 & \centering	 & \centering	 & \centering & \centering		 & \centering & \\
            %\centering 8 & \centering	12 & \centering	  & \centering	& \centering & \centering		 & \centering	 & \\
            \centering 2 & \centering	640,316 & \centering 468 	  & \centering 727 & \centering	 545	 & \centering 337	 & \centering 468 	 & \centering 829	&\\
            \centering 3 & \centering	588,976 & \centering 263 	 & \centering 387  & \centering	 290	 & \centering 200	 & \centering 266	 & \centering 573	&\\
            %\centering 11 & \centering	884 & \centering	  & \centering	 	 & \centering & \centering	 & \centering	 & \\
            %\centering 12 & \centering	51 & \centering		 &\centering	 	 & \centering	 & \centering & \centering	 & \\
            %\centering 13 & \centering	1,356 & \centering	  & \centering		 & \centering	 & \centering & \centering	 & \\
            %\centering 14 & \centering	30 & \centering	  & \centering	 	 & \centering	 & \centering & \centering	 & \\
            \centering 4 & \centering	151,706 & \centering	 3,229 	 & \centering 1,651 	 & \centering 3,805	 & \centering 1,595 & \centering 3,229	 & \centering 2,463	&\\
            \centering 5 & \centering	5,351,657 & \centering 6,804	  & \centering OOM	 	 & \centering 8,058	 & \centering 2,720 & \centering	 6,804	& \centering OOM	&\\
            %\centering 17 & \centering	52 & \centering	  & \centering	 	 & \centering	& \centering & \centering	 & \\
            %\centering 18 & \centering	25 & \centering	 & \centering	 	 & \centering	 & \centering & \centering	 & \\
            %\centering 19 & \centering	565 & \centering	 & \centering	 	 & \centering	 & \centering & \centering & \\
            \hline
            \hline
        \end{tabular}
        \small{
        \begin{tablenotes}
            \item[*] $\#\textit{result}$ is the size of resulting set; $\textit{MRC}$ and $\textit{MRG}$ are CPU and GPU reachability implementations of the proposed matrix-based algorithm; $\textit{MSC}$ and $\textit{MAC}$ are implementations of the proposed matrix-based algorithm for the single-path and all-path query semantics; $\textit{KAC}$ and $\textit{KAG}$ are CPU and GPU implementations of the proposed Kronecker product-based algorithm for the all-path query semantics.
        \end{tablenotes}    }
    \end{threeparttable}
\end{table}

\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{The memory consumption in megabytes of the proposed CFPQ algorithms for the static program analysis~\cite{graspan}\tnote{*}}\label{tab:ClaMemory}%
        \begin{tabular}{| p{0.6cm} || p{2.2cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{1.4cm} | p{0.9cm}l |}
            \hline
            \hline
            \centering \textnumero   & \centering $\#\textit{result}$ & \centering  $\textit{MRC}$ & \centering  $\textit{MRG}$ & \centering  $\textit{MSC}$ & \centering  $\textit{MAC}$ & \centering  $\textit{KAC}$ & \centering  $\textit{KAG}$ &\\
            \hline
            \centering 6 & \centering	92,806,768 & \centering	11,619	  & \centering	5,585 & \centering 35,666	 & \centering OOM & \centering 40,110 & \centering OOM &\\
            \centering 7 & \centering	5,339,563 & \centering	1,342	 & \centering 863	 & \centering 2,651	 & \centering 62,423 & \centering	2,954 & \centering 2,209 &\\
            \centering 8 & \centering	5,351,409	 & \centering 1,331 & \centering 849		 & \centering 2,651 & \centering OOM	 & \centering 2,988	 & \centering 2,219 &\\
            \centering 9 & \centering	5,428,237 & \centering	 1,305	 & \centering 849	 & \centering 2,676	 & \centering OOM & \centering 3,052	 & \centering  2,235 &\\
            \centering 10 & \centering	18,825,025 & \centering	 3,181	 & \centering 2,861	 & \centering 8,332	 & \centering OOM & \centering	9,012 & \centering OOM &\\
            \centering 11 & \centering	9,646,475 & \centering	 1,958	 & \centering 1,099	 & \centering 4,214	 & \centering OOM & \centering 4,779	& \centering 3,723  &\\
            \centering 12 & \centering	3,783,769	 & \centering  1,015  & \centering 687	 & \centering 1,964	 & \centering 62,404  & \centering 2,205 & \centering  1,649 &\\
            \centering 13 & \centering	5,249,389	 & \centering   1,268		 & \centering 845  & \centering	2,589 & \centering 62,384 & \centering 2,922	 & \centering 2,173 &\\
            \centering 14 & \centering	16,747,731 & \centering 3,466   & \centering  1,959	 & \centering 7,156	 & \centering OOM & \centering 8,261 & \centering 5,763  &\\
            \centering 15 & \centering 	5,276,303 & \centering 	1,299   	 & \centering 845		 & \centering 2,632  & \centering 62,421 & \centering 2,980	 & \centering 2,271 &\\
            \centering 16 & \centering  3,990,305 & \centering 1,036 & \centering 691	 	 & \centering 2,073	 & \centering 62,453 & \centering 2,328	 & \centering 1,697 &\\
            \centering 17 & \centering	8,833,403 & \centering 1,888	 & \centering	 1,111		 & \centering 4,201  & \centering OOM	  & \centering 4,680 & \centering  4,069 &\\
            \centering 18 & \centering	90,661,446 & \centering	 11,018 & \centering 5,297	 & \centering 32,635	 & \centering OOM  & \centering	36,812 & \centering OOM &\\
            \centering 19 & \centering	5,593,387 & \centering	1,336	 & \centering 857	 & \centering 2,759	 & \centering OOM & \centering	3,067 & \centering 2,309 &\\
            \centering 20 & \centering	6,085,269 & \centering 1,454	  & \centering	887	 & \centering  2,991 & \centering OOM & \centering 3,308	& \centering  2,415  &\\
            \hline
            \hline
        \end{tabular}
        \small{
        \begin{tablenotes}
            \item[*] $\#\textit{result}$ is the size of resulting set; $\textit{MRC}$ and $\textit{MRG}$ are CPU and GPU reachability implementations of the proposed matrix-based algorithm; $\textit{MSC}$ and $\textit{MAC}$ are implementations of the proposed matrix-based algorithm for the single-path and all-path query semantics; $\textit{KAC}$ and $\textit{KAG}$ are CPU and GPU implementations of the proposed Kronecker product-based algorithm for the all-path query semantics.
        \end{tablenotes}    }
    \end{threeparttable}
\end{table}

Thus, \textbf{[Q3]} can be answered as follows. The overhead costs of storing information about the found paths
in the obtained implementations compared to the obtained reachability implementations are:
\begin{itemize}
    \item up to 4 times slower RDF analysis;
    \item up to 46 times slower pointer analysis of \texttt{C/C++} programs with up to 7 times higher memory consumption.
\end{itemize}

\paragraph{[Q4].} To answer the last question, the proposed implementations for the Kronecker product-based algorithm that do not require a transformation of the input CFG was compared to the proposed implementations of the matrix-based algorithm. The results presented in Tables~\ref{tab:RDFlaResults}, \ref{tab:ClaResults}, \ref{tab:RDFlaMemory}, and~\ref{tab:ClaMemory} can also be used for this comparison. There are no specialized implementations of the Kronecker product-based algorithm for CFPQ problem with the reachability and single-path query semantics. Thus, we compare only implementations that solve the CFPQ problem with the all-path query semantics. In addition, the matrix-based CFPQ algorithm for the all-path query semantics is implemented only on CPU. Therefore, we compare only CPU implementations. Thus, for this comparison the $\textit{MtxAll}_{\textit{CPU}}$ and $\textit{KronAll}_{\textit{CPU}}$ implementations were chosen.

In Tables~\ref{tab:RDFlaResults} and~\ref{tab:RDFlaMemory} one can see that despite the increase in the grammar size after its transformation into the WCNF, the RDF analysis time of the $\textit{MtxAll}_{\textit{CPU}}$ implementation is not slower than the one of the $\textit{KronAll}_{\textit{CPU}}$ implementation that does not require a transformation of the input CFG. Also, the $\textit{MtxAll}_{\textit{CPU}}$ consumes up to 2 times less memory than the $\textit{KronAll}_{\textit{CPU}}$ implementation. The reason for this is the relatively small grammar size for this analysis, as well as the relatively small analysis complexity on the discussed graphs. However, other conclusions we can made for more complex pointer analysis of \texttt{C/C++} programs. In Tables~\ref{tab:ClaResults} and~\ref{tab:ClaMemory} one can see that the $\textit{MtxAll}_{\textit{CPU}}$ implementation is out of memory for most graphs, while for other graphs the $\textit{KronAll}_{\textit{CPU}}$ implementation completes analysis up to one and a half times faster and consumes up to 28 times less memory. The grammar transformation has led to the significant increase in the number of nonterminals and derivation rules of the grammar. Thus, the matrix-based algorithm must store a bigger number of Boolean matrices with large number of nonzero elements, and it must compute more matrix operations. Therefore, for such time-consuming analysis, this had a significant impact on the performance of the $\textit{MtxAll}_{\textit{CPU}}$ implementation.

Thus, \textbf{[Q4]} can be answered as follows. The proposed CPU implementation that does not require a transformation of the input CFG compared to the proposed CPU implementation of the matrix-based algorithm for the all-path query semantics:
\begin{itemize}
    \item does not speed up the RDF analysis consuming up to 2 times more memory due to the relatively small grammar size, as well as the relatively small analysis complexity;
    \item speeds up the pointer analysis of \texttt{C/C++} programs by up to one and a half times consuming up to 28 times less memory.
\end{itemize}

\paragraph{Summary.} Thus, according to the obtained results, we can conclude the following. The proposed approach to the CFPQ allows one to obtain high-performance parallel implementations that speed up the graph analysis time and consume less memory compared to the existing solutions on real data.

\section{Limitations}\label{sec:ch5/sect3}
The proposed approach and obtained CFPQ algorithms impose some limitations on their implementations. This section is devoted to a discussion of these limitations.

Firstly, to apply the obtained implementations it is required to formulate the needed graph analysis as a CFPQ problem. For this purpose, we must describe the path constraints using the appropriate CFL for this analysis. Note that some constraints cannot be described using the CFLs. For those constraints that can be expressed in the form of a CFL it is necessary to describe this language in the form required by the obtained algorithm. The algorithms proposed in this thesis use CFGs and recursive automata to represent CFLs. And for the matrix-based algorithm such grammars must be transformed into the WCNF. Such transformations can lead to the significant grammar size increase that will significantly affect the resulting implementation performance.

Secondly, the performance of the proposed implementations strongly depends on the input graph sparsity. When analyzing dense large graphs, the proposed implementations will either show unsatisfactory running time, or they will consume too much memory. Also, the proposed implementations are inefficient for small graphs and for simple analysis. In these cases the time spent on the organization of parallel computations exceeds, or is comparable to the analysis time itself.

Besides, after constructing a CFPQ algorithm using the proposed approach it is necessary to find a linear algebra library with implemented necessary operations, or to implement them independently. In the case of using standard matrix operations (matrix addition, multiplication, transposition, etc.) with standard data types (Boolean, integer, floating-point, etc.) such a library is easy to find. However, if the algorithm uses linear algebra objects with some custom data type for more complex graph analysis one may not find a suitable library. For using the GraphBLAS implementations, one need to make sure that the custom data type used as matrix and vector elements, and the operations on them, can be implemented using an algebraic structure similar to the semiring that the GraphBLAS standard allows.

\clearpage