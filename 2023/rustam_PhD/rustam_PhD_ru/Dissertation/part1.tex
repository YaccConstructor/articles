\chapter{Обзор}\label{ch:ch1}
В данной главе введены основные термины и определения, используемые в работе, а также приводится формальная постановка задач поиска путей в графе с заданными КС-ограничениями и рассматриваются существующие алгоритмы для их решения. Кроме того, рассматриваются основные идеи использования методов линейной алгебры для решения задач анализа графов, а также существующие библиотеки линейной алгебры, которые могут быть использованы для получения соответствующих высокопроизводительных реализаций.

\section{Основные понятия линейной алгебры}\label{sec:ch1/sec1}
В данном разделе вводится ряд обозначений и определений линейной алгебры, используемых в работе.

\begin{definition}[Алгебраическая структура]
\emph{Алгебраическая структура}~--- это непустое множество $\mathcal{S}$ (носитель) с заданным набором операций и отношений (сигнатурой), которое удовлетворяет некоторой системе аксиом.
\end{definition}

Далее приведём определения таких алгебраических структур, как полугруппа, моноид, группа и полукольцо.

\begin{definition}[Полугруппа]
Множество $\mathcal{S}$ с заданной на нём бинарной операцией $\circ : \mathcal{S} \times \mathcal{S} \to \mathcal{S}$ называется \emph{полугруппой} и обозначается $\langle \mathcal{S}, \circ \rangle$, если выполнена следующая аксиома.
\begin{itemize}
    \item Ассоциативность: $\forall (a, b, c\in \mathcal{S})\colon (a\circ b)\circ c = a\circ (b \circ c)$.
\end{itemize}
\end{definition}

\begin{definition}[Моноид]
	\emph{Моноидом} $\langle \mathcal{S}, \circ, \mathbb{0} \rangle$ называется такая полугруппа с некоторым выделенным элементом $\mathbb{0}$, что выполняется следующая аксиома.
	\begin{itemize}
    \item Наличие нейтрального элемента $\mathbb{0}$: $\forall a\in \mathcal{S}\colon (\mathbb{0} \circ a = a \circ \mathbb{0} = a)$.
    \end{itemize}
\end{definition}

\begin{definition}[Группа]
Непустое множество $\mathcal{S}$ с заданной на нём бинарной операцией $\circ: {\mathcal{S}} \times {\mathcal{S}} \to {\mathcal{S}}$ и нейтральным элементом $\mathbb{0} \in \mathcal{S}$ называется \emph{группой} $\langle \mathcal{S} ,\circ, \mathbb{0} \rangle$, если оно является моноидом с дополнительным требованием наличия обратных элементов. 
\begin{itemize}
\item Наличие обратного элемента: $ \forall a\in \mathcal{S}\quad \exists a^{-1}\in \mathcal{S}\colon (a \circ a^{-1}=a^{-1} \circ a = \mathbb{0})$.
\end{itemize}
\end{definition}


\begin{definition}[Полукольцо]

Непустое множество $\mathcal{S}$ с двумя бинарными операциями $\oplus \colon \mathcal{S} \times \mathcal{S} \to \mathcal{S}$ (часто называют сложением) и $\otimes \colon \mathcal{S} \times \mathcal{S} \to \mathcal{S}$ (часто называют умножением), а также выделенными нейтральными элементами $\mathbb{0}, \mathbb{1} \in \mathcal{S}$ называется \emph{полукольцом} $\langle \mathcal{S}, \oplus, \otimes, \mathbb{0}, \mathbb{1} \rangle$, если выполнены следующие условия.
\begin{enumerate}

\item $\langle \mathcal{S}, \oplus, \mathbb{0} \rangle$~--- это коммутативный моноид, нейтральным элементом которого является $\mathbb{0}$, и при этом  для любых $a, b, c \in \mathcal{S}$ имеем:
\begin{itemize}
	\item $(a \oplus b) \oplus c = a \oplus (b \oplus c),$
	\item $\mathbb{0} \oplus a = a \oplus \mathbb{0} = a,$
	\item $a \oplus b = b \oplus a.$
\end{itemize}

\item $\langle \mathcal{S}, \otimes, \mathbb{1} \rangle$~--- это моноид, нейтральным элементом которого является  $\mathbb{1}$, и при этом для любых $a, b, c \in \mathcal{S}$ справедливо следующее:
\begin{itemize}
	\item $(a \otimes b) \otimes c = a \otimes (b \otimes c),$
    \item $\mathbb{1} \otimes a = a \otimes \mathbb{1} = a.$
\end{itemize}

\item Операция $\otimes$ является дистрибутивной слева и справа относительно операции $\oplus$, т.е. выполняется следующее:
\begin{itemize}
	\item $a \otimes (b \oplus c) = (a \otimes b) \oplus (a \otimes c),$
    \item $(a \oplus b) \otimes c = (a \otimes c) \oplus (b \otimes c).$
\end{itemize}


\item Элемент $\mathbb{0}$ является \textit{аннигилятором} для операции $\otimes$, т.е. имеем:
\begin{itemize}
	\item $\forall a \in \mathcal{S}: \mathbb{0} \otimes a = a \otimes \mathbb{0} = \mathbb{0}.$
\end{itemize}

\end{enumerate}

Если операция $\otimes$ коммутативна, то говорят о коммутативном полукольце.

\end{definition}

Кроме того, на носителях введённых алгебраических структур может быть задано отношение частичного порядка, которое определяется следующим образом.

\begin{definition}[Отношение частичного порядка]
Бинарное отношение $\preceq$ на множестве $\mathcal{S}$ называется \textit{отношением частичного порядка}, если для любых $a, b, c \in \mathcal{S}$ выполнены следующие условия.
\begin{itemize}
	\item Рефлексивность: $a \preceq a$.
    \item Антисимметричность: eсли $a \preceq b$ и $b \preceq a$, то $a = b$. 
    \item Транзитивность: если $a \preceq b$ и $b \preceq c$, то $a \preceq c$. 
\end{itemize}
\end{definition}

Далее введём понятия матрицы и вектора, а также определим некоторые операции над ними.

\begin{definition}[Матрица]
Предположим, что имеется некоторая алгебраическая структура с носителем $\mathcal{S}$. Тогда \emph{матрицей} будем называть прямоугольный массив размера $n\times m, n > 0, m > 0$, заполненный элементами из $\mathcal{S}$. Говорят, что $n$~--- это \emph{высота} матрицы или количество строк в ней, а $m$~--- \emph{ширина} матрицы или количество столбцов.
\end{definition}

При доступе к элементам матрицы используются индексы. Индексация (нумерация) ведётся с левого верхнего угла, первым указывается строка элемента, вторым~--- его столбец. В работе будет использоваться индексация строк и столбцов, начинающаяся с нуля. Так, например, $M[0, 0]$~--- элемент матрицы, находящийся на пересечении верхней строки и левого столбца матрицы $M$.

\begin{definition}[Вектор]
\emph{Вектором} будем называть матрицу, хотя бы один из размеров которой равен единице. Если единице равна высота матрицы, то это \textit{вектор-строка}, если же единице равна ширина матрицы, то это \textit{вектор-столбец}.
\end{definition}

\begin{definition}[Скалярная операция]
Пусть $\langle \mathcal{S}, \circ \rangle$ является полугруппой, $M_{n \times m}$~--- это матрица над этой полугруппой, $x \in \mathcal{S}$.
Тогда результатом применения операции
$
scalar(M, x, \circ)  
$
является матрица
$
P_{n \times m}
$
такая, что $P[i, j] = M[i, j] \circ x$, а
$
scalar(x, M, \circ) = P_{n \times m}
$
, где $P[i, j] = x \circ M[i, j]$.

\end{definition}

\begin{definition}[Поэлементные операции]

Пусть $\langle \mathcal{S}, \oplus, \otimes, \mathbb{0}, \mathbb{1} \rangle$ является полукольцом, а $M_{n \times m}$ и $ N_{n \times m}$~--- это две матрицы одинакового размера над этим полукольцом.
Тогда результатом применения операции \textit{поэлементного сложения} $\bigoplus$ является матрица
$
P_{n \times m}= M \bigoplus N
$,
которая определяется как $P[i, j] = M[i, j] \oplus N[i, j]$. А результатом применения операции \textit{поэлементного умножения} $\bigotimes$ является матрица
$
P_{n \times m}= M \bigotimes N
$,
определённая как $P[i, j] = M[i, j] \otimes N[i, j]$.

\end{definition}

\begin{definition}[Умножение матриц]\label{def:MxM}

Пусть $\langle \mathcal{S}, \oplus, \otimes, \mathbb{0}, \mathbb{1} \rangle$ является полукольцом, а $M_{n \times m}$ и $ N_{m \times k}$~--- это две матрицы над этим полукольцом.
Тогда матрица
$
P_{n \times k}= M \cdot N
$
определяется как $P[i, j] = \bigoplus_{0 \leq l < m} M[i, l] \otimes N[l, j]$.

\end{definition}

\begin{definition}[Произведение Кронекера]

\label{def:kron}
Пусть $\langle \mathcal{S}, \circ \rangle$~--- полугруппа, $M_{m \times n}$ и $N_{p \times q}$~--- две матрицы над этой полугруппой.
Тогда \textit{произведение Кронекера} или тензорное произведение матриц $M$ и $N$~--- это следующая блочная матрица $C$ размера $mp \times nq$.
$$
C = M \times N =
\begin{pmatrix}
scalar(M[0, 0], N, \circ)   & \cdots & scalar(M[0, n - 1], N, \circ)   \\
\vdots                   & \ddots & \vdots       \\
scalar(M[m - 1, 0], N, \circ) & \cdots & scalar(M[m - 1, n - 1], N, \circ)
\end{pmatrix}
$$

\end{definition}


\section{Основные понятия теории графов}\label{sec:ch1/sec2}
В данном разделе вводится ряд обозначений, а также представляется основная информация из теории графов.

\begin{definition}[Граф]  
	\textit{Граф} $\mathcal{G} = \langle V, E, L \rangle$, где $V$~--- конечное множество вершин, $E \subseteq V \times L \times V$~--- конечное множество дуг, а $L$~--- конечное множество меток на дугах.
\end{definition}

В дальнейшем речь будет идти о конечных ориентированных помеченных графах.
Будем использовать термин \textit{граф} подразумевая именно конечный ориентированный помеченный граф, если только не оговорено противное.

Также будем считать, что все вершины пронумерованы подряд, начиная с нуля. То есть, с каждой вершиной ассоциируется некоторое неотрицательное целое число из отрезка $[0, |V| - 1]$, где $|V|$~--- количество вершин графа.

\begin{example}[Пример графа и его графического представления]
	Пусть дан следующий граф: $$\mathcal{G}_1 = \langle \{0, 1, 2, 3\}, \{(0, a, 1), (1, a, 2), (2, a, 0), (0, b, 3), (3, b, 0)\}, \{a, b\} \rangle.$$
	Графическое представление графа $\mathcal{G}_1$ показано на~\cref{fig:example_graph}.
\end{example}

\begin{figure}
	\begin{center}
		\begin{tikzpicture}[on grid, auto]
		\node[state] (q_0)   {$1$};
		\node[state] (q_1) [above right=1.4cm and 1.0cm of q_0] {$2$};
		\node[state] (q_2) [right=2.0cm of q_0] {$0$};
		\node[state] (q_3) [right=2.0cm of q_2] {$3$};
		\path[->]
		(q_0) edge  node {a} (q_1)
		(q_1) edge  node {a} (q_2)
		(q_2) edge  node {a} (q_0)
		(q_2) edge[bend left, above]  node {b} (q_3)
		(q_3) edge[bend left, below]  node {b} (q_2);
		\end{tikzpicture}
	\end{center}
	\caption{Графическое представление графа $\mathcal{G}_1$}
	\label{fig:example_graph}
\end{figure}

\begin{definition}[Дуга]
	\textit{Дуга} ориентированного помеченного графа $\mathcal{G} = \langle V, E, L \rangle$~--- это упорядоченная тройка $e = (v_i, l, v_j) \in V \times L \times V$.
\end{definition}

\begin{example}[Пример дуг графа]
	$(0, a, 1)$ и $(3, b, 0)$~--- это дуги графа $\mathcal{G}_1$. При этом, $(3, b, 0)$ и $(0, b, 3)$~--- это разные дуги, что видно из~\cref{fig:example_graph}.
\end{example}

\begin{definition}[Кратные дуги]
	Две различные дуги $e_1 = (u_1, l_1, v_1)$ и $e_2 = (u_2, l_2, v_2)$ ориентированного помеченного графа $\mathcal{G} = \langle V, E, L \rangle$ называются \textit{кратными}, если $u_1 = u_2$ и $v_1 = v_2$.
\end{definition}

\begin{definition}[Путь]
	\textit{Путём} $\pi$ в графе $\mathcal{G}$ будем называть последовательность дуг такую, что для любых двух последовательных дуг $e_1=(u_1, l_1, v_1)$ и $e_2=(u_2, l_2, v_2)$ в этой последовательности, конечная вершина первой дуги является начальной вершиной второй, то есть $v_1 = u_2$. Будем обозначать путь из вершины $v_0$ в вершину $v_n$ следующим образом: $$v_0 \pi v_n = e_0, e_1, \dots, e_{n - 1} = (v_0, l_0, v_1), (v_1, l_1, v_2), \dots, (v_{n - 1}, l_n, v_n).$$
\end{definition}

\begin{definition}[Цикл]
	\textit{Циклом} называется путь $\pi$ в графе $\mathcal{G}$ такой, что его начальная и конечная вершины совпадают, а все дуги~--- различны.
\end{definition}

Будем считать, что для множества меток $L$ всегда определена операция конкатенации $(\cdot): L^* \times L^* \to L^*$. При записи выражений символ точки (обозначение операции конкатенации) часто будем опускать: $l_1 \cdot l_2 = l_1l_2$.

\begin{definition}[Слово, образованное путём]
	\textit{Слово, образованное путём} $\pi = (v_0, l_0, v_1), (v_1, l_1, v_2), \dots, (v_{n - 1}, l_n, v_n)$,  будем обозначать как слово $\lambda(\pi) = l_0 l_1 \ldots l_n$, которое является конкатенацией меток всех дуг данного пути слева направо.
\end{definition}

\begin{example}[Пример путей графа]
	$(0, a, 1), (1, a, 2) = 0 \pi_1 2$~--- путь из вершины 0 в вершину 2 в графе $\mathcal{G}_1$.
	При этом, $(0, a, 1), (1, a, 2), (2, b, 3), (3, b, 2) = 0 \pi_2 2$~--- это тоже путь из вершины 0 в вершину 2 в графе $\mathcal{G}_1$, но он не равен $0 \pi_1 2$. Причем, $\lambda(\pi_1) = aa$ и $\lambda(\pi_2) = aabb$.
\end{example}

Также определим понятие отрицательного цикла для взвешенных графов, в которых с каждым ребром ассоциируется вещественное число и которые являются частным случаем помеченных графов.

\begin{definition}[Отрицательный цикл]
	\textit{Отрицательным циклом} во взвешенном графе $\mathcal{G} = \langle V, E, \mathbb{R} \rangle$ называется цикл с отрицательной суммой весов на его дугах.
\end{definition}

Кроме того, нам потребуется отношение, отражающее факт существования пути между двумя вершинами.

\begin{definition}[Отношение достижимости] \label{def:reach}
	\textit{Отношение достижимости} в графе:
	$(v_i, v_j) \in P \iff \exists v_i \pi v_j$.
\end{definition}

Также определим понятие матрицы смежности, что позволит использовать один из распространённых способов для представления графов в виде матриц.

\begin{definition}[Матрица смежности]
	\textit{Матрица смежности} графа $\mathcal{G}=\langle V, E, L \rangle$~--- это квадратная матрица $M$ размера $n \times n$, где $|V| = n$ и ячейки которой содержат множества меток на дугах этого графа.	При этом $l \in M[i, j] \iff \exists e = (i, l, j) \in E$.
\end{definition}

Заметим, что наше определение матрицы смежности отличается от классического, в котором матрица отражает лишь факт наличия хотя бы одной дуги и, соответственно, является булевой.

\begin{example}[Пример графа и его матрицы смежности]
    \label{example:adj}
	Пример помеченного графа представлен ниже:
	\begin{center}
		\begin{tikzpicture}[shorten >=1pt,on grid,auto]
		\node[state] (q_0)   {$1$};
		\node[state] (q_1) [above right = 1.4cm and 1cm of q_0] {$2$};
		\node[state] (q_2) [right = 2cm of q_0] {$0$};
		\node[state] (q_3) [right = 2cm of q_2] {$3$};
		\path[->]
		(q_0) edge  node {a} (q_1)
		(q_1) edge  node {a} (q_2)
		(q_2) edge  node {a} (q_0)
		(q_2) edge[bend left = 20]  node {a} (q_3)
		(q_2) edge[bend left = 60]  node {b} (q_3)
		(q_3) edge[bend left, below]  node {b} (q_2);
		\end{tikzpicture}
	\end{center}
	
	 Матрица смежности для этого графа будет выглядеть так:
	$$
	M = \begin{pmatrix}
	\varnothing   & \{a\}       & \varnothing & \{a,b\} \\
	\varnothing   & \varnothing & \{a\}       & \varnothing \\
	\{a\}         & \varnothing & \varnothing & \varnothing \\
	\{b\}  & \varnothing & \varnothing        & \varnothing
	\end{pmatrix}
	$$
\end{example}

Такие матрицы смежности могут быть представлены в виде множества булевых матриц. Для краткости значение булевой переменной $true$ будем обозначать единицей, а $false$~--- нулём.

\begin{definition}[Булева декомпозиция матрицы смежности]
	\textit{Булева декомпозиция матрицы смежности} $M$ графа $\mathcal{G}=\langle V, E, L \rangle$~--- это множество булевых матриц $\mathcal{M} = \{M^l \mid l \in L, M^l[i, j] = 1 \iff l \in M[i, j]\}$.
\end{definition}

\begin{example}[Пример булевой декомпозиции матрицы смежности $M$ из примера~\ref{example:adj}]
	Булева декомпозиция $\mathcal{M}$ состоит из матриц $M^a$  и $M^b$.
	$$
	M^a = \begin{pmatrix}
	0 & 1 & 0 & 1 \\
	0 & 0 & 1 & 0 \\
	1 & 0 & 0 & 0 \\
	0 & 0 & 0 & 0
	\end{pmatrix}
	$$
	
	$$
	M^b = \begin{pmatrix}
	0 & 0 & 0 & 1 \\
	0 & 0 & 0 & 0 \\
	0 & 0 & 0 & 0 \\
	1 & 0 & 0 & 0
	\end{pmatrix}
	$$
\end{example}


\begin{definition}[Произведение Кронекера двух графов]
	Пусть даны два помеченных графа $\mathcal{G}_1=\langle V_1, E_1, L_1 \rangle$ и $\mathcal{G}_2=\langle V_2, E_2, L_2 \rangle$. Тогда \textit{произведение Кронекера двух графов} $\mathcal{G}_1$ и $\mathcal{G}_2$~--- это граф $\mathcal{G} = \mathcal{G}_1 \times \mathcal{G}_2 = \langle V, E, L \rangle$, где
	\begin{itemize}
	    \item $V = V_1 \times V_2$,
	    \item $E = \{((u, v), l, (p, q)) \mid (u, l, p) \in E_1 \wedge (v, l, q) \in E_2\}$,
	    \item $L = L_1 \cap L_2$.
	\end{itemize}
\end{definition}

Из этого определения, а также из определения~\ref{def:kron} следует, что результатом произведения Кронекера матриц смежности двух графов $\mathcal{G}_1$ и $\mathcal{G}_2$, определённого для полугруппы $\langle 2^{L_1} \cup 2^{L_2}, \cap \rangle$, является матрица смежности произведения Кронекера этих графов $\mathcal{G}_1 \times \mathcal{G}_2$. Здесь $2^L$~--- множество всех подмножеств множества $L$.

\section{Основные понятия теории формальных языков}\label{sec:ch1/sec3}
В данном разделе вводится ряд обозначений, а также представляется основная информация из теории формальных языков.

\begin{definition}[Алфавит]
	\textit{Алфавит} $\Sigma$~--- это конечное множество некоторых элементов.
	Элементы этого множества будем называть \textit{символами}.
\end{definition}

%\begin{example}[Примеры алфавитов]
%	\begin{itemize}
%		\item Латинский алфавит $\Sigma = \{ a, b, c, \dots, z\}$
%		\item Кириллический алфавит $\Sigma = \{ \text{а, б, в, \dots, я}\}$
%		\item Алфавит чисел в шестнадцатеричной записи 
%		$$\Sigma = \{0, 1, 2, 3, 4, 5, 6, 7 ,8,9, A, B, C, D, E, F \}$$
%	\end{itemize}
%\end{example}

%Традиционное обозначение для алфавита~--- $\Sigma$. Для обозначения символов алфавита будем использовать строчные буквы латинского алфавита: $a, b, \dots, x, y, z$.

Как и в случае с множеством меток на дугах графа будем считать, что для алфавита $\Sigma$ всегда определена операция конкатенации $(\cdot): \Sigma^* \times \Sigma^* \to \Sigma^*$.

\begin{definition}[Слово]
	\textit{Слово} над алфавитом $\Sigma$~--- это конечная конкатенация символов алфавита $\Sigma$: $w = a_0 \cdot a_1 \cdot \ldots \cdot a_m$, где $w$~--- слово для любых $a_i \in \Sigma$.
\end{definition}

\begin{definition}[Длина слова]
	Пусть $w = a_0 \cdot a_1 \cdot \ldots \cdot a_m$~--- слово над алфавитом $\Sigma$.
	Будем называть $m + 1$ \textit{длиной слова} и обозначать как $|w|$. Кроме того, для обозначения пустого слова будем использовать символ $\varepsilon$, где $|\varepsilon| = 0$.
\end{definition}

\begin{definition}[Язык]
	\textit{Язык} над алфавитом $\Sigma$~--- это множество слов над алфавитом $\Sigma$.
\end{definition}

В качестве примера простейших языков можно привести  язык чисел в двоичной системе счисления $\{0, 1, 10, 11, 100 \dots\}$, а также язык всех правильных скобочных последовательностей $\{(), (()), ()(), (())(), \dots\}$.
	

Любой язык над алфавитом $\Sigma$ является подмножеством $\Sigma^*$~--- множества всех слов над алфавитом $\Sigma$. Заметим, что язык может является бесконечным множеством.

\begin{definition}[Формальная грамматика]
	\textit{Формальная грамматика} $G$~--- это четвёрка $\langle \Sigma, N, P, S \rangle$:  
	\begin{itemize}
		\item $\Sigma$ обозначает конечный алфавит терминальных символов или терминалов, 
		\item $N$~--- алфавит нетерминальных символов или нетерминалов, $\Sigma \cap N=\varnothing$, 
		\item $P$~--- конечное подмножество множества $$( \Sigma^* \cdot N \cdot (\Sigma \cup N)^* ) \times ( (\Sigma \cup N)^+ \cup \{\varepsilon\} ),$$  
		
		\item $S$~--- стартовый символ грамматики, $S  \in N$. 
	\end{itemize}
\end{definition}

Элемент $(a, b) \in P$ называется правилом вывода и записывается следующим образом: $a \rightarrow b$. При этом $a$ называется левой частью правила, а $b$~--- правой частью. Левая часть любого правила из $P$ обязана содержать хотя бы один нетерминал.


\begin{definition}[Вывод цепочки $w$ в грамматике $G$]    
Цепочка $w_2 \in  ( \Sigma \cup  N )^*$ \textit{непосредственно выводима} из цепочки   $w_1 \in ( \Sigma \cup N )^+$ в грамматике $G=\langle \Sigma, N, P, S \rangle$  (обозначается  $w_1 \rightarrow_G w_2$ ), если  $w_1 = x_1 \cdot y \cdot x_2, w_2 = x_1 \cdot z \cdot x_2$, где $x_1, x_2, z \in   (\Sigma \cup N )^*, y \in  (\Sigma \cup N )^+$ и правило вывода  $y \rightarrow z$  содержится в $P$. Индекс $G$ в обозначении $\rightarrow_G$ обычно опускают, если $G$ понятна из контекста.
	
Цепочка $w_2 \in  (\Sigma \cup  N )^*$  \textit{выводима} из цепочки  $w_1 \in (\Sigma \cup  N)^+$ в грамматике $G$  (обозначается  $w_1 \Rightarrow_G w_2$ ), если существуют цепочки $z_0, z_1, \ldots, z_n  (n \geq 0)$ такие, что $w_1 = z_0 \rightarrow z_1 \rightarrow \ldots \rightarrow z_n = w_2$ . При этом последовательность $z_0, z_1, \ldots, z_n$ называется выводом длины $n$.
\end{definition}

\begin{definition}[Язык, порождаемый грамматикой]  
	Язык, \textit{порождаемый} грамматикой $G = \langle \Sigma, N, P, S \rangle$~--- это множество $\mathcal{L}(G)  = \{ w \in \Sigma^*~|~S \Rightarrow w \}$.
\end{definition}

Важными классами языков, порождаемых формальными грамматиками, являются регулярные и контекстно-свободные языки~\cite{aho1973theory}. Одним из распространённых способов описания регулярных языков (порождаемых регулярными грамматиками) является их задание с использованием регулярных выражений.

\begin{definition}[Регулярное выражение]
Цепочка символов $R$ называется \textit{регулярным выражением} над алфавитом $\Sigma$, если её структура соответствует одному из следующих пунктов:
\begin{itemize}
    \item $a$, где $a \in \Sigma$;
    \item $\varepsilon$, где $\varepsilon$~--- пустая строка;
    \item $\varnothing$ (соответствует пустому языку);
    \item $R_1 \mid R_2$ (дизъюнкция), где $R_1$ и $R_2$ являются регулярными выражениями;
    \item $R_1 \cdot R_2$ (конкатенация), где $R_1$ и $R_2$ являются регулярными выражениями;
    \item $(R_1)^*$ (звезда Клини), где $R_1$~--- это регулярное выражение.
\end{itemize}
\end{definition}

Например, регулярное выражение $R = a \cdot (b)^*$ над алфавитом $\Sigma = \{a, b\}$ описывает язык, состоящий из слов, которые начинаются с символа $a$ с последующим некоторым (ноль или больше) количеством символов $b$.

\begin{definition}[Конечный автомат]
\textit{Детерминированный конечный автомат без $\varepsilon$-переходов} $T$~--- пятёрка $\langle \Sigma, Q, Q_s, Q_f, \delta \rangle$:
\begin{itemize}
    \item $\Sigma$~--- алфавит входных символов,
    \item $Q$~--- конечное множество состояний,
    \item $q_s \in Q$~--- начальное состояние,
    \item $Q_f \subseteq Q$~--- множество конечных состояний,
    \item $\delta: Q \times \Sigma \rightharpoonup Q$~--- частично определённая функция переходов.
\end{itemize}
\end{definition}

Известно, что любое регулярное выражение может быть выражено с помощью детерминированного конечного автомата без $\varepsilon$-переходов~\cite{hopcroft2001introduction}. Кроме того, конечный автомат $T = \langle \Sigma, Q, q_s, Q_f, \delta \rangle$ естественным образом может быть представлен в виде помеченного графа $\mathcal{G} = \langle V, E, L \rangle$, где $V = Q$, $L = \Sigma$, $E = \{(q_i, l, q_j) \mid \delta(q_i, l) = q_j\}$ и некоторые вершины помечены как начальное или конечные состояния. Таким образом, матрица смежности такого графового представления и, соответственно, её булева декомпозиция содержат в себе информацию о функции переходов $\delta$.

\begin{example}[Пример представления в виде графа конечного автомата для регулярного выражения $a \cdot (b)^*$] Вершину графа, соответствующую стартовому состоянию, будем помечать с помощью слова \textit{start}, а вершины, соответствующие конечным состояниям, будем помечать двойным кругом. В данном примере стартовому состоянию соответствует вершина 0, а конечному~--- вершина 1.
    $$
    \centering
    \begin{tikzpicture}[shorten >=1pt,auto]
       \node[state, initial] (q_0)                      {$0$};
       \node[state, accepting] (q_1) [right=of q_0] {$1$};
       \path[->]
        (q_0) edge  node {a} (q_1)
        (q_1) edge[loop above]  node {b} (q_1)
        ;
    \end{tikzpicture}
    $$
\end{example}

\begin{definition}[Пересечение конечных автоматов]\label{def:FAintersection}
Пусть даны два конечных автомата 
$T_1 = \langle \Sigma, Q^1, q_s^1, Q_f^1, \delta^1 \rangle$ и $T_2 = \langle \Sigma, Q^2, q_s^2, Q_f^2, \delta^2 \rangle$. Тогда \textit{пересечением} этих двух автоматов является новый конечный автомат $T = \langle \Sigma, Q, q_s, Q_f, \delta \rangle$ такой, что:
\begin{itemize}
    \item $Q = Q^1 \times Q^2$;
    \item $q_s = \langle q_s^1, q_s^2 \rangle$;
    \item $Q_f = Q_f^1 \times Q_f^2$;
    \item $\delta: Q \times \Sigma \rightharpoonup Q$;
    \item $\delta (\langle q_1, q_2 \rangle, s) = \langle q_1', q_2' \rangle$, если $\delta(q_1, s)=q_1'$ и $\delta(q_2, s)=q_2'$.
\end{itemize}
\end{definition}

Согласно~\cite{hopcroft2001introduction} конечный автомат $T$, являющийся пересечением конечных автоматов $T_1$ и $T_2$ распознаёт язык $L_1 \cap L_2$, где $L_1$~--- язык, распознаваемый автоматом $T_1$, а $L_2$~--- язык, распознаваемый автоматом $T_2$. Кроме того, построение пересечения двух конечных автоматов может быть проведено с использованием булевой декомпозиции матриц смежности графовых представлений этих автоматов.

\begin{definition}[Произведение Кронекера булевых декомпозиций матриц смежности]\label{def:FAkron}
Пусть дана полугруппа $\langle \{0, 1\}, \wedge \rangle$ и пусть $\mathcal{M}_1$ и $\mathcal{M}_2$~--- булевы декомпозиции матриц смежности графовых представлений конечных автоматов $T_1 = \langle \Sigma, Q^1, q_s^1, Q_f^1, \delta^1 \rangle$ и $T_2 = \langle \Sigma, Q^2, q_s^2, Q_f^2, \delta^2 \rangle$. Тогда в соответствии с заданной полугруппой \textit{произведение Кронекера булевых декомпозиций матриц смежности двух конечных автоматов} $\mathcal{M}_1 \times \mathcal{M}_2 = \{M^a_1 \times M^a_2 \mid a \in \Sigma\}$.
\end{definition}

Согласно~\cite{rivera2017euro} справедлива следующая теорема.

\begin{theorem}[Пересечение конечных автоматов и произведение Кронекера]\label{thm:FAintersection_and_kron}
 Пусть $T$~--- пересечение конечных автоматов $T_1$ и $T_2$. Пусть $\mathcal{M}$, $\mathcal{M}_1$ и $\mathcal{M}_2$~--- булевы декомпозиции матриц смежности графовых представлений конечных автоматов $T$, $T_1$ и $T_2$. Тогда $\mathcal{M} = \mathcal{M}_1 \times \mathcal{M}_2$.
\end{theorem}
 
Таким образом, функция переходов пересечения двух конечных автоматов может быть вычислена с использованием ряда произведений Кронекера над булевыми матрицами.

Другим важным классом формальных языков, обобщающим класс регулярных языков, являются контекстно-свободные (КС) языки, порождаемые грамматиками следующего вида.

\begin{definition}[Контекстно-свободная грамматика]
	\textit{Контекстно-свободная (КС) грамматика} $G$~--- это четвёрка $\langle \Sigma, N, P, S \rangle$, где 
	\begin{itemize}
		\item $\Sigma$ обозначает конечный алфавит терминальных символов, 
		\item $N$~--- алфавит нетерминальных символов, $\Sigma \cap N=\varnothing$, 
		\item $P$~--- конечное подмножество множества $N \times ( (\Sigma \cup N)^+ \cup \{\varepsilon\} )$,  
		\item $S$~--- стартовый символ грамматики, $S  \in N$. 
	\end{itemize}
\end{definition}

Для представления вывода цепочки в КС-грамматиках обычно используют деревья вывода.

\begin{definition}[Дерево вывода цепочки в КС-грамматике]
	\textit{Деревом вывода цепочки} $w \in \Sigma^*$ в КС-грамматике $G=\langle \Sigma, N, P, S \rangle$ называется упорядоченное корневое дерево со следующими свойствами. 
	\begin{itemize}
		\item Корень помечен $S$.
		
		\item Если его внутренний узел помечен $A \in N$ и $X_1, \ldots , X_k \in \Sigma \cup N$~--- перечисленные слева направо пометки всех сыновей этого узла, то правило $A \rightarrow X_1 \ldots X_k \in P$.
		
		\item Если его внутренний узел помечен $A \in N$ и $\varepsilon$~--- пометка единственного сына этого внутреннего узла, то правило $A \rightarrow \varepsilon \in P$.
		
		\item $w = a_1 \ldots a_m$, где $a_1, \ldots , a_m \in \Sigma \cup \{\varepsilon\} $ перечисленные слева направо пометки всех листьев этого дерева.
		
	\end{itemize}
\end{definition}

Часто, для алгоритмов, использующих КС-грамматики, важно, чтобы она находилась в некоторой нормальной форме. Примером является нормальная форма следующего вида, которая будет в дальнейшем использоваться в данной работе.

\begin{definition}[Ослабленная нормальная форма Хомского КС-грамматики]
	Будем говорить, что КС-грамматика $G = \langle \Sigma, N, P, S \rangle$ находится в \textit{ослабленной нормальной форме Хомского}, если множество $P$ содержит только правила следующих двух видов:
	\begin{itemize}
		\item $A \rightarrow a$, где $A \in N$ и $a \in (\Sigma \cup \{\varepsilon\})$;
		\item $A \rightarrow B C$, где $A, B, C \in N$.
	\end{itemize}
\end{definition}

Стоит отметить, что описанная нормальная форма КС-грамматики отличается от классической нормальной формы Хомского~\cite{chomsky1959certain}, в которой не допускаются правила вида $A \rightarrow \varepsilon$ для всех нетерминалов $A$, кроме стартового $S$. Однако это ограничение не является существенным для использования в данной работе, поэтому будет использоваться нормальная форма более общего вида.

В то время, как регулярное выражение может быть записано в виде конечного автомата, любая КС-грамматика может быть выражена с помощью рекурсивного автомата~\cite{alur2005analysis}.

\begin{definition}[Рекурсивный автомат]
\textit{Рекурсивный автомат} $R$~--- четвёрка $\langle \Sigma, B, m, \{C_i\}_{i \in B} \rangle$:
\begin{itemize}
    \item $\Sigma$~--- конечный алфавит входных символов,
    \item $B$~--- конечное множество меток автоматов,
    \item $m \in B$~--- метка стартового автомата,
    \item Множество автоматов $C_i =  \langle \Sigma \cup B, Q_i, q_s^i, Q^i_f, \delta_i \rangle$:
\begin{itemize}
    \item $\Sigma \cup B$~--- множество допустимых символов переходов автомата, где $\Sigma \cap B = \varnothing$;
    \item $Q_i$~--- конечное множество состояний автомата, где $Q_i \cap Q_j = \varnothing$, $\forall i \neq j$;
    \item $q_s^i$~--- начальное состояние для автомата $C_i$;
    \item $Q_f^i \subseteq Q_i$~--- множество конечных состояний,
    \item $\delta_i: Q_i \times (\Sigma \cup B) \to Q_i$~--- функция переходов.
\end{itemize}
\end{itemize}
\end{definition}

Рекурсивные автоматы в свою очередь могут быть представлены в виде графов или матриц смежности этих графов~\cite{alur2005analysis}.

\begin{example}[Пример представления в виде графа рекурсивного автомата для КС-грамматики, порождающей КС-язык $\mathcal{L} = \{a^nb^n \mid n \geq 1\}$] Пусть дана КС-грамматика $G$, правила вывода которой имеют следующий вид.
	\[
	\begin{array}{rccl}
	0: & S & \rightarrow & \text{\emph{a}} \ S \ \text{\emph{b}} \\
	1: & S & \rightarrow & \text{\emph{a}} \ \text{\emph{b}} \\
	
	\end{array}
	\]
	
	Тогда рекурсивный автомат $R = \langle \{a, b\}, \{S\}, S, \{C_S\}\rangle$ для КС-грамматики $G$ представлен на~\cref{example:automata}. Метки автоматов будем указывать в левом верхнем углу. В данном примере рекурсивный автомат содержит только один конечный автомат $C_S$ с меткой $S$, соответствующей стартовому нетерминалу грамматики.
	
\begin{figure}[h]
    \begin{tikzpicture}[shorten >=1pt,auto]
        \node[state, initial] (q_0)   {$q_S^0$};
        \node[state] (q_1) [right=of q_0] {$q_S^1$};
        \node[state] (q_2) [right=of q_1] {$q_S^2$};
        \node[state, accepting] (q_3) [right=of q_2] {$q_S^3$};
        \path[->]
            (q_0) edge node {a} (q_1)
            (q_1) edge node {S} (q_2)
            (q_2) edge node {b} (q_3)
            (q_1) edge [bend left, above]  node {b} (q_3);
        \node (box) [draw=black, fit= (q_0) (q_1) (q_2) (q_3), inner sep=0.75cm, label=Конечный автомат $C_S$ для нетерминала $S$] {};
        \node[draw=black, anchor=north west] at (box.north west) {$S$};
    \end{tikzpicture}
    \centering
    \caption{Рекурсивный автомат $R$ для КС-грамматики $G$}
    \label{example:automata}
\end{figure}

\end{example}

Таким образом, любой КС-язык может быть описан с использованием таких объектов линейной алгебры, как матрицы.

\section{Постановка задач поиска путей в графе с КС-ограничениями}\label{sec:ch1/sec4}
Для исследования применимости методов линейной алгебры к задачам поиска путей в графе с заданными КС-ограничениями необходимо сначала ввести формальную постановку этих задач. В данном разделе вводится формальная постановка для трёх основных типов таких задач.

В этих задачах на вход подаётся помеченный граф $\mathcal{G} = \langle V, E, L \rangle$ и КС-язык $\mathcal{L}$. Выходом является информация о путях $\pi$ входного графа $\mathcal{G}$ таких, что $\lambda(\pi) \in \mathcal{L}$. Вид запрашиваемой информации зависит от типа решаемой задачи. Выделяют три типичных задачи поиска путей в графе:

\begin{itemize}
\item задача достижимости,
\item поиск одного пути,
\item поиск всех путей.
\end{itemize}

 Ниже представлена формальная постановка для каждой из этих задач.

\textbf{Задача достижимости.} Пусть даны помеченный граф $\mathcal{G} = \langle V, E, L \rangle$ и КС-язык $\mathcal{L}$. Необходимо найти все пары вершин $i, j \in V$, между которыми существует хотя бы один путь $\pi$ такой, что $\lambda(\pi) \in \mathcal{L}$. То есть необходимо построить следующее множество: $$\{(i, j) \mid i, j \in V, \exists i \pi j, \lambda(\pi) \in \mathcal{L}\}.$$

\textbf{Поиск одного пути.} Пусть даны помеченный граф $\mathcal{G} = \langle V, E, L \rangle$ и КС-язык $\mathcal{L}$. Необходимо для всех пар вершин $i, j \in V$ предоставить один путь $\pi$ такой, что $\lambda(\pi) \in \mathcal{L}$, если такой путь существует.

\textbf{Поиск всех путей.} Пусть даны помеченный граф $\mathcal{G} = \langle V, E, L \rangle$ и КС-язык $\mathcal{L}$. Необходимо для всех пар вершин $i, j \in V$ предоставить любое конечное заданное количество путей $\pi$ таких, что $\lambda(\pi) \in \mathcal{L}$, если существует такое количество путей.

Проиллюстрируем постановки данных задач на небольшом графе с использованием классического КС-языка $\mathcal{L} = \{a^nb^n \mid n \geq 1\}$, который не может быть описан с помощью регулярного выражения и который используется для нахождения вершин в графе, находящихся на одном уровне иерархии~\cite{abiteboul1995foundations}.

Пусть имеется графовая база данных или любой другой объект, который может быть представлен в виде графа. Тогда КС-язык $\mathcal{L}$ может быть использован для выявления схожих вершин в этом графе. Для графовых баз данных такая задача нацелена на поиск всех вершин, находящихся на одинаковом уровне иерархии. Например, рассмотрим небольшой граф с двумя циклами, представленный на~\cref{fig:example_graph}. Один из циклов имеет три дуги с метками $a$, другой~--- две дуги с метками $b$. Оба цикла имеют общую вершину с номером $0$.

Пусть результатом решения задачи достижимости с заданными КС-ограничениями является множество пар вершин $R$. Тогда, например, пара вершин $(0, 0) \in R$, так как существует путь из вершины $0$ в вершину $0$, образующий строку \mbox{$w = aaaaaabbbbbb = a^6b^6 \in \mathcal{L}$}.

Результат решения задачи поиска одного пути в графе с заданными КС-ограничениями также содержит по одному примеру пути искомого вида между каждой парой вершин $(i,  j) \in R$. Например, если мы хотим предоставить доказательство существования пути искомого вида между вершинами $0$ и $0$, то в результат может быть добавлен путь $\pi = (0, a, 1), (1, a, 2), (2, a, 0), (0, a, 1), (1, a, 2), (2, a, 0), (0, b, 3), (3, b, 0), (0, b, 3), (3, b, 0),\\(0, b, 3), (3, b, 0)$ для пары $(0, 0) \in R$, где $\lambda(\pi) = a^6b^6 \in \mathcal{L}$.

Результат решения задачи поиска всех путей в графе с заданными КС-ограничениями должен содержать все пути искомого вида между каждой парой вершин $(i, j) \in R$. Например, для пары вершин $(0, 0) \in R$ должны быть представлены пути $0\pi_k 0$, где $\lambda(\pi_k) = a^{6k}b^{6k}$ для всех $k \geq 1$. Множество всех путей может быть бесконечным, поэтому необходимо либо представить данное множество в виде некоторой конечной структуры, либо иметь алгоритм генерации $k$ путей для каждой пары вершин и для любого $k \geq 1$.

\section{Обзор алгоритмов поиска путей в графе с КС-ограничениями}\label{sec:ch1/sec5}
В данном разделе рассмотрены основные существующие алгоритмы поиска путей в графе с  КС-ограничениями. Все рассматриваемые алгоритмы требуют выразить заданные КС-ограничения в виде КС-грамматики, поэтому будем считать, что на вход алгоритмы получают помеченный граф $\mathcal{G} = \langle V, E, L \rangle$ и КС-грамматику $G = \langle \Sigma, N, P, S \rangle$.

\textbf{Алгоритмы для произвольных графов с произвольными КС-ограничениями.}  Существует ряд алгоритмов для задачи достижимости с заданными КС-ограничениями, основанных на различных алгоритмах синтаксического анализа. Так, например, Джелле Хеллингс в работе~\cite{hellings2014conjunctive} предложил алгоритм с временной сложностью $O(|N||E| + (|N||V|)^3)$, основанный на алгоритме синтаксического анализа CYK. Кроме того, в работе~\cite{zhang2016context} была получена реализация этого алгоритма для анализа RDF данных. Также существуют работы~\cite{medeiros2018efficient} и \cite{santos2018bottom}, в которых для решения задачи достижимости с заданными КС-ограничениями использовались LL и LR алгоритмы синтаксического анализа~\cite{aho1973theory}. Для алгоритма в работе~\cite{medeiros2018efficient}, основанного на LL алгоритме, также известна временная сложность в худшем случае: $O(|V|^3 |P|)$. С практической точки зрения, в работе~\cite{kuijpers2019experimental} было проведено исследование, в котором сравнивались реализации основных существующих алгоритмов для задачи достижимости с заданными КС-ограничениями. Это исследование показало, что существующие решения недостаточно производительны для использования на практике.

Кроме того, Джелле Хеллингс в работе~\cite{hellings2020explaining} предложил алгоритм поиска одного пути в графе с заданными КС-ограничениями. Для этого строится так называемая <<аннотированная>> грамматика, которая является конечной структурой, содержащей в себе информацию обо всех искомых путях графа. Далее используются результаты из теории формальных языков для нахождения кратчайшей строки, порождаемой КС-грамматикой. Для каждой пары вершин такие строки используются для нахождения кратчайшего пути между ними, удовлетворяющего заданным КС-ограничениям. Нахождение таких путей решает поставленную задачу поиска одного пути. Временная сложность предложенного алгоритма~--- $O(|N||V|^2(|N||V|^2log(|N||V|^2) + |P|(|V|^3 + |E|)) + L)$, где $L$~--- сумма длин найденных кратчайших путей в графе.

Также существует ряд алгоритмов~\cite{grigorev2017context, verbitskaia2015relaxed, verbitskaia2018parser} поиска всех путей в графе с заданными КС-ограничениями, основанных на алгоритмах синтаксического анализа GLL~\cite{scott2010gll} и GLR~\cite{scott2007brnglr}. В предложенных алгоритмах для хранения информации об искомых путях используется конечное представления леса разбора SPPF~\cite{tomita1984lr}. В дальнейшем эта структура используется для генерации любого количества путей, удовлетворяющих заданным КС-ограничениям. Кроме того, для алгоритма, предложенного в работе~\cite{grigorev2017context} известна временная сложность построения такого леса разбора SPPF в худшем случае: $O(|V|^3 \max_{v \in V} deg^+(v))$, где $deg^+(v)$~--- количество исходящих дуг из вершины $v$. Также существует работа~\cite{hellings2015querying}, в которой Хеллингс аналогично задаче поиска одного пути с заданными КС-ограничениями строит <<аннотированную>> грамматику. Однако построенная грамматика уже содержит всю необходимую информацию обо всех путях в графе, удовлетворяющих заданным КС-ограничениям. Затем эта грамматика может быть использована для генерации искомых путей в графе. Временная сложность построения такой грамматики~--- $O(|N||E| + (|N||V|)^3)$, однако сложность генерации искомых строк пока что мало исследована.

\textbf{Алгоритмы для  частных случаев задачи поиска путей в графе.} Кроме того, в ряде работ~\cite{horwitz1995demand,reps1998program,reps1995precise} было показано, как можно проводить статический анализ программ, решая задачу достижимости в графе с заданными КС-ограничениями. Затем эта задача была использована для формулировки различных проблем статического анализа программ таких, как анализ указателей и поиск псевдонимов~\cite{chatterjee2017optimal,dietrich2015giga,lu2013incremental, sridharan2005demand,yan2011demand,zheng2008demand}, анализ зависимостей в данных~\cite{chatterjee2017optimal}, анализ вывода типов~\cite{milanova2014cfl}, анализ потока данных с использованием системы типов~\cite{rehof2001type} и т.д. В этих алгоритмах графы, построенные из программ, анализируются с использованием определенного КС-языка в качестве ограничений на пути. Примером такого языка является язык Дика~\cite{reps1998program} (язык правильных скобочных последовательностей). Поэтому предложенные алгоритмы предназначены для решения частного случая задачи достижимости с заданными КС-ограничениями.

Другим примером алгоритма для решения частного случая задачи достижимости с заданными КС-ограничениями является алгоритм, предложенный Филипом Брэдфордом в работе~\cite{bradford2017efficient} и использующий операции над матрицами. Этот алгоритм имеет временную сложность в худшем случае $O(|V|^{\omega} log^3 |V|)$, где $\omega$~--- наилучший показатель степени для оценки временной сложности умножения двух матриц размера $n \times n$. Стоит отметить, что алгоритм был также сформулирован с использованием методов линейной алгебры, однако он предназначен только для частного случая КС-ограничений, выраженных с помощью языка Дика с одним типом скобок.

Кроме того, в работе~\cite{miao2019understanding} был предложен алгоритм, решающий задачу достижимости в графе с заданными КС-ограничениями, который был использован для извлечения из графа информации, детально описывающей получение того или иного результата анализа графа. Для решения такой задачи использовался определённый КС-язык, который не может быть описан регулярными выражениями и является языком некоторых палиндромов~\cite{hopcroft2001introduction}. Для такого КС-языка и для задачи достижимости в графе с заданными КС-ограничениями с фиксированным набором конечных вершин $V_{dst}$ был предложен алгоритм с линейной сложностью, если рассматривать $|V_{dst}|$ как константу.

\section{Использование методов линейной алгебры для анализа графов}\label{sec:ch1/sec6}
В данном разделе представлены основные идеи использования методов линейной алгебры для решения задач анализа графов, а также подход к решению задач поиска путей в графах, основанный на этих идеях.

\subsection{Основные идеи}
В последнее время многие задачи анализа графов решают с использованием методов линейной алгебры, что, в свою очередь, позволяет использовать имеющиеся средства распараллеливания, например, для умножения матриц, добиваясь эффективной реализации данных алгоритмов на GPU. При этом, как правило, берётся готовый алгоритм, решающий нужную задачу, и далее этот алгоритм переводится на язык линейной алгебры. Для выполнения этого <<перевода>> можно выделить следующие шаги. 

\begin{enumerate}
    \item Представление основных сущностей алгоритма~--- графа, множества рассматриваемых на текущей итерации вершин и пр.~--- в виде объектов линейной алгебры, т.е. матриц и векторов. 
    \item Выбор процедуры обхода графа в виде набора операций над объектами линейной алгебры.
    \item Реализация семантической части алгоритма в виде модификации выбранных операций над объектами линейной алгебры. При этом используются дополнительные алгебраические структуры (полугруппы, моноиды, полукольца и пр), над которыми строятся объекты линейной алгебры.
\end{enumerate}

Ключевым является выбор объектов для представления информации о графах. Например, сам граф можно описать матрицей смежности, а строка/столбец этой матрицы описывает  исходящие/входящие дуги вершины, задаваемой номером строки/столбца. 

После выбора подходящих объектов важно определить процедуру обхода графа. По сути, этот процесс заключается в рассмотрении всех необходимых путей, и различные методы обхода графов предлагают различный порядок рассмотрения вершин, дуг и путей графа, иными словами имеют различные шаблоны доступа к данным. При удачном выборе процедуры обхода графа и, соответственно, шаблона доступа к данным, в линейной алгебре могут найтись операции над выбранными объектами, имеющие схожий или совпадающий шаблон. Тогда сам процесс обхода графа и рассмотрения различных путей может быть проведен с помощью этих операций.

Однако, если мы решаем не просто задачу о достижимости одной вершины из другой, то кроме обхода графа необходимо ещё выполнить определённые действия при обходе. Например, вычисление некоторой информации о рассматриваемых путях или проверку путей на соответствие некоторым ограничениям в зависимости от поставленной задачи (поиск кратчайших путей, простых путей, поиск путей с заданными КС-ограничениями и т.д.). Эти действия могут быть реализованы дополнительно, однако некоторые операции линейной алгебры могут быть модифицированы с целью выполнения всех необходимых для решения поставленной задачи действий. Поэтому целесообразно исследовать возможность таких модификации для операций, которые соответствуют выбранной процедуре обхода графа.

Например, на листинге~\ref{lst:bford1} представлен псевдокод алгоритма Беллмана-Форда~\cite{bellman1958routing,ford2015flows} поиска кратчайших расстояний во взвешенном графе без кратных дуг с множеством вершин $V$, множеством дуг $E$, функции весов $W$ и выделенной стартовой вершиной $s \in V$. При условии отсутствия отрицательных циклов во входном графе данный алгоритм возвращает кратчайшие расстояния от стартовой вершины до всех остальных.

Согласно~\cite{kepner2011graph} этот алгоритм может быть переведён на язык линейной алгебры следующим образом. Граф был представлен в виде матрицы смежности, а для хранения расстояний от стартовой вершины $s$ до всех остальных вершин использовать вектор $d$. Заметим, что из-за отсутствия кратных дуг в графе элементами матрицы смежности являются множества, состоящие не более чем из одного вещественного числа. Поэтому для удобства преобразуем матрицу смежности и будем рассматривать матрицу $A$ с элементами~--- вещественными числами или специальными элементами $\infty$, обозначающими отсутствие дуги между двумя вершинами. Процедура обхода графа задаётся с помощью умножения вектора на матрицу, как это представлено в листинге~\ref{lst:bford2}. В представленном обходе графа весь процесс поиска путей сводится к вычислению ряда таких умножений $d \cdot A$ в строке 5. Однако для решения задачи поиска кратчайших путей необходимо задать дополнительные действия в процессе обхода графа. Для этого операция умножения вектора на матрицу  переопределяется с использованием такой алгебраической структуры, как полукольцо  $\langle \mathbb{R} \cup \{\infty\}, min, +, \infty, 0 \rangle$, которое позволяет вместо привычной операции сложения элементов матриц и векторов использовать операцию взятия минимума, а вместо операции умножения этих элементов использовать операцию сложения вещественных чисел. При использовании этого полукольца операция $min$ позволяет из нескольких альтернативных путей между двумя вершинами выбирать тот, который имеет меньшую длину, а операция $+$ позволяет вычислять длины рассматриваемых путей, как суммы длин их подпутей.

\begin{algorithm}
  \floatname{algorithm}{Листинг}
\begin{algorithmic}[1]
\caption{Алгоритм Беллмана-Форда поиска кратчайших расстояний во взвешенном графе}
\label{lst:bford1}
\Function{Bellman-Ford}{$V$~--- множество вершин, $E$~--- множество дуг, $W$~--- функция весов, $s$~--- стартовая вершина}
    \State{$d \gets$ список кратчайших расстояний от вершины $s$ до любой другой}
    %\State{$\pi \gets$ список, который будет использоваться для хранения предыдущих вершин в кратчайших путях}
    \ForAll{$v \in V$}
         \State {$d(v) \gets \infty$}
     %    \State {$\pi(v) \gets$ NIL}
    \EndFor
    \State{$d(s) \gets 0$}
    \Comment{\text{Расстояние до стартовой вершины}}
    \For{$k = 1$ \textbf{to} $N - 1$ }
        \If {$d(v) > d(u) + W(u, v)$}
            \State {$d(v) \gets d(u) + W(u, v)$}
      %      \State {$\pi(v) \gets u$}
        \EndIf
    \EndFor
    \ForAll{$(u, v) \in E$}
         \If {$d(v) > d(u) + W(u, v)$}
            \State \Return \text{“В графе существует отрицательный цикл.”}
        \EndIf
    \EndFor
    \State \Return $d$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \floatname{algorithm}{Листинг}
\begin{algorithmic}[1]
\caption{Процедура обхода графа для алгоритма Беллмана-Форда с использованием умножения вектора на матрицу}
\label{lst:bford2}
\Function{Algebraic-Bellman-Ford}{$A$~--- матрица смежности графа, $s$~--- стартовая вершина}
    \State{$d \gets$ вектор кратчайших расстояний от вершины $s$ до любой другой со всеми элементами равными $\infty$}
    \State{$d(s) \gets 0$}
    \Comment{\text{Расстояние до стартовой вершины}}
    \For{$k = 1$ \textbf{to} $N - 1$ }
        \State{$d \gets d \cdot A$}
        \Comment{\text{Умножение вектора на матрицу}}
    \EndFor
    \If {$d \neq d \cdot A$}
        \State \Return \text{“В графе существует отрицательный цикл.”}
    \EndIf
    \State \Return $d$
\EndFunction
\end{algorithmic}
\end{algorithm}

Таким образом,  удачный выбор объектов линейной алгебры, процедуры обхода графа и дополнительных действий в процессе этого обхода позволяют строить алгоритмы для решения задач анализа графов с помощью операций  линейной алгебры.  

\subsection{Подход Algebraic Path Problem} Представленные в предыдущем разделе идеи решения задач анализа ориентированных помеченных графов легли в основу подхода, называемого \textit{Algebraic Path Problem}~\cite{rote1990path}. Суть этого подхода заключается в построении полукольца для решения задачи анализа графа, и это полукольцо  позволяет использовать алгебраические операции для вычисления необходимых свойств путей в графе. Более формально, пусть дан граф $\mathcal{G} = \langle V, E, L \rangle$. Для этого графа предлагается построить такое полукольцо $\langle \mathcal{S}, \oplus, \otimes, \mathbb{0}, \mathbb{1} \rangle$, в котором  $L \subseteq \mathcal{S}$ и которое позволяет свести изначальную задачу анализа графа к вычислению для всех $i, j \in V$ значений $d_{i,j} = \bigoplus \{\lambda_{algebraic}(\pi) \mid \pi~\text{--- путь из вершины $i$ в вершину $j$}\}$. При этом для пути $\pi = (v_0, l_0, v_1), (v_1, l_1, v_2), \ldots, (v_{n - 1}, l_n, v_n)$ выполнено $\lambda_{algebraic}(\pi) = (\ldots (l_0 \otimes l_1) \otimes l_2) \ldots ) \otimes l_n.$

Такие значения могут быть вычислены с использованием метода Гаусса~\cite{rote1985systolic, tarjan1981fast, tarjan1981unified}, на основе алгоритмов анализа графов Флойда и Уоршалла~\cite{fletcher1980more, floyd1962algorithm, warshall1962theorem}, или с использованием умножения матриц~\cite{aho1974design, cormen2009introduction}. Временная сложность алгоритмов, использующих умножение матриц, составляет $\Theta(|V|^3 log(|V|) (T_{\otimes} + T_{\oplus}))$, а временная сложность всех остальных упомянутых алгоритмов~--- $O(|V|^3(T_{\otimes} + T_{\oplus}) + |V|^2 T_*)$. Здесь $T_{\otimes}$, $T_{\oplus}$ и $T_*$~--- временная сложность вычисления операций $s_1 \otimes s_2$, $s_1 \oplus s_2$ и $s^*$ для всех $s, s_1, s_2 \in \mathcal{S}$. Кроме того, существуют некоторые алгоритмы, специализированные для решения частных случаев этой задачи. Например, рассмотренный алгоритм на листинге~\ref{lst:bford2} является результатом применения подхода \textit{Algebraic Path Problem}, в котором вычисление значений $d_{i,j}$ производятся только для фиксированной начальной вершины $i$.

%Следует отметить, что требование ассоциативности операции $\otimes$ и дистрибутивности $\otimes$ относительно $\oplus$ исключает возможность применения данного подхода для многих задача анализа графов, например, для задачи поиска кратчайшего пути с дополнительными модификаторами~\cite{gondran1984graphs} или для задачи подсчёта количества путей~\cite{baras2010path}. Не смотря на то, что для некоторых задач анализа графов удалось обойти данное ограничение~\cite{lengauer1991unstructured, tarjan1981unified}, для задач поиска путей в графе заданными КС-ограничениями до сих пор таких исследований не проводилось.

Лесли Вэлиант показал, как синтаксический анализ КС-языков может быть проведён с использованием операций над матрицами, модифицированных алгебраическими структурами, схожими с полукольцами, однако без требования ассоциативности операции умножения~\cite{valiant1975general}. Поэтому, возможно удастся использовать идеи, схожие с идеями подхода \textit{Algebraic Path Problem}, для решения задач поиска путей в графе с заданными КС-ограничениями.


\section{Основные библиотеки линейной алгебры}\label{sec:ch1/sec7}
%Стандарт GraphBLAS. Графы представлены в виде матриц смежности. Используются практические результаты для вычисления операций над разреженными матрицами.
 Одной из причин использования методов линейной алгебры в задачах анализа графов является наличие большого количества высокопроизводительных библиотек линейной алгебры, позволяющих получать хорошие практические результаты для этих задач. Стоит отметить такие библиотеки, как cuBLAS, cuSPARSE, cuBool, m4ri, Scipy и CUSP$\footnote{Библиотека линейной алгебры CUSP для вычисления операций над разреженными матрицами и решения разреженных систем линейных уравнений на GPU: http://cusplibrary.github.io/ (дата обращения: 14.01.2022).}$.
 
 При построении алгоритма анализа графов с использованием методов линейной алгебры требуется, во-первых, создать необходимые объекты линейной алгебры (матрицы смежности, вектора) и, во-вторых, использовать библиотечные функции для эффективного вычисления необходимых операций над созданными объектами. Тип данных, используемых в матрицах и векторах зависит от поставленной задачи анализа графов. Часто, для решения задачи достаточно использовать булевы матрицы и вектора (например, для решения задачи достижимости) или такие объекты с более сложным типом данных могут быть выражены с помощью набора булевых матриц и векторов. Например, матрица с конечными множествами в качестве элементов может быть выражена с помощью её булевой декомпозиции. Поэтому наличие в выбранной библиотеке линейной алгебры эффективной реализации операций над булевыми матрицами и векторами крайне важно для многих задач анализа графов. Однако, если поставленную задачу не удаётся свести к вычислению операций над набором булевых матриц и векторов, то необходимо использовать эти объекты линейной алгебры с пользовательским типом данных, а в используемых библиотеках должна быть возможность вычислять операции над ними. Такая ситуация возникает при решении более сложных задач анализа графов, например, при поиске всех путей в графе с некоторыми ограничениями.
 
 Для получения высокопроизводительных реализаций при выборе библиотеки линейной алгебры необходимо учитывать особенности используемых данных и выбранных операций. Например, основные операции над матрицами и векторами могут быть эффективно вычислены с использованием параллельных вычислительных систем (на CPU, GPU, с использованием распределённых вычислений и т.д.). Кроме того, данные на практике разрежены, поэтому важно иметь возможность вычислять операции над разреженными матрицами и векторами в выбранной библиотеке.
 
 Таким образом, можно выделить следующие критерии, которые могут быть использованы при выборе библиотеки линейной алгебры для получения высокопроизводительной реализации алгоритма анализа графов:
 
 \begin{itemize}
     \item операции над булевыми матрицами/векторами,
     \item возможность использования пользовательского типа данных и операций над ними,
     \item использование параллельных вычислений,
     \item работа с разреженными матрицами/векторами.
 \end{itemize}
 
 Все перечисленные критерии были учтены при создании Айдыном Булуком, Бенджамином Броком (Benjamin Brock), Тимоти Мэттсоном (Timothy Mattson) и другими стандарта GraphBLAS~\cite{graphblas}, определяющего базовые <<строительные блоки>> для алгоритмов анализа графов в терминах линейной алгебры. Этот стандарт разрабатывался с 2013 года и был впервые опубликован в мае 2017 года. Для реализации выбранного алгоритма анализа графов можно воспользоваться любой из существующих реализаций стандарта GraphBLAS (SuiteSparse:GraphBLAS~\cite{suitesparse1,suitesparse2,suitesparse3}, IBM GraphBLAS$\footnote{IBM GraphBLAS~--- реализация стандарта GraphBLAS на языке \texttt{C++}: https://github.com/IBM/ibmgraphblas (дата обращения: 14.01.2022).}$, GBTL$\footnote{GBTL~--- ещё одна реализация стандарта GraphBLAS на языке \texttt{C++}: https://github.com/cmu-sei/gbtl (дата обращения: 14.01.2022).}$ (GraphBLAS Template Library), GraphBLAST$\footnote{GraphBLAST~--- реализация стандарта GraphBLAS на GPU с использованием платформы CUDA: https://github.com/gunrock/graphblast (дата обращения: 14.01.2022).}$~\cite{graphblast1}). Однако наиболее проработанными и оптимизированными являются реализации SuiteSparse:GraphBLAS на CPU и GraphBLAST~--- на GPU.
 
В стандарте GraphBLAS используются разреженные форматы для хранения матриц (СSR, CSC, COO)~\cite{graphblas}, а также алгебраические структуры, с помощью которых можно модифицировать операции над матрицами и векторами. При применении подхода \textit{Algebraic Path Problem} необходимо использовать полукольца и стандарт GraphBLAS предоставляет такую возможность. Однако стоит отметить, что в стандарте GraphBLAS на используемые алгебраические структуры накладываются более слабые требования, что позволяет использовать структуры более общего вида, чем полукольца. Например, в рамках стандарта возможно создать алгебраическую структуру и с её помощью определить операцию умножения матриц с разными типами данных, что невозможно сделать используя полукольца. Также в стандарте GraphBLAS имеется множество встроенных бинарных операций, из которых могут быть составлены различные алгебраические структуры. Например, может быть составлено полукольцо $\langle \mathbb{R} \cup \{\infty\}, min, +, \infty, 0 \rangle$, которое было использовано для алгоритма Беллмана-Форда в листинге~\ref{lst:bford2}. Однако в том случае, если для выбранного алгоритма анализа графов не подходит ни одна из встроенных в стандарт алгебраических структур, то также существует возможность создавать собственные (пользовательские) структуры, описывая тип данных, бинарные операции, а также соответствующие нейтральные элементы. %Всё это делает использование реализаций стандарта GraphBLAS при реализации алгоритмов анализа графов удобным, а код реализации~--- компактным.

Характеристики всех перечисленных библиотек линейной алгебры в соответствии с выбранными критериями представлены в~\cref{tab:LAlibraries}.


\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{Характеристики существующих библиотек линейной алгебры}\label{tab:LAlibraries}%
        \begin{tabular}{| p{5.1cm} || p{2.2cm} | p{3cm} | p{2.2cm} | p{2.2cm}l |}
            \hline
            \hline
            Библиотека   & \centering Булевый тип данных & \centering Пользователь-\\ ский тип данных & \centering  Параллель-\\ ные вычисления & \centering  Разрежен-\\ ные матрицы/ вектора &\\
            \hline
            cuBLAS & \centering	- & \centering -	 & \centering GPU	 & \centering -	 & \\
            cuSPARSE & \centering -	 & \centering -	 & \centering GPU	 & \centering +	 & \\
            cuBool & \centering	 + & \centering	- & \centering GPU	 & \centering +	 & \\
            CUSP & \centering	 + & \centering	+ & \centering GPU	 & \centering +	 & \\
            m4ri & \centering +	 & \centering -	 & \centering CPU	 & \centering -	 & \\
            Scipy & \centering +	& \centering -	 & \centering -	 & \centering +	 & \\
            SuiteSparse:GraphBLAS & \centering +& \centering +	 & \centering CPU	 & \centering	+ & \\
            IBM GraphBLAS & \centering +	 & \centering +	 & \centering CPU	 & \centering +	 & \\
            GBTL & \centering + & \centering -	 & \centering	CPU & \centering +	 & \\
            GraphBLAST & \centering +	 & \centering -	 & \centering GPU	 & \centering +	 & \\
            \hline
            \hline
        \end{tabular}
    \end{threeparttable}
\end{table}



Таким образом, для получения высокопроизводительных реализаций алгоритмов, предлагаемых в данной диссертации, на основе параллельных вычислений на CPU и с возможностью использовать пользовательские типы данных целесообразно использовать реализацию SuiteSparse:GraphBLAS или реализацию IBM GraphBLAS стандарта GraphBLAS. Однако в данной работе сделан выбор в пользу SuiteSparse:GraphBLAS, так как эта реализация является наиболее стабильной и оптимизированной. Для вычисления операций над разреженными булевыми матрицами и векторами на GPU рекомендуется использовать библиотеку cuBool, GraphBLAST или CUSP.


%Операции над матрицами и соответсвующие им трансформации графов. Транспонирование, поэлементное сложение/умножение, обычное умножение?

%Таблица стандартных полуколец в GraphBLAS?

%Таблица классических алгоритмов на графах с классической и матричными сложностями?

%Графовая база данных RedisGraph?
%RedisGraph~--- графовая база данных. Разреженные матрицы, их формат. Выразительность языка запросов.

%Набор данных CFPQ\_data?
%Созданный датасет. Описать какие графы RDF и запросы к ним. Таблица.

\section{Выводы}\label{sec:ch1/sec8}
На основе проведённого обзора можно сделать следующие выводы.
\begin{itemize}
	\item Проблема поиска путей в графе с заданными КС-ограничениями является актуальной в различных областях~--- в  графовых базах данных, биоинформатике, при статическом анализе программ и пр.
	
	\item Использование методов линейной алгебры для решения задач анализа графов является перспективным и позволяет существенно улучшить их производительность.

	\item На сегодняшний день не проводилось исследований о применении методов линейной алгебры для задач поиска путей в графе с заданными КС-ограничениями.
\end{itemize}

Выполненный обзор также позволяет выявить следующие подходы, технологии и средства, которые целесообразно использовать для решения задач поиска путей в графе с заданными КС-ограничениями.

\begin{itemize}
    \item Для использования методов линейной алгебры можно использовать идеи подхода \textit{Algebraic Path Problem}, однако необходимо перейти от полуколец к более общим алгебраическим структурам.
    \item Для задач поиска путей в графах с заданными КС-ограничениями существует возможность использовать представления в виде объектов линейной алгебры не только для графов, но и для КС-ограничений.
    \item При реализации алгоритмов поиска путей в графах необходимо использовать параллельные вычисления и разреженные форматы для хранения матриц.
	\item Целесообразно использовать стандарт GraphBLAS, позволяющий определять пользовательские типы данных для матриц и векторов, а также получать высокопроизводительные реализации алгоритмов анализа графов, с использованием операций над матрицами и векторами.
	\item Для использования параллельных вычислений на CPU можно использовать реализацию SuiteSparse:GraphBLAS стандарта GraphBLAS, а на GPU~--- библиотеки линейной алгебры cuBool, GraphBLAST и CUSP.
\end{itemize}


\FloatBarrier
