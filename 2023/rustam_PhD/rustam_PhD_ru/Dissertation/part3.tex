\chapter{Алгоритм поиска путей в графе с заданными КС-ограничениями с использованием операций умножения матриц}\label{ch:ch3}
В данной главе изложен алгоритм, полученный в результате применения подхода из предыдущей главы для решения задачи достижимости, поиска одного и поиска всех путей в графе с заданными КС-ограничениями с использованием операций умножения матриц. Также сформулированы и доказаны утверждения о корректности и временной сложности полученного алгоритма. Кроме того, приведены детали реализаций алгоритма, а также его работа продемонстрирована на примере.
\section{Построение алгоритма}\label{sec:ch3/sect1}
В данном разделе изложен процесс построения алгоритма поиска путей в графе с заданными КС-ограничениями с использованием операций умножения матриц.

Пусть дан входной помеченный граф $\mathcal{G} = \langle V, E, L\rangle$ и входной КС-язык в качестве ограничений на пути в нём. Сперва необходимо выбрать объекты линейной алгебры для представления информации о графе. Применимость таких объектов линейной алгебры, как матрицы в задачах анализа графов давно известна. Поэтому для представления входного графа будем использовать его матрицу смежности, в ячейках $(i, j)$ которой будет содержаться информация о дугах между вершиной $i$ и вершиной $j$. Входной КС-язык будем описывать КС-грамматикой $G = \langle \Sigma, N, P, S \rangle$ в ослабленной нормальной форме Хомского, которая, как мы увидим, будет удобна для дальнейшего построения алгебраических структур с операциями, учитывающими заданные КС-ограничения в процессе поиска путей в графе. Затем матрицу смежности необходимо инициализировать, включив в неё информацию о заданных ограничениях. Для описания связи найденных путей в графе с заданными КС-ограничениями будут использоваться нетерминальные символы грамматики $G$. Таким образом, в процессе работы предлагаемый алгоритм для всех рассматриваемых путей $\pi$ будет выяснять из каких нетерминалов $A$ выводится строка $\lambda(\pi)$. Поэтому для инициализации матрицы смежности входного графа будут рассмотрены все дуги с метками $a \in \Sigma \cap L$ и соответствующие им правила вида $A \rightarrow a$. Таким образом, будут рассмотрены все пути графа длины 1, но также необходимо рассмотреть пустые пути, при условии наличия в грамматике $G$ правил вида $A \rightarrow \varepsilon$. Поэтому для каждого такого правила и для каждой вершины $i$ графа $\mathcal{G}$ в матрицу будет записана информация о наличии пустого пути $\pi$ из вершины $i$ в вершину $i$ такого, что строка $\lambda(\pi)$ выводится из нетерминала $A$.

Далее опишем процедуру обхода графа, основанную на вычислении транзитивного замыкания инициализированной матрицы. Такое транзитивное замыкание может быть вычислено с использованием известной техники~\cite{baras2010path}, в которой производится серия умножений матрицы смежности на себя. Это позволит обойти граф и рассмотреть все необходимые для анализа графа пути. Остаётся лишь переопределить операцию умножения таких матриц, чтобы, во-первых, в процессе обхода графа рассматриваемые пути проверялись на соответствие входным КС-ограничениям, а, во-вторых, вычислялась вся необходимая информация для решения поставленной задачи достижимости, поиска одного или поиска всех путей в графе. Для проверки путей на соответствие входным КС-ограничениям будут использованы правила вида $A \rightarrow B C$, где $A, B, C \in N$. В правой части таких правил имеется лишь конкатенация двух нетерминалов, что в процессе вывода строки в грамматике соответствует конкатенации двух подстрок. Аналогично, в процессе анализа графа правила такого вида соответствуют конкатенации двух коротких путей $i \pi_1 k$ и $k \pi_2 j$, где $B \Rightarrow_G \lambda(\pi_1)$ и $C \Rightarrow_G \lambda(\pi_2)$. В таком случае, для пути $i\pi j$, полученного в результате такой конкатенации мы можем утверждать, что $A \Rightarrow_G \lambda(\pi)$. Таким образом, процесс обхода графа $\mathcal{G}$ будет неразрывно связан с процессом вывода строк в грамматике $G$, образованных рассмотренными путями графа. И, наконец, чтобы вычислялась вся необходимая информация для решения поставленной задачи поиска путей в графе, построим алгебраическую структуру $\langle \textit{MatrixElements}, \oplus, \otimes, \bot \rangle$, где:
\begin{itemize}
    \item $\textit{MatrixElements}$~--- множество, содержащее в себе все возможные значения элементов рассматриваемых матриц;
    \item $\oplus$~--- операция сложения элементов матриц, которая будет использоваться при агрегации информации о нескольких путях в графе между одними и теми же вершинами;
    \item $\otimes$~--- операция умножения элементов матриц, которая будет использоваться при агрегации информации о двух путях, которые могут быть сконкатенированы в один более длинный путь;
    \item $\bot$~--- нейтральный по сложению элемент, который будет обозначать отсутствие искомых путей для конкретной пары вершин.
\end{itemize}

Тогда используя построенную алгебраическую структуру определим операцию умножения матриц \mbox{$a \cdot b = c$}, где $a$ и $b$~--- матрицы подходящих размеров с элементами из множества $\textit{MatrixElements}$, как $$c_{i, j} = \bigoplus^{n}_{k=1}{a[i, k] \otimes b[k, j]}.$$ Кроме того, для агрегации информации о путях из двух матриц одинакового размера будем использовать операцию $\bigoplus$ поэлементного сложения элементов этих двух матриц, определённую над той же алгебраической структурой. Также на этапе инициализации необходимо определить элементы, используемые для описания информации о путях длины 0 и 1. Так как значения этих элементов зависят от поставленной задачи поиска путей в графе, то обозначим их, как $\alpha^0_{i, j}, \alpha^1_{i, j} \in \textit{MatrixElements}$, для каждой пары вершин $(i, j)$.

Таким образом, на листинге~\ref{lst:mtx_cfpq} представлен алгоритм поиска путей в графе с заданными КС-ограничениями, использующий операции умножения матриц. Представленный алгоритм принимает на вход граф и КС-ограничения уже выраженные в виде КС-грамматики в ослабленной нормальной форме Хомского. Стоит отметить, что вместо одной матрицы информация о путях в графе хранится в множестве матриц $T$, состоящем из $|N|$ матриц $T^A$ по одной на каждый нетерминальный символ $A \in N$. В таком случае в ячейку $T^A[i, j]$ записывается информация о найденных путях в графе из вершины $i$ в вершину $j$, образующих строки, выводимые из нетерминала $A$ в грамматике $G$. Данная идея схожа с идеей использования булевой декомпозиции матрицы смежности, однако получаемые матрицы $T^A$ будут булевыми только для задачи достижимости. В итоге, предложенный алгоритм решает поставленную задачу поиска путей в графе $\mathcal{G}$ с заданными КС-ограничениями, так как вся необходимая информация о путях из вершины $i$ в вершину $j$, удовлетворяющих заданным КС-ограничениям в виде грамматики $G = \langle \Sigma, N, P, S\rangle$, будет записана в ячейку $T^S[i, j]$.


\begin{algorithm}
	\begin{algorithmic}[1]
		\floatname{algorithm}{Листинг}
		\caption{Алгоритм поиска путей в графе с заданными КС-ограничениями, использующий операции умножения матриц}
		\label{lst:mtx_cfpq}
		\Function{MatrixBasedCFPQ}{$\mathcal{G} = \langle V, E, L \rangle$, $G= \langle N, \Sigma, P, S \rangle$}
		\State{$n \gets$ |V|}
		\State{$T \gets \{T^{A} \mid A \in N$, где $T^{A}$~--- матрица размера $n \times n$ со всеми элементами равными $\bot$ \} }
		
		\ForAll{$(i, x, j) \in E$, $A \mid A \to x \in P$}
		%\Comment{Matrices initialization}
		%\For{$A_k \mid A_k \to x \in P$}
		\State{$T^{A}[i, j] \gets \alpha^1_{i, j}$} \Comment{Инициализация матриц для правил вида $A \to x$}
		%\EndFor
		\EndFor
		\For{$A \mid A \to \varepsilon \in P$}
		\ForAll{$i \in \{0,\ldots, n - 1\}$}
		\State{$T^{A}[i, i] \gets \alpha^0_{i, i}$} \Comment{Инициализация матриц для правил вида $A \to \varepsilon$}
		\EndFor
		\EndFor
		
		\While{любая матрица из $T$ меняется}
		%\Comment{Transitive closure calculation}
		\ForAll{$A \to B C \in P$, где $T^{B}$ или $T^{C}$ изменились}
		\State{ $T^{A} \gets T^{A} \bigoplus (T^{B} \cdot T^{C})$ } 
		\EndFor
		\EndWhile
		\State \Return $T$
		\EndFunction
		
	\end{algorithmic}
\end{algorithm}

Далее представим различные алгебраические структуры, позволяющие переопределить операции над матрицами в алгоритме, представленном на листинге~\ref{lst:mtx_cfpq}, для решения задачи достижимости, поиска одного пути или поиска всех путей в графе с заданными КС-ограничениями.

\paragraph{Задача достижимости.} Так как для решения задачи достижимости необходима лишь информация о наличии путей, образующих из меток своих дуг определённые слова, то в ячейках матрицы смежности могут содержаться только булевы значения 0 или 1. В таком случае в ячейку $T^A[i, j]$ записывается значение 1, если существует путь из вершины $i$ в вершину $j$, образующий строку, выводимую из нетерминала $A$ в грамматике $G$, и значение 0 в противном случае. В процессе инициализации матриц в ячейки $T^A[i, j]$ будут записываться значения $\alpha^0_{i, j}$ и $\alpha^1_{i, j}$ при обнаружении соответствующего пути длины 0 или 1. А так как для поставленной задачи наличие пути записывается в соответствующую ячейку с помощью значения 1, то $\alpha^0_{i, j} = \alpha^1_{i, j} = 1$. Таким образом, алгоритм, представленный на листинге~\ref{lst:mtx_cfpq} решает задачу достижимости в графе с заданными КС-ограничениями при использовании алгебраической структуры $\langle \{0, 1\}, \vee, \wedge, 0 \rangle$ с логическими операциями дизъюнкции и конъюнкции. В графе $\mathcal{G}$ существует путь из вершины $i$ в вершину $j$, удовлетворяющий заданным КС-ограничениям, только если $T^S[i, j] = 1$.

\paragraph{Задача поиска одного пути.}
Для решения задачи поиска одного пути в графе с заданными КС-ограничениями, необходимо для каждой пары вершин $(i, j)$ иметь возможность построить хотя бы одни путь из вершины $i$ в вершину $j$, удовлетворяющий заданным ограничениям, если такие пути существуют. Для этого добавим в ячейки матриц дополнительную информацию о найденных путях в графе и построим новую алгебраическую структуру для модификации операций над этими матрицами. Будем использовать матрицы, в ячейках которых записана информация о найденных путях в виде четвёрок ($\textit{left}$, $\textit{right}$, $\textit{middle}$, $\textit{height}$), где $\textit{left}$ и $\textit{right}$~--- конечные вершины найденного пути, $\textit{middle}$~--- одна из промежуточных вершин найденного пути $\pi$ со строкой $\lambda(\pi)$, выводимой из нетерминала $A$ в грамматике $G$, и $\textit{height}$~--- минимальная высота дерева вывода строки $\lambda(\pi)$ из нетерминала $A$. В случае, когда для определенной пары вершин $(i, j)$ таких путей не обнаружено, то будем использовать четвёрку $\bot = (0, 0, 0, 0)$. 

Для конкретной пары вершин $(i, j)$ и нетерминала $A$ в предложенном алгоритме будет рассматриваться путь, образующий строку, выводимую из нетерминала $A$ и имеющую минимальную высоту дерева вывода. Кроме того, будут рассматриваться конкатенации двух таких путей для различных троек $(A, i, j)$. Поэтому в предложенном алгоритме будут использоваться только четвёрки ($\textit{left}$, $\textit{right}$, $\textit{middle}$, $\textit{height}$) с $\textit{height} \leq h + 1$, где $h$~--- максимальная из таких минимальных высот деревьев вывода для различных троек $(A, i, j)$. Обозначим множество всех возможных таких четвёрок, включая $\bot$, как $\textit{PathIndex}$, и построим алгебраическую структуру, используя это множество как носитель. Нейтральным по сложению элементом в такой структуре будет являться четвёрка $\bot$. В таком случае, изначально все матрицы будут инициализированы этим нейтральным элементом. Далее необходимо определить операции умножения и сложения для этой структуры.

Так как в процессе обхода графа с использованием операции умножения матриц и правил грамматики вида $A \to B C$, рассматриваются более длинные пути $i \pi j$, являющиеся конкатенацией двух коротких путей $i\pi_1 k$ и $k \pi_2 j$, то в качестве промежуточной вершины $\textit{middle}$ длинного пути удобно выбрать вершину $k$. Тогда операция умножения $\otimes$ для \mbox{$\textit{PI}_1, \textit{PI}_2 \in \textit{PathIndex}$}, может быть определена следующим образом.

$$\textit{PI}_1 \otimes \textit{PI}_2 = \begin{cases}
      (\textit{PI}_1.\textit{left}, \textit{PI}_2.\textit{right}, \textit{PI}_1.\textit{right}, max(\textit{PI}_1.\textit{height}, \textit{PI}_2.\textit{height}) + 1),\\
                     \qquad \text{если $\textit{PI}_1\neq \bot \neq \textit{PI}_2$} \\
      \bot, \qquad \text{иначе} \\
    \end{cases}\
$$

Кроме того, в процессе анализа графа для одной и той же пары вершин могут быть найдены несколько путей, удовлетворяющих заданным КС-ограничениям. Такие пути агрегируются с использованием операции сложения $\oplus$ для \mbox{$\textit{PI}_1, \textit{PI}_2 \in \textit{PathIndex}$}, которая может быть определена следующим образом.

$$\textit{PI}_1 \oplus \textit{PI}_2 = \begin{cases}
      \textit{PI}_1, \qquad \text{если $\textit{PI}_1\neq \bot \neq \textit{PI}_2$ и} \\ \qquad (\textit{PI}_1.\textit{height}, \textit{PI}_1.\textit{middle}) \leq (\textit{PI}_2.\textit{height}, \textit{PI}_2.\textit{middle}) \\
      \textit{PI}_1, \qquad \text{если $\textit{PI}_2 = \bot$} \\
      \textit{PI}_2, \qquad \text{иначе} \\
    \end{cases}\
$$

В представленном определении использовался лексикографический порядок над парами целых чисел $(\textit{PI}.\textit{height}, \textit{PI}.\textit{middle})$ для $\textit{PI} \in \textit{PathIndex}$. Таким образом, при использовании операции $\oplus$ в ячейках матрицы $T^A$ будет содержаться информация о найденных путях, образующих строки с минимальными высотами деревьев вывода из нетерминала $A$ в грамматике $G$. Далее определим значения элементов $\alpha^0_{i, j}, \alpha^1_{i, j} \in \textit{PathIndex}$. При обнаружении пути длины 1, выводимого из нетермниала $A_k$ в соответствующую ячейку матрицы $T^{A_k}$ будет добавляться информация об этом пути в виде четвёрки $\alpha^1_{i, j} = (i, j, i, 1)$. В свою очередь для путей длины 0 в соответствующие ячейки добавляются четвёрки $\alpha^0_{i, i} = (i, i, i, 1)$. В данных случаях в качестве промежуточных вершины выбраны начальные вершины путей длины 0 и 1. Таким образом, алгоритм, представленный на листинге~\ref{lst:mtx_cfpq} позволяет решить задачу поиска одного пути в графе с заданными КС-ограничениями при использовании полукольца $\langle \textit{PathIndex}, \oplus, \otimes, \bot \rangle$ с определенными для данной задачи операциями. Результатом работы алгоритма является множество матриц $T^A$ для всех нетерминальных символов $A \in N$, в ячейках $(i, j)$ которых содержится информация об одном найденном пути из вершины $i$ в вершину $j$, образующем строку, выводимую из нетерминала $A$ с минимальной высотой дерева вывода. В случае, если для пары вершин $(i, j)$ таких путей не существует, то $T^A[i, j] = \bot$.

Однако кроме построения множества матриц $T$, содержащих информацию о найденных путях, необходимо восстановить путь $i \pi j$ для любых $i, j$ и нетерминала $A$ таких, что $A \Rightarrow_G \lambda(\pi)$, если такой путь существует. Поэтому на листинге~\ref{lst:mtx_single_extract} представлен алгоритм восстановления одного пути, соответствующего заданным КС-ограничениям, для любой пары вершин $(i, j)$ и нетерминала $A$. Представленный алгоритм восстанавливает путь, соответствующий строке с минимальной высотой дерева вывода. Алгоритм возвращает пустой путь $\pi_{\varepsilon}$ только когда $i = j$ и $A \to \varepsilon \in P$. Необходимо заметить, что если $T^A[i, j] = \bot$, то предложенный алгоритм возвращает специальный путь $\pi_{\emptyset}$, обозначающий отсутствие путей соответствующих заданным КС-ограничениям.

	\begin{algorithm}
		\floatname{algorithm}{Листинг}
		\begin{algorithmic}[1]
			\caption{Алгоритм восстановления одного пути в графе с заданными КС-ограничениями}
			\label{lst:mtx_single_extract}
			\Function{ExtractSinglePath}{$i, j, A, T=\{T^{A_i}\}, G=\langle N, \Sigma, P, S \rangle$}
			\State{$\textit{index} \gets T^{A}_{i,j}$ }
			
			\If{$\textit{index} = \bot$}
			\State \Return $\pi_{\emptyset}$
			\Comment{Такого пути не существует}
			\EndIf
			
			\If{$\textit{index.height} = 1$}
			\If{$(i = j) \wedge (A \to \varepsilon \in P)$}
			\State \Return $\pi_{\varepsilon}$
			\Comment{Возвращаем пустой путь}
			\EndIf
			\ForAll{$ x \mid (i,x,j) \in E$}
			\If{$A \to x \in P$}
			\State \Return $[(i,x,j)]$
			\Comment{Возвращаем путь длины 1}
			\EndIf
			\EndFor
			\EndIf
			
			\ForAll{$A \to B C \in P$}
			\State{$\textit{index}_B \gets T^{B}[i, \textit{index.middle}]$ }
			\State{$\textit{index}_C \gets T^{C}[\textit{index.middle}, j]$ }			
			\If{$(\textit{index}_B \neq \bot) \wedge (\textit{index}_C \neq \bot)$}
			\State{$\textit{maxH} \gets \textit{max}(\textit{index}_B.\textit{height}, \textit{index}_C.\textit{height})$ }
			\If{$\textit{index.height} = \textit{maxH} + 1$}
			
						
			\State{$\pi_1 \gets$ \Call{ExtractSinglePath}{$i, \textit{index.middle}, B, T, G$}}
			\State{$\pi_2 \gets$ \Call{ExtractSinglePath}{$\textit{index.middle}, j, C, T, G$}}
			\State \Return $\pi_1 + \pi_2$
			\Comment{Возвращаем конкатенацию двух путей}
			\EndIf
			\EndIf
			\EndFor
			\EndFunction
		\end{algorithmic}
	\end{algorithm}
	
Таким образом, алгоритмы представленные на листингах~\ref{lst:mtx_cfpq} и \ref{lst:mtx_single_extract} позволяют решить задачу поиска одного пути в графе с заданными КС-ограничениями с использованием операций умножения матриц.
 
\paragraph{Задача поиска всех путей.}
Для решения задачи поиска всех путей в графе с заданными КС-ограничениями, необходимо для каждой пары вершин $(i, j)$ иметь возможность построить все пути из вершины $i$ в вершину $j$, удовлетворяющие заданным ограничениям. Для этого добавим в ячейки матриц дополнительную информацию о всех найденных путях в графе и построим новую алгебраическую структуру для модификации операций над этими матрицами. В качестве такой информации возьмём множество троек $(\textit{left}, \textit{right}, \textit{middles})$, где $\textit{left}$ и $\textit{right}$~--- начальная и конечная вершины найденных путей, а $\textit{middles}$~--- множество некоторых промежуточных вершин этих путей. В процессе обхода графа в $T^A[i, j].\textit{middles}$ будут записываться все промежуточные вершины $k$ рассматриваемых путей $i \pi j$, образованных конкатенацией двух более коротких путей $i \pi_1 k$ и $k \pi_2 j$. В случае, если путь имеет длину 0 или 1 и не имеет промежуточных вершин, то будем добавлять в соответствующую ячейку $(i, j)$ элементы $\alpha^0_{i, j} = \alpha^1_{i, j} = (i, j, \{n\})$ со специальным значением $n = |V|$. Такое значение отличается от номера любой вершины рассматриваемого графа, что позволит отдельно рассматривать случай, когда найденный путь не имеет промежуточных вершин. А в случае отсутствия путей, соответствующих заданным ограничениям для некоторой пары вершин, будем использовать тройку $\bot = (0, 0, \emptyset)$.  Обозначим множество всех возможных значений таких ячеек, включая $\bot$, как $\textit{AllPathIndex}$. Теперь построим алгебраическую структуру над элементами множества $\textit{AllPathIndex}$, которое позволит модифицировать операции умножения и сложения матриц для решения задачи поиска всех путей в графе с заданными КС-ограничениями. Нейтральным элементом по сложению в этой структуре будет элемент $\bot$.

Для построения алгебраической структуры сначала определим операцию умножения $\otimes$ для \mbox{$\textit{API}_1, \textit{API}_2 \in \textit{AllPathIndex}$} следующим образом.

$$\textit{API}_1 \otimes \textit{API}_2 = \begin{cases}
      (\textit{API}_1.\textit{left}, \textit{API}_2.\textit{right}, \{\textit{API}_1.\textit{right}\}), \text{если $\textit{API}_1 \neq \bot \neq \textit{API}_2$} \\
      \bot, \qquad \text{иначе} \\
    \end{cases}\
$$

При обнаружении нескольких путей в графе, удовлетворяющих заданным КС-ограничениям, для одной и той же пары вершин необходимо записать информацию обо всех найденных путях. Поэтому определим операцию сложения $\oplus$ для \mbox{$\textit{API}_1, \textit{API}_2 \in \textit{AllPathIndex}$} следующим образом.

$$\textit{API}_1 \oplus \textit{API}_2 = \begin{cases}
      (\textit{API}_1.\textit{left}, \textit{API}_1.\textit{right}, \\ \textit{API}_1.\textit{middles} \cup \textit{API}_2.\textit{middles}), \qquad \text{если $\textit{API}_1\neq \bot$} \\
      \textit{API}_2, \qquad \text{иначе} \\
    \end{cases}\
$$

Таким образом, алгоритм, представленный на листинге~\ref{lst:mtx_cfpq} позволяет решить задачу поиска всех путей в графе с заданными КС-ограничениями при использовании алгебраической структуры $\langle \textit{AllPathIndex}, \oplus, \otimes, \bot \rangle$ с определенными для данной задачи операциями. Результатом работы алгоритма является множество матриц $T^A$ для всех нетерминальных символов $A \in N$, в ячейках $(i, j)$ которых содержится информация обо всех путях из вершины $i$ в вершину $j$, образующих строки, выводимые из нетерминала $A$. В случае, если для пары вершин $(i, j)$ таких путей не существует, то $T^A[i, j] = \bot$.

После построения множества матриц $T$, содержащих информацию обо всех найденных путях, необходимо иметь возможность восстановить все пути $i \pi j$ для любых $i, j$ и нетерминала $A$ таких, что $A \Rightarrow_G \lambda(\pi)$. Поэтому на листинге~\ref{lst:mtx_all_extract} представлен алгоритм восстановления всех путей, соответствующих заданным КС-ограничениям, для любой пары вершин $(i, j)$ и нетерминала $A$. Алгоритм возвращает пустой путь $\pi_{\varepsilon}$ только когда $i = j$ и $A \to \varepsilon \in P$.

\begin{algorithm}
	\begin{algorithmic}[1]
		\floatname{algorithm}{Листинг}
		\caption{Алгоритм восстановления всех путей в графе с заданными КС-ограничениями}
		\label{lst:mtx_all_extract}		
		\Function{ExtractAllPaths}{$i, j, A, T=\{T^{A_k} \mid A_k \in N\}, G=\langle N, \Sigma, P, S \rangle$}
		\State{$\textit{index} \gets T^{A}_{i,j}$ }
		
		\If{$\textit{index} = \bot$}
		\State \Return $\emptyset$
		\Comment{Таких путей не существует}
		\EndIf
		
		\State{$n \gets $ количество строк матрицы $T^{A}$}
		\State{$\textit{resultPaths} \gets \emptyset$}
		
		\ForAll{$m \in \textit{index.middles}$}		
		\If{$m = n$}  \Comment{Добавляем путь длины 0 или 1}
		\ForAll{$x \mid A \to x \in P$}
		\If{$(i, x, j) \in E$}
		\State{$\textit{resultPaths} \gets \textit{resultPaths} \cup \{((i, x, j))\}$}
		\EndIf
		\EndFor
		\If{$(i = j) \wedge (A \to \varepsilon \in P)$}
		\State{$\textit{resultPaths} \gets \textit{resultPaths} \cup \{\pi_{\varepsilon}\}$}
		\EndIf
		\Else \Comment{Добавляем конкатенацию путей из $i$ в $m$ и путей из $m$ в $j$}
		\ForAll{$A \to B C \in P$}
		\State{$\textit{index}_B \gets T^{B}[i, m]$ }
		\State{$\textit{index}_C \gets T^{C}[m, j]$ }
		\If{$(\textit{index}_B \neq \bot) \wedge (\textit{index}_C \neq \bot)$}
		\State{$\textit{lPaths} \gets$ \Call{ExtractAllPaths}{$i, m, B, T, G$}}
		\State{$\textit{rPaths} \gets$ \Call{ExtractAllPaths}{$m, j, C, T, G$}}
		\State{$\textit{resultPaths} \gets \textit{resultPaths} \cup \textit{lPaths} \cdot \textit{rPaths}$}
		\EndIf
		\EndFor
		\EndIf
		\EndFor
		\State \Return $\textit{resultPaths}$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Таким образом, алгоритмы представленные на листингах~\ref{lst:mtx_cfpq} и \ref{lst:mtx_all_extract} позволяют решить задачу поиска всех путей в графе с заданными КС-ограничениями с использованием операций умножения матриц.


\section{Корректность алгоритма}\label{sec:ch3/sect2}
В данном разделе сформулированы и доказаны утверждения о корректности и завершаемости изложенного алгоритма для рассмотренных задач поиска путей в графе с заданными КС-ограничениями.

Пусть дана одна из трёх задач поиска путей в графе с заданными КС-ограничениями. Также пусть для поставленной задачи построена алгебраическая структура $\langle \textit{MatrixElements}, \oplus, \otimes, \bot \rangle$, переопределяющая операции над матрицами в алгоритме, представленном на листинге~\ref{lst:mtx_cfpq}. Кроме того, пусть для любой пары вершин $(i, j)$ входного графа $\mathcal{G}$ в носителе этой структуры выделены элементы $\alpha^0_{i, j}$ и $\alpha^1_{i, j}$, используемые для инициализации матриц этого алгоритма. Тогда сначала докажем, что если построенная структура обладает некоторыми свойствами, то получившийся алгоритм поиска путей в графе завершается за конечно число шагов и корректно решает поставленную задачу. А затем покажем, что предложенные в предыдущем разделе алгебраические структуры для задач достижимости, поиска одного и поиска всех путей в графе с заданными КС-ограничениями такими свойствами обладают.

\textbf{Завершаемость.} Для доказательства завершаемости алгоритма, представленного на листинге~\ref{lst:mtx_cfpq}, сперва введём обозначения для промежуточных матриц из множества $T$, получающихся в процессе работы этого алгоритма. Для любой пары вершин $(i, j)$ и для любого нетерминала $A \in N$, будем использовать обозначение $T^{A, 0}[i, j]$ для значения в ячейке $T^{A}[i, j]$ после инициализации матриц в строках 2--8 алгоритма, а $T^{A, k}[i, j]$~--- для значения в ячейке $T^{A}[i, j]$ после $k$ исполнений цикла в строках 9--11, для $k \geq 1$.

Тогда докажем, что если на элементах использованной конечной алгебраической структуры $\langle \textit{MatrixElements}, \oplus, \otimes, \bot \rangle$ может быть задано некоторое отношение частичного порядка $\preceq$, то предложенный алгоритм завершается.

\begin{theorem}[Завершаемость алгоритма]\label{thm:finite_mtx}
	 Если на элементах использованной алгебраической структуры $\langle \textit{MatrixElements}, \oplus, \otimes, \bot \rangle$ может быть задано отношение частичного порядка $\preceq$ такое, что для любой пары вершин $(i, j)$, любого нетерминала $A \in N$ и любого $k \geq 1$, $T^{A, k - 1}[i, j] \preceq T^{A, k}[i, j]$ и носитель $\textit{MatrixElements}$~--- конечен, то алгоритм, представленный на листинге~\ref{lst:mtx_cfpq} завершается за конечное число шагов.
\end{theorem}
\begin{proof}
На очередной итерации цикла в строках 9--11 алгоритма, значения в ячейках $T^A[i, j]$ либо могут не изменяться, либо изменяться в результате выполнения операций $T^{A} \gets T^{A} \bigoplus (T^{B} \cdot T^{C})$ в строке 11. Алгоритм продолжает свою работу пока значение хотя бы в одной ячейке изменяется. По условию теоремы, значения в ячейках матриц от итерации к итерации монотонно возрастают относительно заданного частичного порядка $\preceq$. Таким образом, в силу конечности носителя $\textit{MatrixElements}$ на некоторой итерации матрицы перестанут изменяться и алгоритм завершит свою работу.
\end{proof}

\textbf{Корректность.} Для доказательства корректности алгоритма, представленного на листинге~\ref{lst:mtx_cfpq}, введём обозначения, описывающие связь рассматриваемых путей в графе и значений в ячейках $T^{A, k}[i, j]$ промежуточных матриц, получающихся в процессе работы этого алгоритма. Для любой пары вершин $(i, j)$ и для любого нетерминала $A \in N$, будем использовать обозначение $\mathcal{P}_{\mathcal{G}, k}(i, j, A)$ для множества всех путей $i \pi j$ графа $\mathcal{G}$ таких, что существует дерево вывода минимальной высоты $h \leq k$ для строки $\lambda(\pi)$ из нетерминала $A$ грамматики $G$. Также будем говорить, что некоторая информация позволяет корректно решить задачу поиска путей с заданными КС-ограничениями для множества путей $\mathcal{P}$ из вершины $i$ в вершину $j$, если эта информация:
\begin{itemize}
    \item позволяет ответить на вопрос существования хотя бы одного пути $\pi \in \mathcal{P}$, удовлетворяющего заданным ограничениям, для задачи достижимости;
    \item позволяет построить хотя бы один путь $\pi \in \mathcal{P}$, удовлетворяющий заданным ограничениям, если такой существует, для задачи поиска одного пути;
    \item позволяет построить любое конечное количество путей $\pi \in \mathcal{P}$, удовлетворяющих заданным ограничениям, для задачи поиска всех путей.
\end{itemize}

Тогда докажем, что если операции использованной алгебраической структуры $\langle \textit{MatrixElements}, \oplus, \otimes, \bot \rangle$ и её элементы обладают некоторыми свойствами, то предложенный алгоритм корректно решает поставленную задачу.

\begin{lemma}[Корректность алгоритма]\label{lemma:correct_mtx}
	Пусть $\mathcal{G} = \langle V, E, L \rangle$~--- входной граф и $G =\langle N, \Sigma, P, S \rangle$~--- входная КС-грамматика для алгоритма, представленного на листинге~\ref{lst:mtx_cfpq}. Также пусть для использованной алгебраической структуры $\langle \textit{MatrixElements}, \oplus, \otimes, \bot \rangle$ и для любых элементов $\alpha_1, \alpha_2 \in \textit{MatrixElements}$ справедливы следующие свойства:
	\begin{itemize}
	    \item алгебраическая структура $\langle \textit{MatrixElements}, \oplus, \otimes, \bot \rangle$ является полукольцом без требования ассоциативности операции $\otimes$;
	    \item выделенные элементы $\alpha^l_{i, j} \in \textit{MatrixElements}$, использованные в строках 4--8 алгоритма, позволяют корректно решить поставленную задачу для множеств путей графа $\mathcal{G}$ из вершины $i$ в вершину $j$ длины $l$, где $l \in \{0, 1\}$;
	    \item если элементы $\alpha_1$ и $\alpha_2$ позволяют корректно решить поставленную задачу для множеств путей $\mathcal{P}_1$ и $\mathcal{P}_2$ из вершины $i$ в вершину $j$, то элемент $\alpha_1 \oplus \alpha_2$ позволяет корректно решить поставленную задачу для множества путей $\mathcal{P}_1 \cup \mathcal{P}_2$;
	    \item если элементы $\alpha_1$ и $\alpha_2$ позволяют корректно решить поставленную задачу для множества путей $\mathcal{P}_1$ из вершины $i$ в вершину $k$ и для множества $\mathcal{P}_2$ путей из вершины $k$ в вершину $j$, то элемент $\alpha_1 \otimes \alpha_2$ позволяет корректно решить поставленную задачу для множества путей $\mathcal{P}_1 \cdot \mathcal{P}_2$ всех возможных конкатенаций путей из этих множеств.
	\end{itemize}
	Тогда  для любой пары вершин $(i, j)$ графа $\mathcal{G}$, для любого нетерминала $A \in N$ и для любого $k \geq 0$ значение в ячейке $T^{A, k}[i, j]$ позволяет корректно решить поставленную задачу для множества путей $\mathcal{P}_{\mathcal{G}, k + 1}(i, j, A)$.
\end{lemma}
\begin{proof}(Доказательство методом математической индукции)

\textbf{База}: Покажем, что утверждение леммы справедливо для $k = 0$. Для грамматик в ослабленной нормальной форме Хомского, деревья вывода с высотой 1 имеют лишь строки длины 1 или пустая строка $\varepsilon$. Таким образом, множество $\mathcal{P}_{\mathcal{G}, 1}(i, j, A)$ содержит только пути длины 0 или 1. Для всех таких путей и только для них существует дерево вывода минимальной высоты $h = k + 1 = 1$, показанное на рисунке~\ref{tree1}. Рассмотрение таких путей происходит в строках 4--8 алгоритма. Поэтому для любой пары вершин $(i, j)$ и любого нетерминала $A \in N$, $T^{A, 0}[i, j] \neq \bot$ тогда и только тогда, когда либо существует путь $i \pi j$ длины $1$, который содержит единственную дугу $(i, x, j) \in E$ и $(A \rightarrow x) \in P$, либо $i = j$ и $(A \rightarrow \varepsilon) \in P$. В случае наличия пути $\pi \in \mathcal{P}_{\mathcal{G}, 1}(i, j, A)$, в ячейку $T^{A, 0}[i, j]$ будут записаны соответствующие элементы $\alpha^0_{i, j}$ или $\alpha^1_{i, j}$. А по условию леммы выделенные элементы $\alpha^l_{i, j} \in \textit{MatrixElements}$ позволяют корректно решить поставленную задачу для множеств путей длины $l$, где $l \in \{0, 1\}$. Таким образом, утверждение леммы справедливо для $k = 0$.
	
	\begin{figure}
	\begin{center}
		\begin{tikzpicture}[on grid, auto]
		\node[state] (q_0)   {$A$};
		\node[state] (q_1) [below=2.0cm of q_0] {$x$};
		\path[->]
		(q_0) edge  node {} (q_1);
		\end{tikzpicture}
	\end{center}
	\caption{Дерево вывода минимальной высоты $h = 1$ для строки $x = \lambda(\pi)$, где $x \in \Sigma \cup \{\varepsilon\}$}
	\label{tree1}
\end{figure}
	
	\textbf{Индукционный переход}: Предположим, что утверждение леммы справедливо для любого $k \leq (p - 1)$, где $p \geq 1$, и покажем, что оно также справедливо для $k = p$.
	
	Операции цикла в строках 9--11 алгоритма означают, что значение $T^{A, p}[i, j] = T^{A, p - 1}[i, j] \bigoplus_{A \to B C \in P} (T^{B, p - 1} \cdot T^{C, p - 1})[i, j]$. Докажем, что значение в ячейке $T^{A, p}[i, j]$ позволяет корректно решить поставленную задачу для множества путей $\mathcal{P}_{\mathcal{G}, p + 1}(i, j, A)$. 
	
	Пусть значение $\bigoplus_{A \to B C \in P} (T^{B, p - 1} \cdot T^{C, p - 1})[i, j]$ позволяет корректно решить задачу для множества путей $\mathcal{P}'$. По индукционному предположению, значение в ячейке $T^{A, p - 1}[i, j]$ позволяет это сделать для множества путей $\mathcal{P}_{\mathcal{G}, p}(i, j, A)$. Тогда по условию леммы получаем, что значение $T^{A, p}[i, j] = T^{A, p - 1}[i, j] \bigoplus_{A \to B C \in P} (T^{B, p - 1} \cdot T^{C, p - 1})[i, j]$ позволяет корректно решить поставленную задачу для множества путей $\mathcal{P}_{\mathcal{G}, p}(i, j, A) \cup \mathcal{P}'$. Таким образом, для завершения доказательства леммы остаётся показать, что $\mathcal{P}_{\mathcal{G}, p}(i, j, A) \cup \mathcal{P}' = \mathcal{P}_{\mathcal{G}, p + 1}(i, j, A)$.
	
	Существование путей $\pi \in \mathcal{P}_{\mathcal{G}, p + 1}(i, j, A)$ равносильно существованию правила $A \to B C \in P$, а также путей $\pi_1 \in \mathcal{P}_{\mathcal{G}, p}(i, r, B)$  и $\pi_2 \in \mathcal{P}_{\mathcal{G}, p}(r, j, C)$, где путь $\pi$ получается в результате конкатенации путей $\pi_1$ и $\pi_2$, а дерево вывода строки $\lambda(\pi)$ из нетерминала $A$ с минимальной высотой $h \leq p + 1$ представлено на рисунке~\ref{tree2}. По индукционному предположению, значения $T^{B, p - 1}[i, r]$ и $T^{C, p - 1}[r, j]$ позволяют корректно решить поставленную задачу для множества всех таких путей $\pi_1$ и для множества всех таких путей $\pi_2$ соответственно. Используя свойства операции $\oplus$ и $\otimes$ из условия леммы, а также построение операций над матрицами получаем, что значение $(T^{B, p - 1} \cdot T^{C, p - 1})[i, j]$ позволяет корректно решить поставленную задачу для множества путей $\mathcal{P}_{\textit{BC}}$, полученного конкатенацией таких путей $\pi_1$ и $\pi_2$. Кроме того, используя свойство операции $\oplus$ из условия леммы получаем, что $\bigoplus_{A \to B C \in P} (T^{B, p - 1} \cdot T^{C, p - 1})[i, j]$ позволяет корректно решить поставленную задачу для множества путей $\mathcal{P}' = \bigcup_{A \to B C \in P} \mathcal{P}_{\textit{BC}}$. Таким образом, $\mathcal{P}_{\mathcal{G}, p}(i, j, A) \cup \mathcal{P}' = \mathcal{P}_{\mathcal{G}, p}(i, j, A) \cup \bigcup_{A \to B C \in P} \mathcal{P}_{\textit{BC}} = \mathcal{P}_{\mathcal{G}, p + 1}(i, j, A)$, что доказывает утверждение леммы.
	
	\begin{figure}[h!]
	\begin{center}
		\begin{tikzpicture}[on grid, auto]
		\node[state] (q_0)   {$A$};
		\node[state] (q_1) [below left=2cm and 1.5cm of q_0] {$B$};
		\node[state] (q_2) [below right= 2cm and 1.5cm of q_0] {$C$};
		\node[regular polygon,regular polygon sides=3, draw, dashed] (T1) [below=1.9cm of q_1] {$T_B$};
		\node[regular polygon,regular polygon sides=3, draw, dashed] (T2) [below=1.9cm of q_2] {$T_C$};
		\path[->]
		(q_0) edge  node {} (q_1)
		(q_0) edge  node {} (q_2);
		\end{tikzpicture}
	\end{center}
	\caption{Дерево вывода минимальной высоты $h = 1 + \textit{max}(h_1, h_2)$ для строки $\lambda(\pi)$, где $T_B$ и $T_C$~--- деревья вывода для строк $\lambda(p_1)$ и $\lambda(\pi_2)$ с высотами $h_1$ и $h_2$ соответственно}
	\label{tree2}
    \end{figure}

\end{proof}

Следствием леммы~\ref{lemma:correct_mtx} является следующая теорема о корректности алгоритма, представленного на листинге~\ref{lst:mtx_cfpq}.

\begin{theorem}[Корректность алгоритма]\label{thm:correct_mtx}
	Пусть $\mathcal{G} = \langle V, E, L \rangle$~--- входной граф и $G =\langle N, \Sigma, P, S \rangle$~--- входная КС-грамматика для алгоритма, представленного на листинге~\ref{lst:mtx_cfpq}. Пусть выбранная алгебраическая структура удовлетворяет свойствам, представленным в условии леммы~\ref{lemma:correct_mtx}. Тогда для любой пары вершин $(i, j)$ графа $\mathcal{G}$, для любого нетерминала $A \in N$, значение в ячейке $T^{A}[i, j]$ позволяет корректно решить поставленную задачу для множества всех путей графа $\mathcal{G}$ из вершины $i$ в вершину $j$.
\end{theorem}
\begin{proof}
Алгоритм возвращает множество матриц $T$ только в случае, когда для некоторого $k \geq 1$ $T^{A, k} = T^{A, k - 1}$ для всех нетерминалов $A \in N$. То есть для любого нетерминала $A$ $T^{A, p} = T^{A}$ для любого $p \geq k$. Таким образом, по лемме~\ref{lemma:correct_mtx}, для любой пары вершин $(i, j)$ графа $\mathcal{G}$, для любого нетерминала $A \in N$, ячейка $T^{A}[i, j]$ позволяет корректно решить поставленную задачу для множества всех путей $i \pi j$ таких, что существует дерево вывода для строки $\lambda(\pi)$ из нетерминала $A$ грамматики $G$. Что в свою очередь доказывает утверждение теоремы.
\end{proof}

Используя теорему~\ref{thm:correct_mtx} и индукцию на высоты деревьев вывода, соответствующих восстанавливаемым путям с помощью предложенного алгоритма для задач поиска одного пути и поиска всех путей, может быть доказана следующая теорема.

\begin{theorem}[Корректность восстановления путей]\label{thm:correct_extraction_single_all_mtx}
Пусть $\mathcal{G} = \langle V, E, L \rangle$~--- входной граф, $G =\langle N, \Sigma, P, S \rangle$~--- входная КС-грамматика и $T$~--- множество матриц, возвращаемое алгоритмом, представленным на листинге~\ref{lst:mtx_cfpq}. Пусть выбранная алгебраическая структура удовлетворяет свойствам, представленным в условии леммы~\ref{lemma:correct_mtx}. Тогда для любой пары вершин $(i, j)$ и любого нетерминала $A \in N$:
	\begin{itemize}
	    \item для задачи поиска одного пути алгоритм, представленный на листинге~\ref{lst:mtx_single_extract} построит путь $i \pi j$ такой, что существует дерево вывода для строки $\lambda(\pi)$ из нетерминала $A$ грамматики $G$, если такой путь существует;
	    \item для задачи поиска всех путей алгоритм, представленный на листинге~\ref{lst:mtx_all_extract} построит множество всех путей $i \pi j$ таких, что существует дерево вывода для строки $\lambda(\pi)$ из нетерминала $A$ грамматики $G$.
	\end{itemize}
\end{theorem}

\textbf{Свойства предложенных алгебраических структур.} Осталось показать, что предложенные в разделе~\ref{sec:ch3/sect1} алгебраические структуры для задач достижимости, поиска одного и поиска всех путей обладают свойствами, обеспечивающими завершаемость и корректность предложенного алгоритма.

Во-первых, покажем завершаемость алгоритма для предложенных структур. Конечность алгебраических структур для задачи достидимости и для задачи поиска всех путей очевидна. Покажем, что предложенная структура для задачи поиска одного пути также конечна. Для этого остаётся показать, что для заданных графа и КС-грамматики максимальная высота $h$ из минимальных высот деревьев вывода для различных троек $(A, i, j)$ может быть оценена сверху, а именно: $h \leq |N||V|^2$. Каждый внутренний узел рассматриваемых в предложенном алгоритме деревьев ассоциируется с некоторым нетерминалом $A$ и поддеревом с корнем в этом узле. Листья такого поддерева образуют строку, соответствующую некоторому пути в графе из вершины $i$ в вершину $j$. Поэтому с каждым внутренним узлом таких деревьев будем ассоциировать тройку $(A, i, j)$. Если бы для некоторой тройки $(A, i, j)$ существовало дерево вывода минимальной высоты $h > |N||V|^2$, то в таком дереве существовал бы путь длины $h > |N||V|^2$ из корня дерева до некоторого листа. А так как существует лишь $|N||V|^2$ различных таких троек, то на этом пути найдутся два различных узла $u$ и $v$, которые ассоциируются с одной и той же тройкой $(B, k, l)$. Пусть узел $u$ расположен ближе к корню дерева, чем узел $v$. Тогда заменив в этом дереве поддерево, соответствующее узлу $u$, на поддерево, соответствующее узлу $v$, мы получим новое дерево вывода для тройки $(A, i, j)$, в котором уменьшились некоторые расстояния от корня дерева до листов. Такие преобразования можно повторять, пока высота дерева не станет меньше либо равна $|N||V|^2$. Таким образом, изначальное дерево не обладало минимальной высотой для тройки $(A, i, j)$. Значит все такие высоты $h \leq |N||V|^2$, а четвёрки, которые будут использоваться в предложенном алгоритме, содержат $\textit{height} \leq |N||V|^2 + 1$. Поэтому предложенная структура для задачи поиска одного пути также имеет конечный носитель.

Для завершаемости алгоритма с использованием предложенных структур остается показать, что на элементах этих структур может быть задано отношение частичного порядка $\preceq$ такое, что для любой пары вершин $(i, j)$ и любого $k \geq 1$, $T^{A, k - 1}[i, j] \preceq T^{A, k}[i, j]$.

Пусть $\preceq_{\textit{rel}}$~--- отношение частичного порядка соответствующее задаче достижимости, $\preceq_{\textit{single}}$~--- задаче поиска одного пути и $\preceq_{\textit{all}}$~--- задаче поиска всех путей в графе. Для краткости будем использовать обозначения $z_l$, $z_r$, $z_h$, $z_m$ и $z_{ms}$ для $\textit{z.left}$, $\textit{z.right}$, $\textit{z.height}$, $\textit{z.middle}$ и $\textit{z.middles}$ соответственно, где $z$~--- элемент носителя $\textit{MatrixElements}$ одной из трёх введенных алгебраических структур. Тогда для любых элементов $x$ и $y$ этих носителей определим отношения частичного порядка следующим образом:

$$
\begin{array}{lcl}
   x \preceq_{\textit{rel}} y & \iff & (x = 0) \wedge (y = 1), \\ 
   x \preceq_{\textit{single}} y & \iff & (x = \bot = (0, 0, 0, 0)) \ \vee \\ 
    & & ((x_l = y_l) \wedge (x_r = y_r ) \wedge ((y_h, y_m) \leq (x_h, x_m)) ), \\ 
   x \preceq_{\textit{all}} y  & \iff & (x = \bot = (0, 0, \emptyset)) \vee ((x_l = y_l) \wedge (x_r = y_r) \wedge (x_{ms} \subseteq y_{ms}) ). \\ 
\end{array}
$$

%\begin{itemize}
%    \item $x \preceq_{rel} y \iff (x = 0) \wedge (y = 1)$,
%    \item $x \preceq_{single} y \iff (x = \bot = (0, 0, 0, 0)) \vee \\ ((x_l = y_l) \wedge (x_r = y_r ) \wedge ((y_h, y_m) \leq (x_h, x_m)) )$,
%    \item $x \preceq_{all} y \iff (x = \bot = (0, 0, \emptyset)) \vee ((x_l = y_l) \wedge (x_r = y_r) \wedge (x_{ms} \subseteq y_{ms}) )$.
%\end{itemize}

Необходимо показать, что для любого $k \geq 1$, $T^{A, k - 1}[i, j] \preceq_{\textit{rel}} T^{A, k}[i, j]$ для задачи достижимости, $T^{A, k - 1}[i, j] \preceq_{\textit{single}} T^{A, k}[i, j]$ для задачи поиска одного пути и  $T^{A, k - 1}[i, j] \preceq_{\textit{all}} T^{A, k}[i, j]$ для задачи поиска всех путей в графе. На очередной итерации цикла в строках 9--11 алгоритма, значение в ячейке $T^A[i, j]$ либо может не изменится, либо изменится в результате выполнения операций $T^{A} \gets T^{A} \bigoplus (T^{B} \cdot T^{C})$ в строке 11. Если значение не изменилось, то утверждение теоремы очевидно в силу рефлексивности рассматриваемых отношений частичного порядка. В противном случае $T^{A, k}[i, j] = T^{A, k - 1}[i, j] \oplus (T^{B, k - 1} \cdot T^{C, k - 1})[i, j]$. Для всех трёх задач поиска путей в графе с заданными КС-ограничениями докажем, что $T^{A, k - 1}[i, j] \preceq T^{A, k - 1}[i, j] \oplus (T^{B, k - 1} \cdot T^{C, k - 1})[i, j]$ для соответствующего отношения частичного порядка $\preceq$.

\textit{Задача достижимости.} Используя алгебраическую структуру над логическими значениями и операцию дизъюнкции в качестве операции $\oplus$, значение в ячейке $T^A[i, j]$ может изменится только с 0 на 1. Поэтому $T^{A, k - 1}[i, j] \preceq_{\textit{rel}} T^{A, k}[i, j]$, что доказывает завершаемость алгоритма для задачи достижимости.

\textit{Задача поиска одного пути.} По определению операции $\oplus$ полукольца над множеством четвёрок $\textit{PathIndex}$, значение в ячейке $T^A[i, j]$ может изменится только если $T^{A, k - 1}[i, j] = \bot$ или $$((T^{A, k}[i, j].\textit{height}, T^{A, k}[i, j].\textit{middle}) \leq (T^{A, k - 1}[i, j].\textit{height}, T^{A, k - 1}[i, j].\textit{middle})).$$ Если $T^{A, k - 1}[i, j] = \bot$, то по определению отношения частичного порядка $\preceq_{\textit{single}}$, $T^{A, k - 1}[i, j] \preceq_{\textit{single}} T^{A, k}[i, j]$. Иначе по определениям операции умножения матриц $(\cdot)$ и операции умножения элементов матриц $\otimes$, получаем, что $T^{A, k - 1}[i, j].\textit{left} = (T^{B, k - 1} \cdot T^{C, k - 1})[i, j].\textit{left}$ и $T^{A, k - 1}[i, j].\textit{right} = (T^{B, k - 1} \cdot T^{C, k - 1})[i, j].\textit{right}$. Таким образом, по определению отношения частичного порядка $\preceq_{\textit{single}}$, $T^{A, k - 1}[i, j] \preceq_{\textit{single}} T^{A, k}[i, j]$, что доказывает завершаемость алгоритма для задачи поиска одного пути.

\textit{Задача поиска всех путей.} По определению операции $\oplus$ полукольца над множеством троек $\textit{AllPathIndex}$, значение в ячейке $T^A[i, j]$ может изменится только если $T^{A, k - 1}[i, j] = \bot$ или $(T^{A, k - 1}[i, j].\textit{middles} \subseteq T^{A, k}[i, j].\textit{middles})$. Если $T^{A, k - 1}[i, j] = \bot$, то утверждение теоремы доказано по определению отношения частичного порядка $\preceq_{\textit{all}}$. Иначе по определениям операции умножения матриц $(\cdot)$ и операции умножения элементов матриц $\otimes$, получаем, что $T^{A, k - 1}[i, j].\textit{left} = (T^{B, k - 1} \cdot T^{C, k - 1})[i, j].\textit{left}$ и $T^{A, k - 1}[i, j].\textit{right} = (T^{B, k - 1} \cdot T^{C, k - 1})[i, j].\textit{right}$. Таким образом, по определению отношения частичного порядка $\preceq_{\textit{all}}$, $T^{A, k - 1}[i, j] \preceq_{\textit{all}} T^{A, k}[i, j]$, что доказывает завершаемость алгоритма для задачи поиска всех путей.

Во-вторых, докажем корректность алгоритма для предложенных алгебраических структур, показав, что они удовлетворяют следующим свойствам, указанным в условии леммы~\ref{lemma:correct_mtx}.% Пусть была использована алгебраическая структура $\langle \textit{MatrixElements}, \oplus, \otimes, \bot \rangle$, тогда для любых элементов $\alpha_1, \alpha_2 \in \textit{MatrixElements}$:
%	\begin{itemize}
%	    \item алгебраическая структура $\langle \textit{MatrixElements}, \oplus, \otimes, \bot \rangle$ является полукольцом без требования ассоциативности операции $\otimes$;
%	    \item выделенные элементы $\alpha^l_{i, j} \in \textit{MatrixElements}$, использованные в строках 4--8 алгоритма, позволяют корректно решить поставленную задачу для множеств путей графа $\mathcal{G}$ из вершины $i$ в вершину $j$ длины $l$, где $l \in \{0, 1\}$;
%	    \item если элементы $\alpha_1$ и $\alpha_2$ позволяют корректно решить поставленную задачу для множеств путей $\mathcal{P}_1$ и $\mathcal{P}_2$ из вершины $i$ в вершину $j$, то элемент $\alpha_1 \oplus \alpha_2$ позволяет корректно решить поставленную задачу для множества путей $\mathcal{P}_1 \cup \mathcal{P}_2$;
%	    \item если элементы $\alpha_1$ и $\alpha_2$ позволяют корректно решить поставленную задачу для множества путей $\mathcal{P}_1$ из вершины $i$ в вершину $k$ и для множества $\mathcal{P}_2$ путей из вершины $k$ в вершину $j$, то элемент $\alpha_1 \otimes \alpha_2$ позволяет корректно решить поставленную задачу для множества путей $\mathcal{P}_1 \cdot \mathcal{P}_2$ всех возможных конкатенаций путей из этих множеств.
%	\end{itemize}
	

Все три предложенные алгебраические структуры являются полукольцами без требования ассоциативности операции умножения. Осталось показать справедливость свойств для элементов $\alpha^l_{i, j}$ и для операций сложения и умножения предложенных структур.

\textit{Задача достижимости.} В предложенной алгебраической структуре для задачи достижимости были выделены элементы $\alpha^0_{i, j} = \alpha^1_{i, j} = 1$, которые используются в алгоритме, представленном на листинге~\ref{lst:mtx_cfpq}, в случае существования пути из $\mathcal{P}_{\mathcal{G}, 1}(i, j, A)$ для некоторого нетерминала $A \in N$. Если такого пути не существует, то в соответствующей ячейке будет значение $\bot = 0$. Таким образом, элементы $\alpha^0_{i, j}$ и $\alpha^1_{i, j}$ позволяют определить наличие путей длины 0 или 1, удовлетворяющих заданным КС-ограничениям, что доказывает соответствующее свойство алгебраической структуры $\langle \{0, 1\}, \vee, \wedge, 0\rangle$. Справедливость свойства для операции $\oplus$ очевидна, так как $\alpha_1 \vee \alpha_2 = 1$ только если существует хотя бы один искомый путь в множестве $\mathcal{P}_1$ или в множестве $\mathcal{P}_2$, что эквивалентно решению задачи для множества $\mathcal{P}_1 \cup \mathcal{P}_2$. И, наконец, если элементы $\alpha_1$ и $\alpha_2$ позволяют корректно решить задачу достижимости для множества путей $\mathcal{P}_1$ из вершины $i$ в вершину $k$ и для множества $\mathcal{P}_2$ путей из вершины $k$ в вершину $j$, то элемент $\alpha_1 \wedge \alpha_2 = 1$, только если существовал хотя бы один искомый путь в множестве $\mathcal{P}_1$ и хотя бы одни искомый путь в множестве $\mathcal{P}_2$. Конкатенация таких путей является искомым путём из вершины $i$ в вершину $j$, поэтому значение $\alpha_1 \wedge \alpha_2$ позволит решить задачу для множества путей $\mathcal{P}_1 \cdot \mathcal{P}_2$.

\textit{Задача поиска одного пути.} Рассмотрим предложенную структуру $\langle \textit{PathIndex}, \oplus, \otimes, \bot \rangle$ для задачи поиска одного пути. Для корректного решения поставленной задачи будем использовать элемент $\bot = (0, 0, 0, 0) \in \textit{PathIndex}$ для индикации отсутствия искомых путей и элемент $(\textit{left}, \textit{right}, \textit{middle}, \textit{height}) \in \textit{PathIndex}$ если существует искомый путь $\pi$ из вершины $\textit{left}$ в вершину $\textit{right}$, с некоторой выделенной вершиной $\textit{middle}$ и $\textit{height}$~--- минимальной высотой дерева вывода строки $\lambda(\pi)$ для соответствующего нетерминала грамматики. Остальные свойства следуют из построения этой алгебраической структуры в разделе~\ref{sec:ch3/sect1}:
\begin{itemize}
        \item выделенные элементы $\alpha^0_{i, i} = (i, i, i, 1)$ и $\alpha^1_{i, j} = (i, j, i, 1)$ описывают искомые пути длины 0 или 1 с высотой дерева вывода 1, если такие пути существуют;
	    \item если элементы $\alpha_1$ и $\alpha_2$ описывают искомые пути с минимальной высотой дерева вывода для множеств путей $\mathcal{P}_1$ и $\mathcal{P}_2$ из вершины $i$ в вершину $j$, то элемент $\alpha_1 \oplus \alpha_2$ описывает искомый путь с минимальной высотой дерева вывода для множества путей $\mathcal{P}_1 \cup \mathcal{P}_2$;
	    \item если элементы $\alpha_1$ и $\alpha_2$ описывают искомые пути с минимальной высотой дерева вывода для множества путей $\mathcal{P}_1$ из вершины $i$ в вершину $k$ и для множества $\mathcal{P}_2$ путей из вершины $k$ в вершину $j$, то элемент $\alpha_1 \otimes \alpha_2$ описывает искомый путь с минимальной высотой дерева вывода для множества путей $\mathcal{P}_1 \cdot \mathcal{P}_2$.
	\end{itemize}

\textit{Задача поиска всех путей.} Для задачи поиска всех путей с заданными КС-ограничениями в предложенной структуре $\langle \textit{AllPathIndex}, \oplus, \otimes, \bot \rangle$ используется элемент $\bot = (0, 0, \emptyset) \in \textit{AllPathIndex}$ для индикации отсутствия искомых путей и элемент $(\textit{left}, \textit{right}, \textit{middles}) \in \textit{AllPathIndex}$ если существуют искомые пути $\pi$ из вершины $\textit{left}$ в вершину $\textit{right}$, с некоторой выделенной вершиной $\textit{middle} \in \textit{middles}$. Остальные свойства следуют из построения этой алгебраической структуры в разделе~\ref{sec:ch3/sect1}:
\begin{itemize}
        \item с использованием специального значения $n = |V|$ в множестве $\textit{middles}$ выделенные элементы $\alpha^0_{i, j} = \alpha^1_{i, j} = (i, j, \{n\})$ описывают все искомые пути длины 0 или 1;
	    \item если элементы $\alpha_1$ и $\alpha_2$ описывают все искомые пути для множеств путей $\mathcal{P}_1$ и $\mathcal{P}_2$ из вершины $i$ в вершину $j$, то элемент $\alpha_1 \oplus \alpha_2$ описывает все искомые пути для множества путей $\mathcal{P}_1 \cup \mathcal{P}_2$;
	    \item если элементы $\alpha_1$ и $\alpha_2$ описывают все искомые пути для множества путей $\mathcal{P}_1$ из вершины $i$ в вершину $k$ и для множества $\mathcal{P}_2$ путей из вершины $k$ в вершину $j$, то элемент $\alpha_1 \otimes \alpha_2$ описывает все искомые пути для множества путей $\mathcal{P}_1 \cdot \mathcal{P}_2$.
	\end{itemize}
	
Таким образом, для всех трёх предложенных в разделе~\ref{sec:ch3/sect1} алгебраических структур для задач достижимости, поиска одного и поиска всех путей в графе с заданными КС-ограничениями справедливы теоремы~\ref{thm:finite_mtx} и \ref{thm:correct_mtx}.

\section{Временная сложность алгоритма}\label{sec:ch3/sect3}
В данном разделе представлены оценки временной сложности предложенного алгоритма для рассмотренных задач поиска путей в графе.

Пусть для алгоритма, представленного на листинге~\ref{lst:mtx_cfpq} была выбрана алгебраическая структура $\langle \textit{MatrixElements}, \oplus, \otimes, \bot \rangle$ с конечным носителем $\textit{MatrixElements}$ и с заданным на нём отношением частичного порядка $\preceq$ таким, что для любой пары вершин $(i, j)$ и любого $k \geq 1$, $T^{A, k - 1}[i, j] \preceq T^{A, k}[i, j]$. Тогда по теореме~\ref{thm:finite_mtx} алгоритм завершит свою работу за конечное число шагов. Пусть $N_{\textit{iter}}$~---  максимальное количество итераций цикла в строках 9--11 алгоритма, представленного на листинге~\ref{lst:mtx_cfpq}. Стоит отметить, что значение $N_{\textit{iter}}$ зависит от выбранной алгебраической структуры. 

Также предположим, что все операции над элементами из множества $\textit{MatrixElements}$ вычисляются за $O(1)$ элементарных операций. Кроме того, для использованной алгебраической структуры оценим количество элементарных операций, необходимых в худшем случае для вычисления операций над матрицами размера $n \times n$, как:

\begin{itemize}
    \item $O(n^2)$~--- для операции $\bigoplus$ поэлементного сложения двух матриц,
    \item $O(n^3)$~--- для операции $(\cdot)$ умножения двух матриц.
\end{itemize}

Стоит отметить, что данные оценки могут быть улучшены для алгебраических структур, обладающих некоторыми свойствами. Например, существует алгоритм с субкубической сложностью $O(n^{3 - \varepsilon})$, где $\varepsilon > 0$, для таких алгебраических структур, как кольца~\cite{strassen1969gaussian}.

С учётом сделанных предположений справедлива следующая оценка временной сложности алгоритма поиска путей в графе с заданными КС-ограничениями.

\begin{theorem}[Оценка временной сложности алгоритма поиска путей]\label{thm:time_mtx}
	Пусть $\mathcal{G} = \langle V, E, L \rangle$~--- входной граф, $G =\langle N, \Sigma, P, S \rangle$~--- входная КС-грамматика. Тогда для алгоритма, представленного на листинге~\ref{lst:mtx_cfpq}, справедлива следующая оценка временной сложности: $O(|N||P||V|^5)$.
\end{theorem}
\begin{proof}
На этапе инициализации матриц алгоритм производит запись значений в ячейки этих матриц. В строке 5 производится операция записи $O(|E|)$ раз, а в строке 8~--- $O(|V||N|)$ раз. Поэтому для всех задач поиска путей в графе на этапе инициализации производится $O(|E|+|V||N|)$ элементарных операций. 

Далее рассмотрим цикл в строках 9--11, вычисляющий транзитивное замыкание. Алгоритм продолжает вычисления пока любая матрица из множества $T$ меняется. Всего матриц в этом множестве $|N|$ и каждая имеет $|V|^2$ элементов. Из-за свойств трёх предложенных алгебраических структур значения ячеек матриц монотонно возрастают относительно соответствующего отношения частичного порядка. Далее рассмотрим максимальное количество итераций $N_{\textit{iter}}$, которое может возникнуть при решении различных задач поиска путей в графе.

\textit{Задача достижимости и задача поиска одного пути.} С каждой итерацией цикла в строках 9--11 увеличивается на единицу рассматриваемые высоты деревьев вывода строк, соответствующих путям в графе. Для задач достижимости и поиска одного пути значение конкретной ячейки может изменится лишь в рамках одной итерации цикла в строках 9--11. Поэтому максимальное количество итераций рассматриваемого цикла может быть достигнуто в случае, когда за каждую итерацию цикла изменяется значение лишь одной ячейки в одной матрице. Для задачи достижимости значение может изменится с $\bot = 0$ на 1, а для задачи поиска одного пути значение либо изменяется с $\bot = (0, 0, 0, 0)$ на четвёрку, описывающую некоторый найденный на данной итерации путь, либо значение для найденного пути изменяется на значение для другого пути с меньшим номером промежуточной вершины $\textit{middle}$. В рамках одной итерации цикла в строках 9--11 операции в строке 11 выполняются $O(|P|)$ раз. Поэтому для задач достижимости и поиска одного пути справедлива следующая оценка временной сложности: $O(N_{\textit{iter}} |P||V|^3)$, где максимальное количество итераций цикла в строках 9--11 $N_{\textit{iter}} = |N||V|^2$.

\textit{Задача поиска всех путей.} Для данной задачи докажем, что количество итераций цикла в строках 9--11 превышает максимальное количество таких итераций при решении задачи поиска одного пути не более чем на 1, то есть всегда меньше либо равно, чем $|N||V|^2 + 1$. Для этого покажем, что изменения значения в одной из матриц на итерации с номером $k$ для задачи поиска всех путей влечёт за собой тот факт, что при решении с такими же входными данными задачи поиска одного пути значение в одной из матриц изменится на итерации с номером $k$ или $k - 1$.

Аналогично уже рассмотренным задачам, для задачи поиска всех путей с каждой итерацией цикла в строках 9--11 увеличивается на единицу рассматриваемые высоты деревьев вывода строк, соответствующих путям в графе. Пусть на итерации с номером $k$ изменилось значение в ячейке $T^{A}[i, j]$ после обнаружения путей из вершины $i$ в вершину $j$, образующих строки, выводимые из нетерминала $A$ и имеющие деревья вывода высоты $k + 1$. Это могло произойти в двух случаях: либо $T^{A, k - 1}[i, j] = \bot$ и $k + 1$~--- минимальная высота деревьев вывода для таких путей, либо $T^{A, k - 1}[i, j] = (i, j, \textit{middles}) \neq \bot$ и был найден хотя бы один путь $\pi$ с выделенной промежуточной вершиной $m \notin \textit{middles}$. В первом случае, на такой же итерации будет изменено значение в ячейке $T^{A}[i, j]$ при решении задачи поиска одного пути, поэтому $k \leq |N||V|^2$. Больший интерес представляет собой второй случай, который рассмотрим подробнее. Так как $m \notin \textit{middles}$, то $k + 1$~--- минимальная высота деревьев вывода для путей из вершины $i$ в вершину $j$ с выделенной промежуточной вершиной $m$, образующих строки, выводимые из нетерминала $A$. Пусть такое дерево вывода минимальной высоты образовано с использованием на корневом уровне правила вывода $(A \to B \ C) \in P$, где путь $i \pi j$~--- конкатенация путей $i \pi_1 m$ и $m \pi_2 j$, а $B \Rightarrow_G \lambda(\pi_1)$ и $C \Rightarrow_G \lambda(\pi_2)$. Тогда хотя бы одна из строк $\lambda(\pi_1)$ или $\lambda(\pi_2)$ имеет минимальную высоту дерева вывода из соответствующего нетерминала равную $k$. Иначе можно было бы построить дерево вывода строки $\lambda(\pi)$ с высотой меньшей, чем $k + 1$. Таким образом, на предыдущей итерации цикла с номером $k - 1$ был найден хотя бы один путь с минимальной высотой дерева вывода из соответствующего нетерминала и изменилось значение в ячейке $T^{B}[i, m]$ или в ячейке $T^{C}[m, j]$. Значения в этих ячейках также изменятся на $k - 1$ итерации цикла при решении задачи поиска одного пути. Таким образом, для решения задачи поиска одного пути потребуется не менее $k - 1$ итерации, а из уже доказанной оценки сверху на количество таких итераций получаем, что $k - 1 \leq |N||V|^2$ и, значит, $k \leq |N||V|^2 + 1$.

Мы показали, что при решении задачи поиска всех путей количество итераций в цикле не превышает $|N||V|^2 + 1$ и поэтому асимптотически для задачи поиска всех путей справедлива оценка, полученная для предыдущих двух задач, а именно: $O(|N||P||V|^5)$.
\end{proof}

Следует отметить что приведённая оценка временной сложности алгоритма, представленного на листинге~\ref{lst:mtx_cfpq}, может быть существенно улучшена для некоторых алгебраических структур или для разреженных графов. Однако в общем случае полученные оценки временной сложности алгоритма являются точными, так как существует пример графа и КС-грамматики, при которых эти оценки временной сложности достигаются. Впервые такой пример опубликовал Джелле Хеллингс в работе~\cite{hellings2015querying}. В этом примере используется граф, схожий с графом $\mathcal{G}_1$, изображённым на~\cref{fig:example_graph}, однако имеющий $2^n + 1$ дуг с меткой $a$ и $2^n$ дуг с меткой $b$. А используемая КС-грамматика порождает язык $\mathcal{L} = \{a^nb^n \mid n \geq 1\}$. Взаимная простота длин двух циклов в этом графе приводит к тому, что минимальная высота дерева вывода путей из вершины 0 в вершину 0, удовлетворяющих заданным КС-ограничениям~--- $O(|V|^2)$. Пример работы предложенного алгоритма на частном случае таких графов будет рассмотрен в следующем разделе.

Далее, используя индукцию на минимальные высоты деревьев вывода, соответствующих восстанавливаемому пути с помощью алгоритма, представленного на листинге~\ref{lst:mtx_single_extract}, может быть доказана следующая теорема.

\begin{theorem}[Оценка временной сложности алгоритма восстановления одного пути]\label{thm:time_single_mtx}
	Пусть $\mathcal{G} = \langle V, E, L \rangle$~--- входной граф, $G = \langle N, \Sigma, P, S \rangle$~--- входная КС-грамматика и $T$~--- множество матриц, возвращаемое алгоритмом, представленным на листинге~\ref{lst:mtx_cfpq}, с использованием алгебраической структуры, соответствующего задаче поиска одного пути. Тогда для алгоритма, представленного на листинге~\ref{lst:mtx_single_extract}, справедлива следующая оценка временной сложности: $O(d|N|^2)$, где $d$~--- количество вершин в дереве вывода минимальной высоты для восстановленного алгоритмом пути.
\end{theorem}

В данной работе временная сложность алгоритма, представленного на листинге~\ref{lst:mtx_all_extract}, не приводится, так как она зависит от конкретного способа ограничения количества восстанавливаемых путей и построения соответствующих множеств искомых путей.

\section{Пример}\label{sec:ch3/sect4}

В данном разделе работа изложенного алгоритма продемонстрирована на примере, основанном на КС-языке правильных вложенных скобочных последовательностей.

Пусть даны граф $\mathcal{G}_1$, изображённый на~\cref{fig:example_graph} и КС-ограничения в виде КС-языка $\mathcal{L} = \{a^nb^n \mid n \geq 1\}$. Представим данный КС-язык в виде КС-грамматики $G$ в ослабленной нормальной форме Хомского со следующими правилами вывода.
	\[
	\begin{array}{rcclcrccl}
	0: & S & \rightarrow & A \ B   & \quad & 3: & A & \rightarrow & \text{\emph{a}}     \\
	1: & S & \rightarrow & A \ S_1       & \quad & 4: & B & \rightarrow & \text{\emph{b}} \\
	2: & S_1 & \rightarrow & S \ B & & & & &
	
	\end{array}
	\]

Далее разберём работу алгоритма, представленного на листинге~\ref{lst:mtx_cfpq}, для задачи достижимости, поиска одного и поиска всех путей.

\paragraph{Задача достижимости.} Для рассматриваемых графа и КС-грамматики алгоритм, представленный на листинге~\ref{lst:mtx_cfpq}, инициализирует множество матриц $T$, изображенных на~\cref{ExampleQueryInitMatrix}.


\begin{figure}[h]
	\[
	T^{A, 0} = \begin{pmatrix}
	0 & 1      & 0 & 0       \\
	0 & 0 & 1       & 0 \\
	1       & 0 & 0 & 0 \\
	0       & 0 & 0 & 0 \\
	\end{pmatrix}
	\]
	\[
	T^{B, 0} = \begin{pmatrix}
	0 & 0       & 0 & 1      \\
	0 & 0 & 0       & 0 \\
	0       & 0 & 0 & 0 \\
	1      & 0 & 0 & 0 \\
	\end{pmatrix}
	\]
	\caption{Множество матриц $T$ после инициализации для задачи достижимости (элементы $T^{S_1, 0}[i, j]$ и $T^{S, 0}[i, j]$ равны $\bot = 0$ для всех $i, j$)}
	\label{ExampleQueryInitMatrix}
\end{figure}

Так как в заданной грамматике отсутствуют правила вида $A \rightarrow \varepsilon$, то алгоритм переходит к выполнению цикла в строках 9--11. Далее в процессе работы алгоритма будут меняться только матрицы $T^{S}$ и $T^{S_1}$. После первой итерации цикла все элементы матрицы $T^{S_1, 1}$ останутся равны $0$, а элементы матрицы $T^{S, 1}$ изображены на~\cref{ExampleQueryFirstIteration}. При нахождении очередного пути на некоторой итерации алгоритм добавляет информацию о достижимости в соответствующую матрицу. Например, на первой итерации цикла был найден путь $2 \pi 3 = (2, a, 0), (0, b, 3)$, образующий строку $\lambda(\pi) = ab$, выводимую из нетерминала $S$. Информация о достижимости вершины 3 из вершины 2 добавляется в ячейку $T^{S, 1}[2, 3]$. 


\begin{figure}[h]
\[
T^{S,1} = T^{S, 0} \bigoplus (T^{A, 0} \cdot T^{B, 0}) = \begin{pmatrix}
	0 & 0     & 0 & 0       \\
	0 & 0 & 0  & 0 \\
	0       & 0 & 0 & 1 \\
	0       & 0 & 0& 0\\
\end{pmatrix}
\]
\caption{Элементы матрицы $T^{S, 1}$, полученные после первой итерации для задачи достижимости}
\label{ExampleQueryFirstIteration}
\end{figure}

Для полного обхода графа в соответствии с входной КС-грамматикой этот процесс повторяется, пока добавляется новая информация хотя бы в одну из матриц. В данном примере алгоритм выполнит 13 итераций цикла, после чего завершит свою работу. Результирующая матрица $T^{S, 13}$ представлена на~\cref{ExampleQueryFinalMatrices}.

{\footnotesize
\begin{figure}[h]
	\[
	T^{S, 13} = \begin{pmatrix}
	1 & 0     & 0 & 1       \\
	1 & 0 & 0   & 1 \\
	1       & 0 & 0 & 1 \\
	0       & 0 & 0 & 0 \\
	\end{pmatrix}
	\]
	\caption{Элементы результирующей матрицы $T^{S, 13}$ для задачи достижимости}
	\label{ExampleQueryFinalMatrices}
\end{figure}
}

Наконец, после работы алгоритма можно использовать получившуюся матрицу для построения множества пар вершин, являющегося ответом на задачу достижимости в графе с заданными КС-ограничениями. В данном примере этим множеством является $\{(0, 0), (0, 3), (1, 0), (1, 3), (2, 0), (2, 3)\}$.


\paragraph{Задача поиска одного пути.} Аналогично задаче достижимости, продемонстрируем работу алгоритма, представленного на листинге~\ref{lst:mtx_cfpq}, для задачи поиска одного пути, при которой используется соответствующее полукольцо $\langle \textit{PathIndex}, \oplus, \otimes, \bot \rangle$, где $\bot = (0, 0, 0, 0)$. Алгоритм инициализирует множество матриц $T$, изображенных на~\cref{ExampleQueryInitMatrixSingle}.

{\footnotesize
\begin{figure}[h]
	\[
	T^{A, 0} = \begin{pmatrix}
	\bot & (0, 1, 0, 1)       & \bot & \bot       \\
	\bot & \bot & (1, 2, 1, 1)       & \bot \\
	(2, 0, 2, 1)       & \bot & \bot & \bot \\
	\bot       & \bot & \bot & \bot \\
	\end{pmatrix}
	\]
	\[
	T^{B, 0} = \begin{pmatrix}
	\bot & \bot       & \bot & (0, 3, 0, 1)       \\
	\bot & \bot & \bot       & \bot \\
	\bot       & \bot & \bot & \bot \\
	(3, 0, 3, 1)      & \bot & \bot & \bot \\
	\end{pmatrix}
	\]
	\caption{Множество матриц $T$ после инициализации для задачи поиска одного пути (элементы $T^{S_1, 0}[i, j]$ и $T^{S, 0}[i, j]$ равны $\bot = (0, 0, 0, 0)$ для всех $i, j$)}
	\label{ExampleQueryInitMatrixSingle}
\end{figure}
}

Как и в случае решения задачи достижимости, далее в процессе работы алгоритма будут меняться только матрицы $T^{S}$ и $T^{S_1}$. После первой итерации цикла в строках 9--11 все элементы матрицы $T^{S_1, 1}$ останутся равны $\bot$, а элементы матрицы $T^{S, 1}$ изображены на~\cref{ExampleQueryFirstIterationSingle}. В отличие от предыдущего случая, при решении задачи поиска одного пути в матрицу добавляется информация не только о достижимости, но и о конечных вершинах пути, одной из его промежуточных вершин, а также о высоте соответствующего дерева вывода. Например, на первой итерации цикла был найден путь $2 \pi 3 = (2, a, 0), (0, b, 3)$, образующий строку $\lambda(\pi) = ab$, выводимую из нетерминала $S$. В ячейку $T^{S, 1}[2, 3]$ записывается значение $(2, 3, 0, 2)$, так как был найден путь из вершины 2 в вершину 3, с промежуточной вершиной 0 и с деревом вывода строки $\lambda(\pi) = ab$ высоты 2, изображенного на~\cref{treeExample}.

{\footnotesize
\begin{figure}[h]
	\[
	T^{S,1} = T^{S, 0} \bigoplus (T^{A, 0} \cdot T^{B, 0}) = \begin{pmatrix}
	\bot & \bot       & \bot & \bot       \\
	\bot & \bot & \bot       & \bot \\
	\bot       & \bot & \bot & (2, 3, 0, 2) \\
	\bot       & \bot & \bot & \bot \\
	\end{pmatrix}
	\]
	\caption{Элементы матрицы $T^{S, 1}$, полученные после первой итерации для задачи поиска одного пути}
	\label{ExampleQueryFirstIterationSingle}
\end{figure}
}

	\begin{figure}[h!]
	\begin{center}
		\begin{tikzpicture}[on grid, auto]
		\node[state] (q_0)   {$S$};
		\node[state] (q_1) [below left=2cm and 1.5cm of q_0] {$A$};
		\node[state] (q_2) [below right= 2cm and 1.5cm of q_0] {$B$};
		\node[state] (q_3) [below=2.0cm of q_1] {$a$};
		\node[state] (q_4) [below=2.0cm of q_2] {$b$};
		\path[->]
		(q_0) edge  node {} (q_1)
		(q_0) edge  node {} (q_2)
		(q_1) edge  node {} (q_3)
		(q_2) edge  node {} (q_4);
		\end{tikzpicture}
	\end{center}
	\caption{Дерево вывода из нетерминала $S$ для строки $\lambda(\pi) = ab$ минимальной высоты $h = 2$}
	\label{treeExample}
    \end{figure}

Как и при решении задачи достижимости алгоритм выполнит 13 итераций цикла в строках 9--11, после чего завершит свою работу. Результирующая матрица $T^{S, 13}$ для задачи поиска одного пути представлена на~\cref{ExampleQueryFinalMatricesSingle}.

{\footnotesize
\begin{figure}[h]
	\[
	T^{S, 13} = \begin{pmatrix}
	(0, 0, 1, 12) & \bot       & \bot & (0, 3, 1, 6)       \\
	(1, 0, 2, 4) & \bot & \bot       & (1, 3, 2, 10) \\
	(2, 0, 0, 8)       & \bot & \bot & (2, 3, 0, 2) \\
	\bot       & \bot & \bot & \bot \\
	\end{pmatrix}
	\]
	\caption{Элементы результирующей матрицы $T^{S, 13}$ для задачи поиска одного пути}
	\label{ExampleQueryFinalMatricesSingle}
\end{figure}
}

Построенные матрицы также содержат информацию о достижимости, поэтому аналогично может быть построено множество пар вершин $\{(0, 0), (0, 3), (1, 0), (1, 3), (2, 0), (2, 3)\}$, которое является ответом на задачу достижимости с заданными КС-ограничениями. Однако построенные матрицы также содержат информацию, достаточную для построения по одному пути, соответствующему заданным ограничениям, для каждой пары вершин из этого множества. Для этого может быть использован алгоритм, представленный на листинге~\ref{lst:mtx_single_extract}. Например, для восстановления такого пути из вершины 0 в вершину 0 необходимо передать этому алгоритму на вход: начальную и конечную вершины $i = j = 0$; $S$~--- стартовый нетерминал грамматики; результирующие матрицы для всех нетерминалов, вычисленные алгоритмом, представленным на листинге~\ref{lst:mtx_cfpq}; а также КС-ограничения в виде грамматики $G$. Тогда алгоритм, представленный на листинге~\ref{lst:mtx_single_extract}, вернёт путь $0\pi 0$, для которого $\lambda(\pi) = a^6 b^6$. Минимальная высота дерева вывода такой строки из стартового нетерминала $S$ равна 12, что соответствует значению $(0, 0, 1, 12)$, записанному в ячейке $T^{S, 13}[0, 0]$.


\paragraph{Задача поиска всех путей.} Аналогично предыдущим двум задачам, предоставим состояния матриц из множества $T$ для задачи поиска всех путей и полукольца $\langle \textit{AllPathIndex}, \oplus, \otimes, \bot \rangle$, где $\bot = (0, 0, \emptyset)$. Множество матриц $T$ после инициализации изображено на~\cref{ExampleQueryInitMatrixAll} (в процессе инициализации матриц вместо промежуточных вершин используется специальное значение 4 = $|V|$, сигнализирующее о том, что длина найденного пути равна 0 или 1). Элементы матрицы $T^{S, 1}$, полученные после первой итерации цикла в строках 9--11 изображены на~\cref{ExampleQueryFirstIterationAll}. И, наконец, результирующая матрица $T^{S, 13}$ для задачи поиска всех путей представлена на~\cref{ExampleQueryFinalMatricesAll}.

{\small
	\begin{figure}[h]
		\[
		T^{A, 0} = \begin{pmatrix}
			\bot & (0, 1, \{4\})       & \bot & \bot       \\
			\bot & \bot & (1, 2, \{4\})       & \bot \\
			(2, 0, \{4\})       & \bot & \bot & \bot \\
			\bot       & \bot & \bot & \bot \\
		\end{pmatrix}
		\]
		\[
		T^{B, 0} = \begin{pmatrix}
			\bot & \bot       & \bot & (0, 3, \{4\})       \\
			\bot & \bot & \bot       & \bot \\
			\bot       & \bot & \bot & \bot \\
			(3, 0, \{4\})      & \bot & \bot & \bot \\
		\end{pmatrix}
		\]
		\caption{Множество матриц $T$ после инициализации для задачи поиска всех путей (элементы $T^{S_1, 0}[i, j]$ и $T^{S, 0}[i, j]$ равны $\bot = (0, 0, \emptyset)$ для всех $i, j$)}
		\label{ExampleQueryInitMatrixAll}
	\end{figure}
}

{\small
	\begin{figure}[h]
		\[
		T^{S, 1} = \begin{pmatrix}
			\bot & \bot       & \bot & \bot       \\
			\bot & \bot & \bot       & \bot \\
			\bot       & \bot & \bot & (2, 3, \{0\}) \\
			\bot       & \bot & \bot & \bot \\
		\end{pmatrix}
		\]
		\caption{Элементы матрицы $T^{S, 1}$, полученные после первой итерации для задачи поиска всех путей}
		\label{ExampleQueryFirstIterationAll}
	\end{figure}
}

{\small
	\begin{figure}[h]
		\[
		T^{S, 13} = \begin{pmatrix}
			(0, 0, \{1\}) & \bot       & \bot & (0, 3, \{1\})       \\
			(1, 0, \{2\}) & \bot & \bot       & (1, 3, \{2\}) \\
			(2, 0, \{0\})       & \bot & \bot & (2, 3, \{0\}) \\
			\bot       & \bot & \bot & \bot \\
		\end{pmatrix}
		\]
		\caption{Элементы результирующей матрицы $T^{S, 13}$ для задачи поиска всех путей}
		\label{ExampleQueryFinalMatricesAll}
	\end{figure}
}

Можем заметить, что для данного примера в результирующей матрице $T^S$ нету элементов с более чем одной промежуточной вершиной. Поэтому полученная матрица очень схожа с соответствующей матрицей для задачи поиска одного пути, но без наличия информации о высотах деревьев вывода. Однако в общем случае количество найденных промежуточных вершин для путей между двумя вершинами может быть больше одного. После построения алгоритмом таких матриц известно, что они содержат все такие промежуточные вершины, поэтому с помощью алгоритма, представленного на листинге~\ref{lst:mtx_all_extract}, могут быть восстановлены все пути, удовлетворяющие заданным КС-ограничениям. Например, могут быть восстановлены все пути из вершины 0 в вершину 0, образующие строки из языка $\mathcal{L} = \{a^nb^n \mid n \geq 1\}$. Множество таких путей бесконечно и они образуют слова из множества $\{a^6 b^6, a^{12} b^{12}, a^{18} b^{18}, \ldots \}$. Для любого $m \geq 1$, путь, образующий строку $a^{6m} b^{6m}$, проходит по циклу с метками $a$ $2m$ раз и по циклу с метками $b$~--- $3m$ раз. При реализации алгоритма восстановления всех путей необходимо ограничивать количество восстанавливаемых путей и добавить соответствующий входной параметр в алгоритм.

Таким образом, была продемонстрирована работа изложенного алгоритма поиска путей в графе с заданными КС-ограничениями.

\section{Реализация}\label{sec:ch3/sect5}
В данном разделе приведены детали реализации полученного алгоритма поиска путей в графе с заданными КС-ограничениями с использованием операций умножения матриц. Все перечисленные в разделе реализации находятся в открытом доступе в рамках платформы $\textit{CFPQ\_PyAlgo}\footnote{CFPQ\_PyAlgo~--- платформа для разработки и тестирования алгоритмов поиска путей в графе с заданными КС-ограничениями: https://github.com/JetBrains-Research/CFPQ\_PyAlgo (дата обращения: 14.01.2022).}$.

При реализации предложенного алгоритма учитывались особенности реальных графов в таких областях, как анализ RDF данных и статический анализ программ. Такие графы имеют довольно большие размеры (до десятков миллионов вершин), однако являются разреженными (имеют до десятков миллионов дуг). Для графов таких размеров целесообразно использовать параллельные вычислительные системы, так как время, затраченное на организацию параллельных вычислений (например, обмен данными между CPU и GPU) будет незначителен в сравнении с временем самого анализа. Поэтому обязательными атрибутами реализаций являются: использование параллельных вычислений и представление матриц с помощью разреженных форматов. Так как рассматриваемые графы не являются сильно разреженными, то для хранения разреженных матриц был выбран формат CSR. Далее будут описаны полученные реализации предложенного алгоритма.

\paragraph{Задача достижимости.} Для решения задачи достижимости были использованы операции умножения и сложения над набором булевых матриц. А для реализации данного алгоритма были выбраны библиотеки для параллельного вычисления этих операций над разреженными булевыми матрицами на CPU и GPU. Реализация на CPU была создана с использованием библиотеки SuiteSparse:GraphBLAS, а для реализации на GPU~--- с использованием библиотеки cuBool. Стоит отметить, что библиотека SuiteSparse:GraphBLAS содержит встроенные алгебраические структуры, которые могут быть использованы для вычисления операций над булевыми матрицами. В результате были получены следующие реализации:
\begin{itemize}
    \item $\textit{MtxReach}_{\textit{CPU}}$~--- на языке \texttt{Python} с использованием пакета pygraphblas, являющегося обёрткой для библиотеки SuiteSparse:GraphBLAS;
    \item $\textit{MtxReach}_{\textit{GPU}}$~--- на языке \texttt{Python} с использованием пакета pycubool, являющегося обёрткой для библиотеки cuBool.
\end{itemize}

Для решения остальных задач поиска путей в графе с заданными КС-ограничениями были использованы более сложные типы для элементов матриц. Это приводит к существенному увеличению затрат по памяти, что особенно критично для реализаций на GPU. Предложенный алгоритм, основанный на умножении матриц, для задач поиска одного и всех путей в графе может быть реализован на GPU, например, с использованием библиотеки CUSP, которая позволяет вычислять операции над матрицами с пользовательским типом данных. Однако для апробации таких реализаций на реальных данных необходимо проведение дальнейших исследований по оптимизации предложенного алгоритма и использованных алгебраических структур для задач поиска одного и всех путей в графе. Особое внимание в таком исследовании необходимо уделить затратам по памяти предложенного алгоритма и деталям реализации вычисления на GPU операций над матрицами в конкретной выбранной библиотеке. В данной работе предложенный алгоритм для задач поиска одного и всех путей был реализован только на CPU.

\paragraph{Задача поиска одного пути.} Алгоритм для решения задачи поиска одного пути был также реализован с использованием библиотеки SuiteSparse:GraphBLAS. Однако вместо использования одной из встроенных алгебраических структур, для вычисления операций над матрицами в этом алгоритме необходимо определить пользовательский тип данных и операции над ними, соответствующие приведённой для этой задачи структуре $\langle \textit{PathIndex}, \oplus, \otimes, \bot \rangle$. В результате была получены следующая реализация:
\begin{itemize}
    \item $\textit{MtxSingle}_{\textit{CPU}}$~--- на языке \texttt{Python} с использованием пакета pygraphblas, являющегося обёрткой для библиотеки SuiteSparse:GraphBLAS.
\end{itemize}

\paragraph{Задача поиска всех путей.} Реализация для задачи поиска всех путей была также получена с использованием библиотеки SuiteSparse:GraphBLAS. Однако пакет pygraphblas на момент написания данного текста не позволяет определить пользовательский тип данных и операции над ними, соответствующие алгебраической структуре $\langle \textit{AllPathIndex}, \oplus, \otimes, \bot \rangle$. Поэтому реализация алгоритма для поиска всех путей была написана на языке \texttt{C++} с использованием библиотеки SuiteSparse:GraphBLAS, а также для этого алгоритма была написана собственная обёртка на языке \texttt{Python}. В итоге была получена следующая реализация:
\begin{itemize}
    \item $\textit{MtxAll}_{\textit{CPU}}$~--- на языке \texttt{Python} с использованием собственной обёртки для реализации алгоритма на языке \texttt{C++}, использующей библиотеку SuiteSparse:GraphBLAS.
\end{itemize}

Кроме того, для задач поиска одного и поиска всех путей в графе были реализованы на языке \texttt{Python} алгоритмы восстановления искомых путей по информации, содержащейся в построенных матрицах. Стоит отметить, что в реализации алгоритма восстановления всех путей был дополнительно использован параметр, ограничивающий длины восстанавливаемых путей для завершаемости этого процесса.

\clearpage
