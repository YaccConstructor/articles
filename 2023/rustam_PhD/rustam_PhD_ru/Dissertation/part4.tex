\chapter{Алгоритм поиска путей в графе с заданными КС-ограничениями не требующий трансформации КС-грамматики}\label{ch:ch4}
В данной главе изложен алгоритм поиска путей в графе с заданными КС-ограничениями, который не требуют трансформации входной КС-грамматики, а также использует операции линейной алгебры для задач достижимости, поиска одного пути и поиска всех путей. Также сформулированы и доказаны утверждения о корректности и временной сложности полученного алгоритма. Кроме того, приведены детали реализаций алгоритма, а также его работа продемонстрирована на примере.

\section{Построение алгоритма}\label{sec:ch4/sect1}
В данном разделе изложен процесс построения алгоритма поиска путей в графе с заданными КС-ограничениями с использованием произведения Кронекера.

Пусть дан входной помеченный граф $\mathcal{G} = \langle V, E, L\rangle$ и входной КС-язык в качестве ограничений на пути в нём. Применимость матриц для описания графов уже была показана в предыдущей главе, однако для входных КС-ограничений в предложенных алгоритмах необходимо строить КС-грамматику и приводить её в ослабленную нормальную форму Хомского. Такое преобразование грамматики может привести как минимум к квадратичному увеличению её размера~\cite{hopcroft2001introduction}. Особенностью алгоритма, предлагаемого в данной главе является использование рекурсивных автоматов для описания входных КС-ограничений без необходимости трансформации КС-грамматики.

Известно, что любая КС-грамматика может быть представлена с помощью рекурсивного автомата~\cite{alur2005analysis}. В свою очередь рекурсивный автомат, как и конечный автомат, может быть представлен в виде графа. Поэтому КС-ограничения также могут быть выражены с помощью таких объектов линейной алгебры, как матрицы. В таком случае, задачу поиска путей в графе с заданными КС-ограничениями можно решить с помощью нахождения пересечения рекурсивного автомата, соответствующего КС-ограничениям, и конечного автомата, соответствующего входному графу. Предлагаемый алгоритм основан на обобщении алгоритма пересечения конечных автоматов. Как было показано в~\cref{sec:ch2/sec2} для ограничений в виде регулярного языка, вычислять пересечение автоматов можно с помощью произведения Кронекера, применённого к матрицам из булевых декомпозициий матриц смежности для графовых представлений этих автоматов. Таким образом, используя операцию произведения Кронекера $\times$ и операцию $\bigvee$ поэлементного сложения булевых матриц, определённые над полукольцом $\langle \{0, 1\}, \vee, \wedge, 0 \rangle$, будет построена матрица, описывающая пересечение рекурсивного автомата для КС-ограничений и конечного автомата для входного графа. Однако такой рекурсивный автомат может иметь переходы с нетерминальными символами, которые имеют специальную логику рекурсивных вызовов, что требует добавления отдельного шага~--- вычисления транзитивного замыкания построенной матрицы для обработки этих символов. После вычисления транзитивного замыкания, в граф могут быть добавлены новые дуги $(i, A, j)$ при обнаружении пути $i\pi j$, для которого $A \Rightarrow_G \lambda(\pi)$. После обновления графа процесс повторяется до сходимости.

Описанный алгоритм поиска путей в графе с заданными КС-ограничениями, использующий произведение Кронекера, представлен на листинге~\ref{lst:tensor_cfpq}. Ключевая идея алгоритма заключается в итеративном вычислении произведения Кронекера для булевой декомпозиции матриц смежности $\mathcal{M}_1$ рекурсивного автомата и булевой декомпозиции матриц смежности $\mathcal{M}_2$ входного графа с последующим вычислением транзитивного замыкания результирующей матрицы. Наиболее трудоёмкими этапами в предложенном алгоритме являются вычисления произведения Кронекера и транзитивного замыкания. Кроме того, в предложенном алгоритме используется функция $\textit{getNonterminals}$, которая по двум состояниям автомата $R$ возвращает множество нетерминальных символов, которые соответствуют переходам между этими состояниями. 

\begin{algorithm}[h]
\begin{algorithmic}[1]
\floatname{algorithm}{Листинг}
\footnotesize
\caption{Алгоритм поиска путей в графе с заданными КС-ограничениями, использующий произведение Кронекера}
\label{lst:tensor_cfpq}
\Function{KroneckerBasedCFPQ}{$\mathcal{G} = \langle V, E, L \rangle$, $G=\langle N, \Sigma, P, S \rangle$}
    % Input data preparation
   \State{$n \gets$ |V|}
    \State{$R \gets$ рекурсивный автомат для грамматики $G$ c $m$ состояниями}
    \State{$\mathcal{M}_1 \gets$ булева декомпозиция матрицы смежности для $R$ с размерами матриц $m \times m$}
    \State{$\mathcal{M}_2 \gets$ булева декомпозиция матрицы смежности для $\mathcal{G}$ с размерами матриц $n \times n$}
    %\State{$M_3 \gets$ The empty matrix}
    \State{$C_3, M_3 \gets$ пустые матрицы размера $m n \times m n$}
    % Eps-transition handling for graph
    \For{$q \in \{0,\ldots, m - 1\}$}
        \For{$A \in \textit{getNonterminals}(R, q, q)$}
            \For{$i \in \{0,\ldots, n - 1\}$}
                \State{$\mathcal{M}_2^A[i, i] \gets 1$}
            \EndFor
        \EndFor
    \EndFor
    \While{любая матрица из $\mathcal{M}_2$ меняется}
        \State{$M_3 \gets \bigvee_{M^A \in \mathcal{M}_1 \times \mathcal{M}_2} M^A$}
        \Comment{Использование произведения Кронекера}
        \State{$C_3 \gets \textit{transitiveClosure}(M_3)$}
        \Comment{Вычисление транзитивного замыкания}
        \For{$(i, j)\ |\ C_3[i, j] = 1$}
                \State{$q_1, q_2 \gets \textit{getStates}(i, j, n)$}
                \State{$x, y \gets \textit{getCoordinates}(i, j, n)$}
                \For{$A \in \textit{getNonterminals}(R, q_1, q_2)$}
                    \State{$\mathcal{M}_2^A[x,y] \gets 1$}
                \EndFor
        \EndFor
    \EndWhile
\State \Return $\mathcal{M}_2, M_3$
\EndFunction
% \Function{add}{$C, C', i, j$}
%     \State{$C'[i,j] \gets {1}$}
%     \For{$(u,v) \mid C[u,i] = C[j,v] = 1, C[u,j] = C[u,v] = 0$}
%         \State{$C'[u,v] \gets {1}$}
%     \EndFor
%     \State \Return{$C'$}
% \EndFunction
\Function{getStates}{$i, j, n$}
\Comment{Получение номеров состояний автомата $R$ по индексам ячейки в матрице $C_3$}
    \State \Return{$\left\lfloor{i / n}\right\rfloor, \left\lfloor{j / n}\right\rfloor$}
\EndFunction
\Function{getCoordinates}{$i, j, n$}
\Comment{Получение номеров вершин графа $\mathcal{G}$ по индексам ячейки в матрице $C_3$}
    \State \Return{$i \bmod n, j \bmod n$}
\EndFunction
\end{algorithmic}
\end{algorithm}

Результатом работы алгоритма, представленного на листинге~\ref{lst:tensor_cfpq}, является булева декомпозиция матриц смежности $\mathcal{M}_2$ входного графа с добавленными дугами с нетерминальными символами в качестве меток, которые описывают достижимость вершин в соответствии с заданными КС-ограничениями, а также матрица $M_3$, которая содержит необходимую информацию для восстановления всех искомых путей. Далее покажем как предложенный алгоритм позволяет решать задачи поиска путей в графе с заданными КС-ограничениями.

\paragraph{Задача достижимости.} Данная задача может быть решена с использованием множества матриц $\mathcal{M}_2$. А именно, в графе $\mathcal{G}$ существует путь из вершины $i$ в вершину $j$, удовлетворяющий заданным КС-ограничениям, только если $\mathcal{M}_2^S[i, j] = 1$.

\paragraph{Задача поиска одного пути и задача поиска всех путей.} Решить данные задачи можно с помощью матрицы $M_3$, которая для любого нетерминального символа $A \in N$ и для любой пары вершин $(i, j)$ содержит достаточно информации для восстановления всех путей $i \pi j$ таких, что $A \Rightarrow_G \lambda(\pi)$. Поэтому на листинге~\cref{lst:tensor_extract_all} представлен алгоритм восстановления всех путей в графе, соответствующих заданным КС-ограничениям. Стоит также отметить, что  представленный алгоритм восстановления путей основан на методе поиска в ширину, применённом на графе, соответствующем матрице $M_3$. А так как для данного метода обхода графа известен алгоритм~\cite{kepner2011graph}, использующий операции линейной алгебры, то именно такие операции могут быть использованы для при реализации функции $BFS$ обхода в ширину, которая возвращает пути из выделенной начальной вершины в конечную. Однако количество таких путей может быть бесконечным, поэтому при реализации функции $BFS$ необходимо вычислять множество таких путей <<лениво>>. Кроме того, для ограничения количества восстановленных путей в графе, возвращаемых алгоритмом, используется параметр $k$. При этом возвращаются $k$ найденных путей с номерами вершин, образующих лексикографически наименьшие последовательности. Таким образом, предложенный алгоритм позволяет восстанавливать любое количество путей, удовлетворяющих заданным КС-ограничениям.

\begin{algorithm}
	\floatname{algorithm}{Листинг}
	\begin{algorithmic}[1]
	    \footnotesize
		\caption{Алгоритм восстановления всех путей в графе с заданными КС-ограничениями для алгоритма, основанного на произведении Кронекера}
		\label{lst:tensor_extract_all}
		\State{$\mathcal{M}_2 \gets $ булева декомпозиция матрицы смежности результирующего графа алгоритма на листинге~\ref{lst:tensor_cfpq}}
		\State{$M_3 \gets $ результирующая матрица $M_3$ алгоритма на листинге~\ref{lst:tensor_cfpq}}
		\State{$R \gets$ рекурсивный автомат для входных КС-ограничений}
		\State{$\mathcal{M}_1 \gets $  булева декомпозиция матрицы смежности для $R$}
		
		\Function{ExtractAllPaths}{$v_s, v_f, A, k$}
		\State{$q_A^0 \gets$ начальное состояние конечного автомата для нетерминала $A$}
		\State{$F_A \gets$ конечные состояния конечного автомата для нетерминала $A$}
		\State{$\textit{paths} \gets \bigcup\limits_{q_A^f \in F_A} \Call{BFS}{M_3, (q_A^0, v_s), (q_A^f, v_f)}$}
		\State{$\textit{resultPaths} \gets \emptyset$}
		\For{$\textit{path} \in \textit{paths}$}
		\State{$\textit{currentPaths} \gets \emptyset$}
		\For{$((s_i, v_i), (s_j, v_j)) \in \textit{path}$}
		\State{$\textit{newEdges} \gets  \{(v_i, t, v_j) \mid M_2^t[v_i, v_j] \wedge M_1^t[s_i, s_j]\}$}
		\State{$\textit{currentPaths} \gets \textit{currentPaths} \cdot \textit{newEdges}$}
		\Comment{Конкатенация путей}
		\State{$k' \gets k - |\textit{resultPaths}| - |\textit{currentPaths}|$}
		\State{$\textit{newSubPaths} \gets  \bigcup_{\{N \mid  M_2^N[v_i, v_j]  \wedge M_1^N[s_i, s_j]\}} \Call{ExtractAllPaths}{v_i, v_j, N, k'}$}
		\State{$\textit{currentPaths} \gets \textit{currentPaths} \cdot \textit{newSubPaths}$}
		\Comment{Конкатенация путей}
		\EndFor
		\State{$\textit{resultPaths} \gets \textit{resultPaths} \cup \textit{currentPaths}$}
		\If{$|\textit{resultPaths}| \geq k$}
		\State \Return $\Call{TopK}{\textit{resultPaths}}$
		\EndIf
		\EndFor

		\State \Return $\textit{resultPaths}$
		\EndFunction
		
		\Function{TopK}{$\textit{paths}$}
		\Comment{Выбор $k$ путей}
		\State{$\textit{kPaths} \gets k$ путей из $\textit{paths}$ с наименьшими номерами вершин в лексикографическом порядке}
		\State \Return $\textit{kPaths}$
		\EndFunction

	\end{algorithmic}
\end{algorithm}

Таким образом, алгоритмы представленные на листингах~\ref{lst:tensor_cfpq} и \ref{lst:tensor_extract_all} позволяют решить задачу поиска одного и задачу поиска всех путей в графе с заданными КС-ограничениями с использованием операции произведения Кронекера.


\section{Корректность алгоритма}\label{sec:ch4/sect2}
В данном разделе сформулированы и доказаны утверждения о корректности и завершаемости изложенного алгоритма.

Для доказательства завершаемости представленного алгоритма поиска путей в графе с заданными КС-ограничениями будет использовано определённое в разделе~\ref{sec:ch3/sect2} отношение частичного порядка $\preceq_{\textit{rel}}$ на элементах использованного булевого полукольца $\langle \{0, 1\}, \vee, \wedge, 0 \rangle$. Сперва докажем теорему о монотонности алгоритма, представленного на листинге~\ref{lst:tensor_cfpq}. Далее для любых допустимых индексов $(i, j)$ и для любого нетерминала $A \in N$, будем использовать следующие обозначения:

\begin{itemize}
    \item $\mathcal{M}_2^{A, 0}[i, j]$, $M_3^{0}[i, j]$ и $C_3^{0}[i, j]$~--- для значений в ячейках $\mathcal{M}_2^{A}[i, j]$, $M_3[i, j]$ и $C_3[i, j]$ после инициализации матриц в строках 2--10 алгоритма, представленного на листинге~\ref{lst:tensor_cfpq};
    \item $\mathcal{M}_2^{A, k}[i, j]$, $M_3^{k}[i, j]$ и $C_3^{k}[i, j]$~--- для значений в ячейках $\mathcal{M}_2^{A}[i, j]$, $M_3[i, j]$ и $C_3[i, j]$ после $k$ исполнений цикла в строках 11--18, для $k \geq 1$.
\end{itemize}

\begin{theorem}[Монотонность алгоритма]\label{thm:monotone_tensor}
	Пусть $\mathcal{G} = \langle V, E, L \rangle$~--- входной граф и $G = \langle N, \Sigma, P, S \rangle$~--- входная КС-грамматика для алгоритма, представленного на листинге~\ref{lst:tensor_cfpq}. Тогда для любых допустимых индексов $(i, j)$ и для любого нетерминала $A \in N$, значения в ячейках $\mathcal{M}_2^{A}[i, j]$, $M_3[i, j]$ и $C_3[i, j]$ монотонно возрастают в соответствии с отношением частичного порядка $\preceq_{\textit{rel}}$.
\end{theorem}
\begin{proof}
Необходимо доказать, что для любого $k \geq 1$, $\mathcal{M}_2^{A, k - 1}[i, j] \preceq_{\textit{rel}} \mathcal{M}_2^{A, k}[i, j]$,  $M_3^{k - 1}[i, j] \preceq_{\textit{rel}} M_3^{k}[i, j]$ и $C_3^{k - 1}[i, j] \preceq_{\textit{rel}} C_3^{k}[i, j]$. Для $k = 1$ данное утверждение верно, так как все элементы матриц $M_3$ и $C_3$ равны $\bot = 0$, а значения элементов матриц $\mathcal{M}_2^{A}$ могут изменится лишь в строке 18 с 0 на 1. Для $k > 1$ данное утверждение верно, так как по свойствам определённых операций произведения Кронекера и транзитивного замыкания изменения некоторых значений элементов матриц $\mathcal{M}_2^{A, k - 1}$ с 0 на 1 могут привести только к таким же изменениям для некоторых элементов матриц $M_3^{k - 1}$ и $C_3^{k - 1}$, что доказывает утверждение теоремы.
\end{proof}

Следствием доказанной теоремы является следующая теорема о конечности алгоритма, представленного на листинге~\ref{lst:tensor_cfpq}.

\begin{theorem}[Завершаемость алгоритма]\label{thm:finite_tensor}
	Алгоритм, представленный на листинге~\ref{lst:tensor_cfpq} завершается за конечное число шагов.
\end{theorem}
\begin{proof}
По теореме~\ref{thm:monotone_tensor}, значения в ячейках матриц из множества $\mathcal{M}_2^{A}$ монотонно возрастают. А так как матрицы и множества возможных значений элементов этих матриц конечны, то алгоритм, представленный на листинге~\ref{lst:tensor_cfpq} завершается за конечное число шагов.
\end{proof}

Кроме того, с помощью рассуждений, аналогичных рассуждениям в доказательствах леммы~\ref{lemma:correct_mtx} и теоремы~\ref{thm:correct_mtx}, может быть доказана следующая теорема.

\begin{theorem}[Корректность алгоритма]\label{thm:correct_tensor}
	Пусть $\mathcal{G} = \langle V, E, L \rangle$~--- входной граф и $G = \langle N, \Sigma, P, S \rangle$~--- входная КС-грамматика для алгоритма, представленного на листинге~\ref{lst:tensor_cfpq}. Тогда для любой пары вершин $(i, j)$ графа $\mathcal{G}$, для любого нетерминала $A \in N$, значение в ячейке $\mathcal{M}_2^{A, k}[i, j] = 1$ только если существует путь $i \pi j$ такой, что $A \Rightarrow_G \lambda(\pi)$.
\end{theorem}
\begin{proof}
По индукции на минимальные высоты деревьев вывода, соответствующих рассматриваемым путям в графе.
\end{proof}

Следствием теоремы~\ref{thm:correct_tensor} является корректность матрицы $M_3$, возвращаемой алгоритмом из листинга~\ref{lst:tensor_cfpq} и описывающей пересечение конечного автомата для входного графа и рекурсивного автомата для входных КС-ограничений. Таким образом, корректен и предложенный алгоритм восстановления всех путей в графе, основанный на обходе в ширину матрицы $M_3$, что отображено в следующей теореме.

\begin{theorem}[Корректность восстановления путей]\label{thm:correct_extraction_single_all_tensor}
	Пусть $\mathcal{G} = \langle V, E, L \rangle$~--- входной граф, $G = \langle N, \Sigma, P, S \rangle$~--- входная КС-грамматика и $(\mathcal{M}_2, M_3)$~--- результат, возвращаемый алгоритмом, представленным на листинге~\ref{lst:tensor_cfpq}. Тогда для любой пары вершин $(i, j)$ и любого нетерминала $A \in N$ алгоритм, представленный на листинге~\ref{lst:tensor_extract_all} построит множество из заданного количества путей $i \pi j$ таких, что существует дерево вывода для строки $\lambda(\pi)$ из нетерминала $A$ грамматики $G$, если такие пути существуют.
\end{theorem}

\section{Временная сложность алгоритма}\label{sec:ch4/sect3}
В данном разделе представлена оценка временной сложности предложенного алгоритма.

Предположим, что все операции над элементами использованных матриц вычисляются за $O(1)$ элементарных операций. Кроме того, оценим количество элементарных операций, необходимых в худшем случае для вычисления операций над булевыми матрицами, как:

\begin{itemize}
    \item $O(n^2)$~--- для операции $\bigvee$ поэлементного сложения двух булевых матриц размера $n \times n$,
    \item $O(m^2n^2)$~--- для операции $\times$ произведения Кронекера булевой декомпозиции матрицы смежности размера $m \times m$ и булевой декомпозиции матрицы смежности размера $n \times n$,
    \item $O(n^3\log n)$~--- для вычисления транзитивного замыкания булевой матрицы размера $n \times n$.
\end{itemize}

Стоит отметить, что вычисление транзитивного замыкания булевой матрицы за такое количество элементарных операций может быть выполнено с использованием техники быстрого возведения матрицы в степень~\cite{baras2010path}.

Тогда справедлива следующая оценка временной сложности предложенного в этой главе алгоритма поиска путей в графе с заданными КС-ограничениями.

\begin{theorem}[Оценка временной сложности алгоритма поиска путей, основанного на произведении Кронекера]\label{thm:time_tns}
	Пусть $\mathcal{G} = \langle V, E, L \rangle$~--- входной граф, $G =\langle N, \Sigma, P, S \rangle$~--- входная КС-грамматика и $R$~--- рекурсивный автомат для грамматики $G$ с множеством состояний $Q$. Тогда для алгоритма, представленного на листинге~\ref{lst:tensor_cfpq}, справедлива следующая оценка временной сложности: $O(|N||Q|^3|V|^5 \log (|Q||V|))$.
\end{theorem}
\begin{proof}
В строках 7--10 алгоритма для каждого состояния $q$ производится чтение значений в ячейках $[q, q]$ в $|N|$ булевых матрицах размера $|Q| \times |Q|$ с помощью функции $\textit{getNonterminals}$, а затем для каждого полученного нетерминала $A$ и каждой вершины графа $i$ производится запись в ячейку $[i, i]$ соответствующей булевой матрицы. Поэтому в этих строках производится $O(|N||Q||V|)$ элементарных операций. 

Далее рассмотрим цикл в строках 11--18. Алгоритм продолжает вычисления пока любая матрица из множества $\mathcal{M}_2$ меняется. Всего матриц в этом множестве, которые могут меняться~--- $|N|$ (они соответствуют нетерминальным символам грамматики $G$) и каждая из них имеет $|V|^2$ элементов. На каждой итерации могут измениться лишь некоторые нулевые значения ячеек этих матриц на значение 1. Поэтому максимальное количество итераций рассматриваемого цикла может быть достигнуто в случае, когда за каждую итерацию цикла изменяется значение лишь одной ячейки в одной матрице. Таким образом, максимальным количеством итераций рассматриваемого цикла является $|N||V|^2$. А на каждой итерации производится: вычисление произведения Кронекера за $O(|Q|^2|V|^2)$ операций; вычисление поэлементного сложения получившихся булевых матриц, соответствующих общим символам автомата и графа, а также нетерминальным символам, за $O(|Q|^2|V|^2)$ операций; вычисление транзитивного замыкания булевой матрицы размера $|Q||V| \times |Q||V|$ за $O(|Q|^3|V|^3 \log (|Q||V|))$ операций; и вычисления цикла в строках 14--18 за $O(|N||Q||V|)$ операций. Наиболее трудоёмким является вычисление транзитивного замыкания булевой матрицы размера $|Q||V| \times |Q||V|$, поэтому алгоритм завершит свою работу за $O(|N||V|^2 (|Q|^3|V|^3 \log (|Q||V|)))$. Отсюда получаем заявленную оценку временной сложности алгоритма, представленного на листинге~\ref{lst:tensor_cfpq}.
\end{proof}

Следует отметить что приведённая оценка временной сложности алгоритма, представленного на листинге~\ref{lst:tensor_cfpq}, может быть существенно улучшена для разреженных графов. Также имеется возможность воспользоваться специальной техникой вычисления транзитивного замыкания~\cite{ibaraki1983line}, которая использует инкрементальность получающихся на итерациях алгоритма матриц и вычисляет информацию о достижимости только для необходимого множества вершин.

В данной работе временная сложность алгоритма, представленного на листинге~\ref{lst:tensor_extract_all}, не приводится, так как она зависит от конкретной реализации функции $\textit{BFS}$.

\section{Пример}\label{sec:ch4/sect4}
В данном разделе работа изложенного алгоритма продемонстрирована на примере, основанном на КС-языке $\mathcal{L} = \{a^nb^n \mid n \geq 1\}$. Рассмотрим граф $\mathcal{G}_1$, изображённый на~\cref{fig:example_graph}. Для алгоритма, изложенного в предыдущей главе было необходимо представить входные КС-ограничения в виде КС-грамматики в ослабленной нормальной форме Хомского. Пример такой грамматики для языка $\mathcal{L}$ был рассмотрен в разделе~\ref{sec:ch3/sect4}. Однако для алгоритма, представленного на листинге~\ref{lst:tensor_cfpq}, приведение в нормальную форму необязательно. Поэтому рассмотрим грамматику с меньшим количеством правил и нетерминальных символов. Правила вывода такой КС-грамматики $G$ имеют следующий вид.
	\[
	\begin{array}{rccl}
	0: & S & \rightarrow & \text{\emph{a}} \ S \ \text{\emph{b}} \\
	1: & S & \rightarrow & \text{\emph{a}} \ \text{\emph{b}} \\
	
	\end{array}
	\]

Предложенный на листинге~\ref{lst:tensor_cfpq} алгоритм использует представление КС-грамматики в виде рекурсивного автомата. Такой автомат $R = \langle \{a, b\}, \{S\}, S, \{C_S\}\rangle$ для КС-грамматики $G$ представлен на~\cref{example:automata}.

Меткой стартового автомата $C_S$ является стартовый нетерминал грамматики $S$, начальным состоянием этого автомата является состояние $q_S^0$, а множеством конечных состояний~--- $\{ q_S^3 \}$. Алгоритм будет использовать булевы декомпозиции $\mathcal{M}_1$ и $\mathcal{M}_2$ матриц смежности рекурсивного автомата и входного графа. Для более компактно представления в данном примере будем использовать сами матрицы смежности $M_1$ и $M_2$ для автомата $R$ и графа $\mathcal{G}_1$, которые выглядят следующим образом (нулевые значения пропущены):
    $$
    M_1 =
    \begin{pmatrix}
    . & \{a\} & . & .     \\
    . & . & \{S\} & \{b\} \\
    . & . & . & \{b\}     \\
    . & . & . & .
    \end{pmatrix}
    ,~~~~~
    M_2^0 =
    \begin{pmatrix}
    . & \{a\} & . & .     \\
    . & . & \{a\} & .     \\
    \{a\} & . & . & \{b\} \\
    . & . & \{b\} & .
    \end{pmatrix}.
    $$ 

В строках 7--10 алгоритм рассматривает все $\varepsilon$-переходы в автомате $R$ и добавляет в матрицу $M_2$ информацию о пустых путях в графе. Однако в рассматриваемом примере рекурсивный автомат не содержит $\varepsilon$-переходов, поэтому в этих строках матрица $M_2$ не изменится.

Далее алгоритм выполняет цикл в строках 11--18 пока матрица $M_2$ изменяется. Приведём значения матриц $M_2$, $M_3$ и $C_3$ на каждой итерации алгоритма. На первой итерации цикла вычисляется произведение Кронекера $M_3^1 = M_1 \times M_2^0$ и транзитивное замыкание $C_3^1$, которые выглядят следующим образом (новые ненулевые значения выделены).

%\begin{figure}
    {\scriptsize
    \renewcommand{\arraystretch}{0.6}
    \centering
    $$
    M_3^1 =\left(
    \begin{array}{c c c c | c c c c | c c c c | c c c c }
    . & . & . & .  &  . & 1 & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & 1 & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  1 & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & .   \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    \end{array}
    \right)
    $$
    $$
    C_3^1 =
    \left(
    \begin{array}{c c c c | c c c c | c c c c | c c c c }
    . & . & . & .  &  . & 1 & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & 1 & .  &  . & . & . & .  &  . & . & . & \cellcolor{lightgray}\textbf{1} \\
    . & . & . & .  &  1 & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .
    \end{array}
    \right)
    $$
    }
    %\caption{The first iteration tensor product and transitive closure evaluation for example query}
    %\label{example:iteration1eval}
%\end{figure}

%Note here that the dimension $n$ of the matrix $M_3$ equals 16, and this value is constant in time of the algorithm execution.

После вычисления транзитивного замыкания ячейка $C_3^1[1, 15]$ содержит ненулевое значение. Для того чтобы понять, что это означает для исходного графа $\mathcal{G}_1$ и рекурсивного автомата $R$, разберём используемые в алгоритме функции $\textit{getStates}$ и $\textit{getCoordinates}$. С помощью функции $\textit{getStates}$ вычисляются значения состояний $q_1$ и $q_2$ рекурсивного автомата, которые соответствуют некоторому найденному пути в графе. Для вычисления $x$ и $y$~--- начальной и конечной вершин этого пути, используется функция $\textit{getCoordinates}$. Затем в матрицу $M_2$ добавляется информация о том, что существует путь в графе из вершины $x$ в вершину $y$, метки на дугах которого образуют слово, выводимое из некоторого нетерминала на переходах из состояния $q_1$ в состояние $q_2$ рекурсивного автомата. Например, после первой итерации новое ненулевое значение в ячейке $C_3^1[1, 15]$ матрицы $C_3^1$ означает следующее.
\begin{itemize}
    \item Состояния автомата $q_1 = 0$ и $q_2 = 3$, так как ячейка $C_3^1[1, 15]$ в верхнем правом блоке матрицы $C_3$ с координатами блока $(0, 3)$.
    \item Вершины $x = 1$ и $y = 3$, так как ячейка $C_3^1[1, 15]$ имеет именно такие координаты внутри своего блока.
    \item Функция $\textit{getNonterminals}$ возвращает множество $\{S\}$, так как это единственный нетерминал на переходах из состояния $0$ в состояние $3$ рекурсивного автомата $R$.
    \item Таким образом, существует путь в графе из вершины $1$ в вершину $3$, метки на дугах которого образуют слово, выводимое из нетерминала $S$.
\end{itemize}

В результате на первой итерации цикла в ячейку $M_2^1[1, 3]$ добавляется нетерминал $S$. Обновлённая матрица $M_2$ и соответствующий обновлённый граф представлены на~\cref{example:iteration1res}.

\begin{figure}[h]
    \begin{subfigure}[]{0.5\textwidth}
    \centering
    $$
    M_2^1 =
    \begin{pmatrix}
    . & \{a\} & . & .     \\
    . & . & \{a\} & \{\textbf{S}\} \\
    \{a\} & . & . & \{b\} \\
    . & . & \{b\} & .
    \end{pmatrix}
    $$
    \end{subfigure}
    \begin{subfigure}[]{0.4\textwidth}
    \centering
    \begin{tikzpicture}[shorten >=1pt,auto]
           \node[state] (q_0)                      {$0$};
           \node[state] (q_1) [above right=of q_0] {$1$};
           \node[state] (q_2) [right=of q_0]       {$2$};
           \node[state] (q_3) [right=of q_2]       {$3$};
            \path[->]
            (q_0) edge  node {a} (q_1)
            (q_1) edge  node {a} (q_2)
            (q_1) edge[bend left, above]  node {\textbf{S}} (q_3)
            (q_2) edge  node {a} (q_0)
            (q_2) edge[bend left, above]  node {b} (q_3)
            (q_3) edge[bend left, below]  node {b} (q_2);
    \end{tikzpicture}
    \end{subfigure}
    \caption{Обновлённая матрица $M_2$ и соответствующий обновлённый граф после первой итерации алгоритма}
    \label{example:iteration1res}
\end{figure}


На второй итерации цикла вычисленные матрицы $M_3^2$ и $C_3^2$ выглядят следующим образом:

{
\scriptsize
    \renewcommand{\arraystretch}{0.6}
    \centering
    $$
    M_3^2 =
    \left(
    \begin{array}{c c c c | c c c c | c c c c | c c c c }
    . & . & . & .  &  . & 1 & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & 1 & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  1 & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .           &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & \cellcolor{lightgray}\textbf{1}  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .           &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .           &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .
    \end{array}
    \right)
    $$
    $$
    C_3^2 =
    \left(
    \begin{array}{c c c c | c c c c | c c c c | c c c c }
    . & . & . & .  &  . & 1 & . & .  &  . & . & . & \cellcolor{lightgray}\textbf{1}  &  . & . & \cellcolor{lightgray}\textbf{1} & . \\
    . & . & . & .  &  . & . & 1 & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  1 & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & 1  &  . & . & \cellcolor{lightgray}\textbf{1} & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .
    \end{array}
    \right).
    $$
}
%listed in Figure~\ref{example:iteration2eval}.

Новые ненулевые значения матрицы $C_3^2$ появились в ячейках $[0, 11]$, $[0, 14]$ и $[5, 14]$. Однако только ячейка с индексом $[0, 14]$ соответствует состояниям $q_1$ и $q_2$ автомата, между которыми есть хотя бы один переход по нетерминальному символу. Поэтому только значение в ячейке $[5, 14]$ повлияет на обновление матрицы $M_2$. Обновлённая матрица $M_2$ и соответствующий обновлённый граф после второй итерации представлены на~\cref{example:iteration2res}.

%\begin{figure}
%    \caption{The second iteration tensor product and transitive closure evaluation for example query}
%    \label{example:iteration2eval}
%\end{figure}

\begin{figure}
    \begin{subfigure}[]{0.5\textwidth}
    \centering
    $$
    M_2^2 =
    \begin{pmatrix}
    .     & \{a\} & \{\textbf{S}\} & .     \\
    .     & .     & \{a\} & \{S\} \\
    \{a\} & .     & .     & \{b\} \\
    .     & .     & \{b\} & .
    \end{pmatrix}
    $$
    \end{subfigure}
    \begin{subfigure}[]{0.4\textwidth}
    \centering
    \begin{tikzpicture}[shorten >=1pt,auto]
           \node[state] (q_0)                      {$0$};
           \node[state] (q_1) [above right=of q_0] {$1$};
           \node[state] (q_2) [right=of q_0]       {$2$};
           \node[state] (q_3) [right=of q_2]       {$3$};
            \path[->]
            (q_0) edge  node {a} (q_1)
            (q_1) edge  node {a} (q_2)
            (q_1) edge[bend left, above]  node {S} (q_3)
            (q_2) edge  node {a} (q_0)
            (q_0) edge[bend right, below]  node {\textbf{S}} (q_2)
            (q_2) edge[bend left, above]  node {b} (q_3)
            (q_3) edge[bend left, below]  node {b} (q_2);
    \end{tikzpicture}
    \end{subfigure}
    \caption{Обновлённая матрица $M_2$ и соответствующий обновлённый граф после второй итерации}
    \label{example:iteration2res}
\end{figure}

Матрицы $M_2$ и $C_3$, вычисленные на оставшихся итерациях цикла, представлены на~\cref{example:iteration3to6res} и на~\cref{example:iteration3to6eval}.
В данном примере номер последней итерации цикла~--- 7, на которой в матрицу $M_2$ не добавляется новых ненулевых значений и алгоритм выходит из цикла.



\begin{figure}[ht]
    \centering
    $$
    M_2^3 =
    \begin{pmatrix}
    .     & \{a\} & \{S\} & .       \\
    .     & .     & \{a\} & \{S\}   \\
    \{a\} & .     & .     & \{b, \textbf{S}\} \\
    .     & .     & \{b\} & .
    \end{pmatrix}
    M_2^4 =
    \begin{pmatrix}
    .     & \{a\} & \{S\}   & .       \\
    .     & .     & \{a, \textbf{S}\} & \{S\}   \\
    \{a\} & .     & .       & \{b, S\} \\
    .     & .     & \{b\}   & .
    \end{pmatrix}
    $$
    $$
    M_2^5 =
    \begin{pmatrix}
    .     & \{a\} & \{S\}   & \{\textbf{S}\}   \\
    .     & .     & \{a, S\} & \{S\}   \\
    \{a\} & .     & .       & \{b, S\} \\
    .     & .     & \{b\}   & .
    \end{pmatrix}
    M_2^6 =
    \begin{pmatrix}
    .     & \{a\} & \{S\}   & \{S\}   \\
    .     & .     & \{a, S\} & \{S\}   \\
    \{a\} & .     & \{\textbf{S}\}   & \{b, S\} \\
    .     & .     & \{b\}   & .
    \end{pmatrix}
    $$
    \caption{Обновлённая матрица $M_2$ для итераций алгоритма с 3 по 6}
    \label{example:iteration3to6res}
\end{figure}



Изначальный граф и граф со всеми добавленными дугами после работы алгоритма представлен на~\cref{example:input_and_result}.

\begin{figure}[h]
        \centering
        \begin{subfigure}{.48\textwidth}
        \begin{center}
        \begin{tikzpicture}[shorten >=1pt,auto]
           \node[state] (q_0)                      {$0$};
           \node[state] (q_1) [above right=2cm and 1.5cm of q_0] {$1$};
           \node[state] (q_2) [right=1.5cm of q_0]       {$2$};
           \node[state] (q_3) [right= 1.5cm of q_2]       {$3$};
            \path[->]
            (q_0) edge  node {a} (q_1)
            (q_1) edge  node {a} (q_2)
            (q_2) edge  node {a} (q_0)
            (q_2) edge[bend left, above]  node {b} (q_3)
            (q_3) edge[bend left, below]  node {b} (q_2);
        \end{tikzpicture}
        \caption{Исходный граф $\mathcal{G}_1$}
        \label{input:graph}
        \end{center}
        \end{subfigure}
        \begin{subfigure}{.48\textwidth}
        \begin{center}
        \begin{tikzpicture}[shorten >=1pt,auto]
        \node[state] (q_0)                      {$0$};
        \node[state] (q_1) [above right=2cm and 1.5cm of q_0] {$1$};
        \node[state] (q_2) [right=1.5cm of q_0]       {$2$};
        \node[state] (q_3) [right= 1.5cm of q_2]       {$3$};
          \path[->]
            (q_0) edge  node {a} (q_1)
            (q_1) edge  node {a,\textbf{S}} (q_2)
            (q_2) edge[bend right, above]  node {a} (q_0)
            (q_2) edge[loop right]  node {\textbf{S}} (q_2)
            (q_1) edge[bend left, above]  node {\textbf{S}} (q_3)
            (q_0) edge[bend right, above]  node {\textbf{S}} (q_2)
            (q_2) edge[bend left, above]  node {b,\textbf{S}} (q_3)
            (q_0) edge[bend right, below]  node {\textbf{S}} (q_3)
            (q_3) edge[bend left, below]  node {b} (q_2);
    \end{tikzpicture}
    \caption{Результирующий граф}
    \label{example:result}
    \end{center}
    \end{subfigure}
    \caption{Исходный граф $\mathcal{G}_1$ и граф, соответствующий результирующей булевой декомпозиции матрицы смежности $\mathcal{M}_2$}
    \label{example:input_and_result}

\end{figure}

\begin{figure}[ht]
    \scriptsize
    \renewcommand{\arraystretch}{0.6}
    \centering
    $$
    C_3^3 =
    \left(
    \begin{array}{c c c c | c c c c | c c c c | c c c c }
    . & . & . & .  &  . & 1 & . & .  &  . & . & . & 1  &  . & . & 1 & . \\
    . & . & . & .  &  . & . & 1 & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  1 & . & . & .  &  . & . & \cellcolor{lightgray}\textbf{1} & .  &  . & . & . & \cellcolor{lightgray}\textbf{1} \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & 1 & .  &  . & . & . & \cellcolor{lightgray}\textbf{1} \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & 1  &  . & . & 1 & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .
    \end{array}
    \right)
    $$
    $$
    C_3^4 =
    \left(
    \begin{array}{c c c c | c c c c | c c c c | c c c c }
    . & . & . & .  &  . & 1 & . & .  &  . & . & . & 1  &  . & . & 1 & . \\
    . & . & . & .  &  . & . & 1 & .  &  . & . & . & \cellcolor{lightgray}\textbf{1}  &  . & . & \cellcolor{lightgray}\textbf{1} & 1 \\
    . & . & . & .  &  1 & . & . & .  &  . & . & 1 & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & 1 & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & 1  &  . & . & 1 & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & 1  &  . & . & \cellcolor{lightgray}\textbf{1} & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .
    \end{array}
    \right)
    $$
    $$
    C_3^5 =
    \left(
    \begin{array}{c c c c | c c c c | c c c c | c c c c }
    . & . & . & .  &  . & 1 & . & .  &  . & . & \cellcolor{lightgray}\textbf{1} & 1  &  . & . & 1 & \cellcolor{lightgray}\textbf{1} \\
    . & . & . & .  &  . & . & 1 & .  &  . & . & . & 1  &  . & . & 1 & 1 \\
    . & . & . & .  &  1 & . & . & .  &  . & . & 1 & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & 1 & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & 1 & 1  &  . & . & 1 & \cellcolor{lightgray}\textbf{1} \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & 1  &  . & . & 1 & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .
    \end{array}
    \right)
    $$
    $$
    C_3^6 =
    \left(
    \begin{array}{c c c c | c c c c | c c c c | c c c c }
    . & . & . & .  &  . & 1 & . & .  &  . & . & 1 & 1  &  . & . & 1 & 1 \\
    . & . & . & .  &  . & . & 1 & .  &  . & . & . & 1  &  . & . & 1 & 1 \\
    . & . & . & .  &  1 & . & . & .  &  . & . & 1 & \cellcolor{lightgray}\textbf{1}  &  . & . & \cellcolor{lightgray}\textbf{1} & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & 1 & 1  &  . & . & \cellcolor{lightgray}\textbf{1} & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & 1 & 1  &  . & . & 1 & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & 1  &  . & . & 1 & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .
    \end{array}
    \right)
    $$
    \caption{Транзитивное замыкание $C_3$ на итерациях алгоритма с 3 по 6}
    \label{example:iteration3to6eval}
\end{figure}

Результатом работы алгоритма, представленного на листинге~\ref{lst:tensor_cfpq}, являются матрицы $M_2$ и $M_3$. В матрице $M_2$ содержится вся информация о достижимости в графе в соответствии с заданными КС-ограничениями, которая отображена на~\cref{example:result}. А последнее значение матрицы $M_3$ содержит информацию, достаточную для восстановления всех искомых путей.

\clearpage


\section{Реализация}\label{sec:ch4/sect5}
В данном разделе приведены детали реализации полученного алгоритма поиска путей в графе с заданными КС-ограничениями с использованием произведения Кронекера.

При реализации предложенного алгоритма также учитывались особенности реальных графов. В данном случае остаются применимы рассуждения из раздела~\cref{sec:ch3/sect5}, в результате которых был сделан выбор использовать параллельные вычисления и разреженный формат для хранения матриц.

В предложенном алгоритме используется операция произведения Кронекера над булевыми матрицами, а также операция вычисления транзитивного замыкания матрицы. Алгоритм был реализован на CPU с использованием библиотеки SuiteSparse:GraphBLAS и на GPU с использованием библиотеки cuBool, в которых реализована операция произведения Кронекера и транзитивное замыкание может быть вычислено с использованием серии умножений булевых матриц (возведения матрицы $M_3$ в некоторую степень). В результате были получены следующие реализации:
\begin{itemize}
    \item $\textit{KronAll}_{\textit{CPU}}$~--- на языке \texttt{Python} с использованием пакета pygraphblas, являющегося обёрткой для библиотеки SuiteSparse:GraphBLAS;
    \item $\textit{KronAll}_{\textit{GPU}}$~--- на языке \texttt{Python} с использованием пакета pycubool, являющегося обёрткой для библиотеки cuBool.
\end{itemize}

Стоит отметить, что предложенный алгоритм позволяет построить матрицы, которые содержат в себе информацию, достаточную для восстановления всех путей в графе, соответствующих заданным КС-ограничениям. Ответ на задачу достижимости может быть получен с использованием матриц $\mathcal{M}_2$, вычисленных с использованием разработанных реализаций. Для задач поиска одного и всех путей был реализован алгоритм восстановления искомых путей, представленный на листинге~\ref{lst:tensor_extract_all}, по информации, содержащейся в матрицах $\mathcal{M}_2$ и $M_3$.

Реализации $\textit{KronAll}_{\textit{CPU}}$ и $\textit{KronAll}_{\textit{GPU}}$ также находятся в открытом доступе в рамках платформы $\textit{CFPQ\_PyAlgo}$.


\clearpage
