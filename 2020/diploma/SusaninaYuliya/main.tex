\documentclass[12pt]{matmex-diploma-custom}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{float}
\usepackage[caption=false]{subfig}
\usepackage{minted}
\usepackage{verbments}
\usepackage{caption}
\usepackage{tikz} 
\usepackage{pgfplots} 
\usepackage{sidecap} 
\usepackage{soul}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{dsfont}


\usepackage{algpseudocode}
\usepackage[Листинг,ruled]{algorithm}
\usepackage{algorithmicx}
\algtext*{EndWhile}% Remove "end while" text
\algtext*{EndIf}% Remove "end if" text
\algtext*{EndFor}

%\documentclass[14pt]{matmex-diploma-custom}
%\hyphenation{Ge-ne-ra-lised}
%\tolerance=1
\emergencystretch=\maxdimen
%\hyphenpenalty=10000
%\hbadness=10000
\usetikzlibrary{graphs, graphs.standard, quotes}
\usetikzlibrary{arrows}


\begin{document}


\makeatletter
\let\@upn\textbf% \textup -> \textbf
\makeatother
\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}


% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
	chair              = {Программная инженерия
		\vskip 1em
		Системное программирование},
	title              = {От синтаксического анализа графов к системам матричных уравнений},
	% Здесь указывается тип работы. Возможные значения:
	%   coursework - Курсовая работа
	%   diploma - Диплом специалиста
	%   master - Диплом магистра
	%   bachelor - Диплом бакалавра
	type               = {coursework},
	position           = {студента},
	group              = 571,
	author             = {Сусанина Юлия Алексеевна},
	supervisorPosition = {к.\,ф.-м.\,н., доцент},
	supervisor         = {Григорьев С.\,В.},
	%reviewerPosition   = {научный координатор Центра Компьютерных Наук TUCS},
	%reviewer           = {Бараш М.\,Л.},
	%chairHeadPosition  = {д.\,ф.-м.\,н., профессор},
	%chairHead          = {Терехов А.\,Н.}
}


\maketitle
%\setcounter{tocdepth}{1}
\tableofcontents
% У введения нет номера главы
\section*{Введение}

Поиск путей с контекстно-свободными ограничениями в графе (синтаксический анализ графа) --– способ задать пути в помеченном графе в терминах некоторой контекстно-свободной грамматики –-- набирает популярность во многих областях, например, биоинформатика~\cite{sevon2008subgraph}, графовые базы данных~\cite{Kuijpers:2019:ESC:3335783.3335791,Medeiros:2018:EEC:3167132.3167265,yannakakis1990graph} или статический анализ кода~\cite{zhang2013fast, Reps}. 
Контекстно-свободные грамматики обладают большей выразительной мощностью, чем обычно использующиеся регулярные языки и поэтому является многообещающей областью для исследования. 

Несмотря на то, что уже предложено много различных алгоритмов для синтаксического анализа графов~\cite{azimov2018context,RDF,Medeiros:2018:EEC:3167132.3167265,Verbitskaia:2018:PCC:3241653.3241655,10.1007/978-3-319-91662-0_17}, недавние эксперименты показывают, что хорошая производительность на реальных данных все еще является большой проблемой~\cite{Kuijpers:2019:ESC:3335783.3335791}. 
Лучшие результаты показывают алгоритмы, в основе которых лежит сведение к какой-либо хорошо исследованной задаче с известными быстрыми алгоритмами решения.
Например, предложенный Рустамом Азимовым алгоритм~\cite{azimov2018context}, сводит задачу поиска путей с контекстно-свободными ограничениями к перемножению булевых матриц и позволяет ускорить вычисления за счет использования высокопроизводительных библиотек и параллельных техник~\cite{mishin2019evaluation}.

Недавние результаты применения вычислительных методов в логическом программировании показали, что использование знаний и методов из этого раздела математики позволяет ускорить вычисления~\cite{aspis2018linear, sato2017linear}, например, сведение к решению линейных матричных уравнений ускорило вычисление определенного класса Datalog-запросов. 
Если мы применим похожую технику к нашей задаче, это откроет новые возможности для поиска путей с контекстно-свободными ограничениями. 
Например, приближенные методы часто сокращают процесс вычисления без потери важных результатов. 
Еще одной немаловажной причиной для выбора численных методов как перспективной области исследования является связанное с активным развитием искусственного интеллекта и машинного обучения постоянное улучшение библиотек и программных пакетов для вычислительной математики и, соответственно, возможность высокоэффективных реализаций.

В данной работе предполагается создать подход, в основе которого лежат алгоритмы линейной алгебры и вычислительной математики, который позволит ускорить обработку контектсно-свободных запросов к графовым данным. Также необходимо изучить возможность решения некоторых задач из линейной алгебры через синтаксический анализ графов, наметить основные направления будущих исследований.



\section{Постановка задачи}

Целью данной работы является создание подхода, основанного на методах линейной алгебры и вычислительной математики, к задаче поиска путей с контекстно-свободными ограничениями в графе.
Для её достижения были поставлены следующие задачи.

\begin{itemize}
	\item Сведение задачи синтаксического анализа графов к задаче решения (систем) матричных уравнений.
    \item Исследование способов решения полученных уравнений.
    \item Реализация и экспериментальное исследование.
\end{itemize}
	

\section{Обзор предметной области}

\subsection{Синтаксический анализ}

Алфавитом $\Sigma$ будем называть некоторое конечное множество символов.
Тогда $\Sigma^{*}$ --- это множество всех конечных строк над алфавитом $\Sigma$.

Контекстно-свободная (КС) грамматика --- это четверка $(\Sigma, N, P, S)$, где $\Sigma$ --- конечное множетство терминальных символов, $N$ --- конечное множество нетерминальных символов, $P$ --- конечное множество правил вида $A \rightarrow \beta$, где $A \in N$, $\beta \in V^{*}$, $V = \Sigma \cup N$ и $S \in N$ --- стартовый символ.

КС-грамматика $G_S = (\Sigma, N, P, S)$ находится в нормальной форме Хомского, если все ее правила имеют следующий вид: $A \rightarrow BC$, $A \rightarrow a$, или $S \rightarrow \varepsilon$, 
где $A, B, C \in N, a \in \Sigma$ и $\varepsilon$ --- пустая строка.

$L_{G}(A) = \{ \omega | A\xrightarrow{*} \omega\}$ --- язык, порождаемый грамматикой $G_{A} = (\Sigma, N, P, A)$, где $A \xrightarrow{*} \omega$ означает, что $\omega$ может быть получена из нетерминала $A$ путем применения некотороый последовательности правил из $P$.

Основной задачей синтаксического анализа является определение принадлежности некоторой строки языку, заданному грамматикой.

% Табличными методами синтаксического анализа строк называются алгоритмы, результатом выполнения которых является матрица разбора $T$. Элементы данной матрицы --- подмножества нетерминалов, и каждый ее элемент отвечает за вывод конкретной подстроки: $T_{i, j} =  \{ A \mid A \in N, a_{i + 1} \dots a_{j} \in L_{G}(A)\} \quad \forall i < j$.

\subsection{Задача поиска путей с контекстно-свободными ограничениями в графе}

Задача поиска путей с контекстно-свободными ограничениями в графе, или, далее для краткости мы ее также будем называть задача синтаксического анализа графов, --- это задача поиска путей в помеченном графе, которые удовлетворяют ограничениям, заданным некоторых формальным языком, в нашем случае, контекстно-свободным.

Ориентированный, помеченный граф --- это тройка $D = (V, E, \Sigma)$, где $V$ --- конечное множество вершин, $E \subseteq V \times \Sigma \times V$ --- конечное множество ребер с метками из $\Sigma$.

Путь из вершины $m$ в вершину $n$ в графе $D$ будем обозначать как $m \lambda n$, где $\lambda$ --- уникальное слово, составленное путем конкатенации всех меток ребер вдоль данного пути. 
Обозначим $\mathcal{P}$ множество всевозможных путей в графе $D$.

Тогда задача поиска путей с контекстно-свободными ограничениями в терминах реляционной семантики запросов~\cite{hellings2015querying} --- это для входных КС-грамматики $G$ и помеченного графа $D$ найти контекстно-свободные отношения $R_A \subseteq V \times V$ для каждого нетерминала $A \in N$, которые заданы следующим образом: $R_A = \{ (m, n) \mid m \lambda n \in \mathcal{P}, \lambda \in L_G(A)\}$. 
Так как каждое отношение $R_A$ конечно, то его можно представить с помощью Булевой матрицы $T_A$: 
$T_A = 1 \Leftrightarrow (i, j) \in R_A$.

\subsection{Матричный алгоритм для синтаксического анализа графов}

Матричный алгоритм был предложен Рустамом Азимовым~\cite{azimov2018context} и вычисляет контектсно-свободные запросы с использованием реляционной семантики.
Он строит матрицу разбора $T$, элементами которой являются множетсва нетерминалов, такие что $A \in T_{i, j} \Leftrightarrow \exists i\lambda j \in R_A$.

Для каждой пары вершин $(i, j)$ инициализируем $T_{i, j} = \{ A \mid (i, a, j) \in E, (A \to a) \in P\}$.
Затем, заполнение матрицы разбора $T$ происходит путем вычисление ее транзитивного замыкания: $M^* = M^{(1)} \cup M^{(2)} \dots$, где $M^{(1)} = M$, $M^{(k)} = M^{(k-1)} \cup (M^{(k-1)} \times M^{(k-1)})$ for $k > 1$.

Также мы можем представить  матрицу $T$ как множество Булевых матриц размера $|V| \times |V|$, такие что $(T_A)_{i, j} = 1 \Leftrightarrow A \in T_{i, j}$ для каждого нетерминала $A \in N$.
Таким образом, мы можем заменить вычисление транзитивного замыкания $T = T \cup (T \times T)$ на несколько умножений Булевых матриц $T_A = T_A + (T_B T_C)$ для каждого правила в грамматике $(A \to BC) \in P$.
Псевдокод данного алгоритма приведен в Листинге~\ref{alg:graphParse}.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\caption{Матричный алгоритм для синтаксического анализа графов}
\label{alg:graphParse}

\State{$T \gets$ the matrix $|V| \times |V|$ in which each element is $\varnothing$}
\ForAll{$(i,x,j) \in E$}
    \State{$T_{i,j} \gets T_{i,j} \cup \{A~|~(A \rightarrow x) \in P \}$}
\EndFor    
\While{matrix $T$ is changing}
   
    \State{$T \gets T \cup (T \times T)$}
\EndWhile
\State \Return $T$
\end{algorithmic}
\end{algorithm}

Несмотря на то, что сложность данного алгоритма $\mathcal{O}(|N|^3|V|^2(BMM(|V|) + BMU(|V|)))$ (здесь $BMM(n)$ и $BMU(n)$ обозначают время, необходимое для перемножения и сложения двух Булевых матриц размера $n \times n$ соответственно), его реализации, в которых используются текники параллельных вычислений и эффективные алгоритмы обработки матричных операций, показывают высокую производительность на реальных данных~\cite{mishin2019evaluation}.

\subsection{Datalog-запросы и синтаксический анализ графов}

Datalog --- декларативный логический язык программирования, использующийся для написания и вычисления запросов к базам данных~\cite{ceri1989you}. 

Программа на языке Datalog состоит из базы данных фактов, которую также называют экстенсиональной базой данных, и правил, с помощью которых можно выводить новые факты из уже имеющихся. Правила предназначены для построения интенсиональной базы данных.

Рассмотрим простую грамматику для описания вложенных скобочных последовательностей: $S \to aSb \mid ab$ и произвольный граф $D =(V, E, \{a, b\})$.
Примерами фактов в данном случае являются $a(0, 1)$ или $b(1, 2)$, которые обозначают "существует ребро из вершины $0$ в вершину $1$ с меткой $a$ в графе $D$" и "существует ребро из вершины $1$ в вершину $2$ с меткой $b$ в графе $D$" соответсвенно.
Правила будут иметь следующий вид:
\begin{align*}
& S(i, j) \text{ :-- } a(i, k), S(k, l), b(l, j) \\
& S(i, j) \text{ :-- } a(i, k), b(k, j).
\end{align*}
А запросом будет выражение, которое вернет все такие пары $(i, j)$, что существует путь из вершины $i$ в вершину $j$, удовлетворяющие отношению $R_S$: $? \text{ :-- } S(i, j)$.

Таким образом, можно описывать КС-запросы к графам в терминах Datalog-запросов.


\subsection{Вычисление Datalog-запросов через решение систем матричных уравнений}

Тайсуке Сато в своей работе~\cite{sato2017linear} предложил фундаментально новый подход к вычислению Datalog-запросов. 
Он рассматривает линейные Datalog-программы, в которых используется $N$ констант и $M$ бинарных предикатов. (В нашем случае, константами являются номера вершин, бинарными предикатами терминальные и нетерминальные символы.) Далее, закодировав все константы $N$-мерными векторами, а предикаты матрицами размера $N \times N$, он свел задачу к решению систем линейных матричных уравнений над $\mathbb{R}$.
Проведенные Сато эксперименты показали, что предложенный подход эффективно справляется с Datalog-запросами к графам размера до $10^4$ вершин и показывает ускорение в $10^1 \sim 10^4$ раз по сравнению с системами B-Prolog, XSB, DLV и Clingo, когда они не используют разреженное представление матриц. 

\subsection{Безматричные методы Ньютона-Крылова}

Пусть дана некоторая нелинейная функция $F(X) = 0$ и начальное приближение $X_0$, тогда метод Ньютона пытается найти решение данной функции путем численного итеративного процесса:
$$X_{i+1} = X_i - (F'(X_i))^{-1} F(X_i)$$ 
или
\begin{equation*}
  \begin{cases}
    F'(X_i) H_i = -F(X_i)\\
    X_{i+1} = X_i + H_i.
  \end{cases}
\end{equation*}
Явным преимуществом данного метода является то, что он обладает квадратичной сходимостью и позволяет находить решение за небольшое число шагов.

Из второй записи итеративного процесса видно, что на каждом шаге необходимо решать линейной уравнение $F'(X_i) H_i = -F(X_i)$. Наиболее эффективными методами решения больших несимметричных систем уравнений являются методы, основанные на подпространствах Крылова, например, метод минимизации невязок с рестартами (GMRES) и его модификации.

Эти методы используют для решения системы уравнений $Ax = b$ подпространства Крылова: $K_j = span(r_0, Ar_0, A^2r_0, \cdot, A^{j-1}r_0)$, где $r_0 = b - A x_0$, $x_0$ --- некоторое начальное приближение.

Можно заметить, что при использовании методов Крылова для решения линейных систем уравнений производная функции $F'(X_i)$ встречается только в умножении вида матрица-вектор и может быть вычислена приближенно:
$$F'(X_i)v \approx \frac{F(X_i + \epsilon v) - F(X_i)}{\epsilon},$$
где $\epsilon$ --- некоторое малое число.

Такие методы, основанные на методе Ньютона с использованием методов решения линейных систем с помощью подпространств Крылова и аппроксимации производной функции, называются безматричными методами Ньютона-Крылова.



\section{Синтаксический анализ графов через решение систем матричных уравнений}

В данном разделе мы собираемся на основе метода, предложенного Сато, свести задачу синтаксического анализа графов к задаче решения систем матричных уравнений. Предполагается, что данное сведение в будущем позволит создавать эффективные реализации для ускорения вычисления контекстно-свободных запросов к графам. Также Сато замечает, что решение нелинейных матричных уравнений точными методами вызывает затруднения как с точки зрения теории, так и с точки зрения практики из-за возникающих проблем с точностью. 


Сначала сведем задачу поиска путей с контекстно-свободными ограничениями в графе к решению систем булевых матричных уравнений.  


Для данных графа $D$ и грамматики $G$ каждый нетерминал и терминал этой грамматики задает конечное отношение $R_A$, которое может быть представлено как Булева матрица аналогично с представлением с матричном алгоритме: 
$$T_E \in \mathbb{M}^{|V| \times |V|}: (T_{E})_{ij} = 1 \iff (i,j) \in R_E \; \  \forall E \in (N \cup \Sigma).$$

Теперь для каждого правила:
$$N_i \to \beta^0_0 \dots \beta^0_k \mid \ldots \mid \beta^l_0 \dots \beta^l_m, \beta^i_j \in \Sigma \cup N$$
мы можем создать соответсвующее ему уравнение над Булевыми матрицами
$$T_{N_i} = T_{\beta^0_0}\cdot \ldots \cdot T_{\beta^0_k} + \ldots + T_{\beta^l_0}\cdot \ldots \cdot T_{\beta^l_m}.$$

Например, рассмотрим небольшой запрос $a^nb^n$, который не может быть описан с помощью регулярного языка. Контекстно-свободная грамматика для него выглядит следующим образом: $S \rightarrow aSb \mid ab$. 
Данный запрос может быть преобразован в следующее уравнение над Булевыми матрицами:
$$T_S = T_AT_ST_B + T_AT_B.$$

Один из способов его решения --- наивный итеративный процесс:
\begin{gather*} 
T_S^0 = \mathbf{0} \\
T_S^{k+1} = T_A T_S^k T_B + T_A T_B
\end{gather*} 

Но, чтобы применять эффективные численные методы, мы должны рассматреть другое уравнение над вещественными числами $\mathbb{R}$:

$$\mathcal{T}_S = \epsilon(T_A \mathcal{T}_S T_B + T_A T_B).$$

Для этого уравнения мы также строим последовательность матриц $\{ \mathcal{T}_S^{k}\}$: 
\begin{gather*} 
\mathcal{T}_S^0 = \mathbf{0} \\
\mathcal{T}_S^{k+1} = \epsilon(T_A \mathcal{T}_S^k T_B + T_A T_B)
\end{gather*} 

Когда  $\mathcal{T}_S^{k} \leq \textbf{1}$ данная последовательность сходится к $\mathcal{T}_S^*$, так как является монотонно возрастающей последовательностью матриц с точной верней границей.
Более того, $((\mathcal{T}_S^{k+1})_{ij} > 0 \Leftrightarrow (T_S^{k+1})_{ij} = 1)$ и, следовательно, $ceil(\mathcal{T}_S^*) = T_S^*$, где $ceil(x)$ --- функция, возвращающая наименьшее целое, которое меньше или равно $x$. 
В следующем разделе будет показано, почему это так и как подбирать необходимую $\epsilon$.

Таким образом, для каждого правила входной грамматики
$$N_i \to \beta^0_0 \dots \beta^0_k \mid \ldots \mid \beta^l_0 \dots \beta^l_m$$
можно построить уравнение над вещественными числами
$$\mathcal{T}_{N_i} = \epsilon_{N_i}(T_{\beta^0_0}\cdot \ldots \cdot T_{\beta^0_k} + \ldots + T_{\beta^l_0}\cdot \ldots \cdot T_{\beta^l_m}), $$
где $\epsilon_{N_i}$ выбрана так, чтобы $\mathcal{T}_{N_i}^{k} \leq \textbf{1}$ для всех $k$ в соответствующем итеративном процессе.



\section{Исследование методов решения полученных уравнений}

Здесь мы попробуем рассмотреть способы решения полученных уравнений. 
Для наглядности, как и в предыдущем разделе, мы остановимся на небольших грамматиках, в которых один нетерминал.
Однако при работе с реальными данными приходится иметь дело с большими грамматиками, в которых более одного нетерминала, поэтому мы также кратко опишем методы решения в тех, случаях, когда мы сталкиваемся с системами уравнений. 

\subsection{Линейный случай}

Рассмотрим уравнение для грамматики $S \rightarrow aSb \mid ab$, полученное в предыдущем разделе:

\begin{equation}
    \mathcal{T}_S = \varepsilon (T_AT_B + T_A\mathcal{T}_S T_B).
\label{eqoverR}
\end{equation}

Это уравнение можно привести к линейной системе с помощью произведения Кронекера:
$$vec(\mathcal{T}_S) = \varepsilon (vec(T_AT_B) + (T_B^T \otimes T_A)vec(\mathcal{T}_S)),$$
где $vec(X)$ --- функция соединяющая столбцы матрицы $X$ в один единый вектор. 

Заметим, что большинство доказательств дублирует ход рассуждений Сато в ~\cite{sato2017linear}, однако мы рассматриваем контекстно-свободную грамматику, в то время как Сато рассматривал в основном регулярные.


\begin{lemma}
Если $\displaystyle  0 < \varepsilon \leq \frac{1}{1 + \| T_B^T \otimes T_A\|}$, тогда последовательность матриц $\{ \mathcal{T}_S^{(k)}\}$: 
\begin{center}
$\mathcal{T}_S^{(0)} = 0$ \\
$vec(\mathcal{T}_S^{(k+1)}) = \varepsilon (vec(T_AT_B) + (T_B^T \otimes T_A)vec(\mathcal{T}_S^{(k)}))$ 
\end{center}
сходится и ее предел равен наименьшему решению уравнения~\ref{eqoverR}.

\end{lemma}

\begin{proof}
Cначала докажем, что $\mathcal{T}_S^{(k)} \leq \mathds{1} \ \forall k \in \mathbb{N}$.

База индукции: очевидно.

Индукционный переход: пусть $\mathcal{T}_S^{(k)} \leq  \mathds{1}$.

\begin{align*}
    vec(\mathcal{T}_S^{(k+1)}) &= \varepsilon (vec(T_AT_B) + (T_B^T \otimes T_A)vec(\mathcal{T}_S^{(k)})) \\
    & \leq \varepsilon (vec(T_AT_B) + (T_B^T \otimes T_A) \mathds{1}) \\
    & \leq \varepsilon (1 + \| T_B^T \otimes T_A\|) \mathds{1}
\end{align*}

Так как $\varepsilon (1 + \| T_B^T \otimes T_A\|) \leq 1$, то $\mathcal{T}_S^{(k+1)} \leq \mathds{1}$

$\{ \mathcal{T}_S^{(k)}\}$ сходится как последовательность монотонно возрастающих матриц с существующей верхней границей 
\begin{align*}
\mathcal{T}_S^{(\infty)} = \lim_{k \to \infty} \mathcal{T}_S^{(k+1)} &= \lim_{k \to \infty}  \varepsilon (T_AT_B + T_A\mathcal{T}_S^{(k)} T_B) \\
&= \varepsilon (T_AT_B + T_A\lim_{k \to \infty}\mathcal{T}_S^{(k)} T_B) = \varepsilon (T_AT_B + T_A\mathcal{T}_S^{(\infty)} T_B)
\end{align*}

Теперь покажем, что для любого другого решения $\mathcal{T}_S'$ выполняется $\mathcal{T}_S^{(\infty)} \leq \mathcal{T}_S'$. Для этого покажем, что $\mathcal{T}_S^{(k)} \leq \mathcal{T}_S' \ \forall k \in \mathbb{N}$

База индукции: $0 \leq \mathcal{T}_S'$.

Индукционный переход: пусть $\mathcal{T}_S^{(k)} \leq  \mathcal{T}_S'$.
\begin{align*}
    vec(\mathcal{T}_S^{(k+1)}) &= \varepsilon (vec(T_AT_B) + (T_B^T \otimes T_A)vec(\mathcal{T}_S^{(k)})) \\
    & \leq \varepsilon (1 + \| T_B^T \otimes T_A\|) \mathcal{T}_S^{(k)}
\end{align*}
Так как $\varepsilon (1 + \| T_B^T \otimes T_A\|) \leq 1$ и $\mathcal{T}_S^{(k)} \leq  \mathcal{T}_S'$, то $\mathcal{T}_S^{(k+1)} \leq  \mathcal{T}_S'$ \ и, следовательно,
$$
\mathcal{T}_S^{(\infty)} = \lim_{k \to \infty} \mathcal{T}_S^{(k+1)} \leq \mathcal{T}_S'.
$$
\end{proof}

\begin{lemma}
$(T_S^{(k)})_{i,j} = 1 \Leftrightarrow (\mathcal{T}_S^{(k)})_{i,j}  > 0$
\end{lemma}

\begin{proof}
База индукции: очевидно.

Индукционный переход: $(T_S^{(k)})_{i,j} = 1 \Leftrightarrow (\mathcal{T}_S^{(k)})_{i,j}  > 0$.

\begin{align*}
(T_AT_S^{(k)}T_B)_{i,j} = 1 
&\Leftrightarrow \exists p, q: (T_A)_{i, p}(T_S^{(k)})_{p, q}(T_B)_{q,j} = 1 \\
&\Leftrightarrow \exists p, q: (T_A)_{i, p} = 1 \text{ и }  (T_S^{(k)})_{p, q} = 1 \text{ и }
(T_B)_{q,j} = 1 \\
& \text{ по индукционному предлоложению } \\
& \Leftrightarrow \exists p, q: (T_A)_{i, p} = 1 \text{ и }  (\mathcal{T}_S^{(k)})_{p, q} > 0 \text{ и }
(T_B)_{q,j} = 1 \\
& \Leftrightarrow (T_A\mathcal{T}_S^{(k)}T_B)_{i,j} > 0 
\end{align*}
\begin{align*}
(T_S^{(k+1)})_{i,j} = 1 
&\Leftrightarrow (T_AT_B + T_AT_S^{(k)}T_B)_{i,j} = 1 \\
&\Leftrightarrow  (T_AT_B)_{i,j} = 1 \text{ или } (T_AT_S^{(k)}T_B)_{i,j} = 1 \\
&\Leftrightarrow (T_AT_B)_{i,j} = 1 \text{ или } (T_A\mathcal{T}_S^{(k)}T_B)_{i,j} > 0  \\
&\Leftrightarrow (\mathcal{T}_S^{(k+1)})_{i,j} = (\varepsilon (T_AT_B + T_A\mathcal{T}_S^{(k)}T_B))_{i,j} > 0
\end{align*}
\end{proof}

\begin{lemma}
Пусть $\mathcal{T}_S^*$ --- наименьшее решение уравнения~\ref{eqoverR} и $\displaystyle  0 < \varepsilon \leq \frac{1}{1 + \| T_B^T \otimes T_A\|}$, тогда $T_S^*$, построенная следующим образом: 

\begin{equation}
(T_S^*)_{i, j} =
\begin{cases}
  1, & \text{ если } (\mathcal{T}_S^*)_{i, j} > 0 \\
  0, & \text{ иначе}
\end{cases}
\end{equation}
является наименьшим решением уравнения~\ref{eqbool}.
\end{lemma}

\begin{theorem}
Если $\displaystyle  0 < \varepsilon \leq \frac{1}{1 + \| T_B^T \otimes T_A\|}$, то $\mathcal{T}_S^* = (I \otimes I - \varepsilon (T_B^T \otimes T_A))^{-1} \varepsilon \ vec(T_AT_B)$ --- наименьшее решение  уравнения~\ref{eqoverR}, а $T_S^*$, построенное как в лемме 3, является наименьшим решением уравнения~\ref{eqbool}.
\end{theorem}

\begin{proof}
$$\mathbb{\rho} (\varepsilon (T_B^T \otimes T_A))) \leq \varepsilon \|T_B^T \otimes T_A\|  \leq 1 -\varepsilon < 1$$ 
$\Rightarrow (I \otimes I - \varepsilon (T_B^T \otimes T_A))^{-1}$ существует и уравнение~\ref{eqoverR} имеет единственное решение, которое совпадает с $\mathcal{T}_S^*$. 
\end{proof}

Таким образом, при корректном подборе $\epsilon$ наше уравнение будет иметь единственное решение. 
Уравнения вида $\sum_{i=1}^n A_iXB_i = C$ называются уравнениями Сильвестра и для $k = 1, 2$ могут быть решены за  $\mathcal{O}(|V|^3)$~\cite{Bartels:1972:SME:361573.361582}. 
В случае $k > 2$ их можно свести с линейной системе с помощью произведения Кронекера (как было показано выше) $Ax = b$, где $A$ --- матрица размера  $(|V|^2\times|V|^2)$ и время, необходимое для нахождения решения --- это  $\mathcal{O}(|V|^6)$ or $\mathcal{O}(|V|^{4+2\omega})$ используя более эффективные алгоритмы перемножения матриц (здесь $\mathcal{O}(n^{2+\omega})$ --- временная сложность умножения двух матриц размера $n \times n$).
Использование разреженного представления матриц и приближенных методов может быть эффективно для решения уравнений такого вида ~\cite{bouhamidi2008}.

Если же мы имеем дело с системами уравнений, то мы должны построить граф зависимостей для нетерминалов входной грамматики и разбить множетсво наших уравнений на непересекающиеся подмножетсва в соответсвии с сильносвязными компонентами этого графа, а затем решать систему поэтапно для каждого полученного подмножетсва.


\subsection{Нелинейный случай}

Рассмотрим грамматику $S \rightarrow SS \mid aSb \mid ab$, которая описывает язык правильных скобочных последовательностей, и её уравнение:
\begin{equation*}
    \mathcal{T}_S = \varepsilon (\mathcal{T}^2_S +  T_AT_B + T_A\mathcal{T}_S T_B).
\end{equation*}

Для решения нелинейных систем лучше всего подходят различные численные итеративные методы, однако метод наивной итерации сходится долго. Мы также можем ввести функцию $F(\mathcal{T}_S) = \mathcal{T}_S - \varepsilon (\mathcal{T}^2_S +  T_AT_B + T_A\mathcal{T}_S T_B) = 0$ и решать ее методом Ньютона, который обладает квадратичной сходимостью.

Теперь покажем, почему безматричный метод Ньютона-Крылова подходит для решения таких систем уравнений. 
Кроме его известных преимуществ, таких как уже упомянутая скорость сходимости и аппроксимация производной, которая позволяет существенно ускорить вычисления, данный метод также, в нашем случае, никогда не будет изменять элементы, которые в результирующей матрицы должны быть нулевыми.

На этапе решения линейной системы $F'(X_i) H_i = -F(X_i)$ методами основанными на подпространствах Крылова начальное приближение $x_0$ выгодно  и следует брать нулевым, то $r_0 = -F(X_i)$. Производная у нас считается приближенно по следующей формуле 
$$F'(X_i)v \approx \frac{F(X_i + \epsilon v) - F(X_i)}{\epsilon},$$
и в качестве вектора у нас может служить только некоторый элемент подпространства Крылова.
То есть все остальные элементы образованы только применением функции либо к $X_0$ (которое также следует взять нулем), либо к комбинации $X_i$ и $\epsilon X_j$, что не может привести к изменению элементов, которые в $\mathcal{T}^*_S$ равны нулю.

Главным недостатком использования метода Ньютона и вообще решения систем нелинейных уравнений является подбор $\epsilon$, для сходимости она должна быть менее $\frac{1}{|V|}$. Данную проблему можно решать только ad-hoc учитывая размер и разреженность данных.

\section{Эксперименты}

Мы проведем сравнительный анализ нашего метода с матричным алгоритмом синтаксического анализа графов и рассмотрим дальнейшие пути улучшения реализаций предложенного метода.

Главной целью данных экспериментов показать применимость предложенного алгоритма на реальных данных. 
Для сравнения был выбрали матричный алгоритм синтаксического анализа графов~\cite{azimov2018context}, так как в его основе также лежит сведение к другой проблеме с уже существующими эффективными решениями, и GLL для графов~\cite{grigorev2017context}, который обладает лучшей асимптотической сложностью, равной $\mathcal{O}(|V|^4)$. Реализации и данные результатов экспериментов были взяты из соответсвующих статей. Названия реализаций остались прежними.

Алгоритмы сравнивались на двух запросах, правила которых представлены на рисунках ~\ref{ProductionRulesQuery1} и ~\ref{ProductionRulesQuery2}. Графы для запросов были взять из работы~\cite{RDF}.

\begin{figure}[h]
   \[
\begin{array}{rccl}
   S & \rightarrow & \text{\emph{subClassOf}}^{-1} \ S \ \text{\emph{subClassOf}} \\ 
   S & \rightarrow & \text{\emph{type}}^{-1} \ S \ \text{\emph{type}} \\ 
   S & \rightarrow & \text{\emph{subClassOf}}^{-1} \ \text{\emph{subClassOf}} \\ 
   S & \rightarrow & \text{\emph{type}}^{-1} \ \text{\emph{type}} \\ 
\end{array}
\]
\caption{Правила грамматики для запроса 1.}
\label{ProductionRulesQuery1}
\end{figure}


\begin{figure}[h]
   \[
\begin{array}{rccl}
   S & \rightarrow & \text{\emph{subClassOf}}^{-1} \ S \ \text{\emph{subClassOf}} \\ 
   S & \rightarrow & \text{\emph{subClassOf}} \\
\end{array}
\]
\caption{Правила грамматики для запроса 2.}
\label{ProductionRulesQuery2}
\end{figure}

Уравнения для запросов 1 и 2 были сконструированы и решены на языке программирования Python с помощью библиотеки \textit{scipy} ~\cite{scipy}:
    \begin{itemize}
        \item в \textbf{sLSV} использовалась функция $spsolve$ для решения разреженных линейных систем;
        \item в \textbf{JFNK} использовалась функция $optimize.newton_krylov$ для решения уравнения безматричным методом Ньютона-Крылова.
    \end{itemize}


\begin{table*}[h]
\caption{Результаты сравнения с матричным алгоритмом для запроса 1 (в мс)}
\label{tbl1}
\centering\resizebox{0.85\textwidth}{!}{\begin{minipage}{\textwidth}
\begin{tabular}{ | c | c | c | c | c | c | c || c | c |}
\hline
Ontology & V & E & GLL & dGPU & sCPU & sGPU & sLSV & JFNK\\
\hline 
\hline
skos        & 144 & 323 & 10 & 56 & 14 & 12 & 9 & 13\\
generations & 129 & 351 & 19 & 62 & 20 & 13 & 9 & 14\\
travel      & 131 & 397 & 24 & 69 & 22 & 30 & 10 & 65\\
univ-bench  & 179 & 413 & 25 & 81 & 25 & 15 & 13 & 61\\
atom-primitive & 291 & 685 & 255 & 190 & 92 & 22 & 32 & 190\\
biomedical-measure-primitive & 341 & 711 & 261 & 266 & 113 & 20 & 50 & 421 \\
foaf        & 256 & 815 & 39 & 154 & 48 & 9 & 26 & 100\\
people-pets & 337 & 834 & 89 & 392 & 142 & 32 & 51 & 305\\
funding     & 778 & 1480 & 212 & 1410 & 447 & 36 & 213 & 1910\\
wine        & 733 & 2450 & 819 & 2047 & 797 & 54 & 410& 2220\\
pizza       & 671 & 2604 & 697 & 1104 & 430 & 24 & 1710 & 1500\\
\hline
\end{tabular}
\end{minipage} }
\end{table*}

\begin{table*}[t]
\caption{Результаты сравнения с матричным алгоритмом для запроса 2 (в мс)}
\label{tbl2}
\centering\resizebox{0.85\textwidth}{!}{\begin{minipage}{\textwidth}
\begin{tabular}{ | c | c | c | c | c | c | c || c | c |}
\hline
Ontology & V & E & GLL & dGPU & sCPU & sGPU & sLSV & JFNK)\\
\hline 
\hline
skos        & 144 & 323 & 1 & 10 & 2 & 1 & 7 & 5\\
generations & 129 & 351 & 1 & 9 & 2 & 0 & 5 & 0\\
travel      & 131 & 397 & 1 & 31 & 7 & 10 & 5 & 51\\
univ-bench  & 179 & 413 & 11 & 55 & 15 & 9 & 8 & 40\\
atom-primitive & 291 & 685 & 66 & 36 & 9 & 2 & 27& 40\\
biomedical-measure-primitive & 341 & 711 & 45 & 276 & 91 & 24 & 35 & 284\\
foaf        & 256 & 815 & 2 & 53 & 14 & 3 & 16 & 26\\
people-pets & 337 & 834 & 3 & 144 & 38 & 6 & 49 & 73\\
funding     & 778 & 1480 & 23 & 1246 & 344 & 27 & 184 & 502\\
wine        & 733 & 2450 & 8 & 722 & 179 & 6 & 171 & 791\\
pizza       & 671 & 2604 & 29 & 943 & 258 & 23 & 161 & 334\\
\hline
\end{tabular}
\end{minipage} }
\end{table*}

Полученые результаты показывают, что предложенный метод и его первая реализация уже показывают лучший результат, чем первые реализации сравниваемых алгоримов. Во многих случаях \textbf{JFNK} проигрывает другим реализациям, потому что в нем не используются ни параллельные вычисления, ни разреженное представление матриц. 

Таким образом, можно сделать вывод, что предложенный подход показывает неплохое время работы, сравнимое с другими алгоритмами синтаксического анализа графов и демонстрирует свою практическую применимость. Однако предложенные решения плохо маштабируются и для работы с большими данными потребуется более эффективная реализация, использующая параллельные вычисления или другие высоко-производительные библиотеки для численных методов. 

       
% \section{Синтаксический анализ взвешенных графов и взвешенные грамматики}

% В этом разделе мы наметим основные направления будущих исследований и оценим возможности решения классов матричных (систем) уравнений через синтаксический анализ графов с ограничениями, заданными взвешенными грамматиками.
    

% \subsection{Решение матричных уравнений через синтаксический анализ графов с ограничениями, заданными взвешенными грамматиками}

% \subsection{Взвешенные грамматики и различные формализмы их описания}

% Взвешенная контекстно-сободная грамматика (WCFG) $G_\Theta$ --- пара $(G, \Theta)$: $G$ --- контекстно-свободная грамматика $(N, \Sigma, S, P)$; $\Theta: P \rightarrow \mathbb{R}^+$.

% Стохастическая грамматика (SCFG) $G_\Theta$ --- пара $(G, \Theta)$: $G$ --- контекстно-свободная грамматика $(N, \Sigma, S, P)$; $\Theta: P \rightarrow (0, 1]$, т.ч. $\forall A \in N : \sum_{i=1}^{n_A} \Theta(A \rightarrow \alpha_i) = 1$, $n_A$ --- количество правил с нетерминалом A в левой части.

% Контекстно-свободная грамматика со взвешенными правилами (RWCFG) $G_\lambda = (G, \lambda)$: $G$ --- контекстно-свободная грамматика $(N, \Sigma, S, P)$; $\lambda: P \rightarrow \mathbb{R}^+$.

% Контекстно-свободная грамматика со взвешенными терминалами (TWCFG) $G_\pi = (G, \pi)$: $G$ --- контекстно-свободная грамматика $(N, \Sigma, S, P)$; $\pi: \Sigma \rightarrow \mathbb{R}^+$.


\section{Заключение}
В данной работе были получены следующие результаты.

\begin{itemize}
	  \item Задача CFPQ была сведена к задаче решения матричных уравнений над множеством вещественных чисел $\mathbb{R}$
      \item Исследованы способы решения полученных линейных и нелинейных уравнений как точными методами, так и приближенными
      \item Поставлены первые эксперименты применения полученного подхода к CFPQ и проведен сравнительный анализ с существующими аналогами
      \item На основе полученных результатов написана работа \linebreak “Context-Free Path Querying via Matrix Equations”, которая была принята во второй очный тур ACM SIGMOD 2020 Student Research Competition.
\end{itemize}

Кроме того, мы можем определить несколько направлений будущих исследований. 

\begin{itemize}
    \item Эффективная реализация предложенного подхода с использованием специализированных библиотек и параллельных вычислений.
    \item Определение подклассов полиномиальных уравнений, решение которых может быть сведено к CFPQ.
    \item Попытка построить взаимное сведение между CFPQ и решением соответсвующих подклассов уравнений.
\end{itemize}

\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{references}

\end{document}