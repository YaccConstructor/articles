\section{Brahma.FSharp}

Brahma.FSharp is a tool that allows one to utilize GPGPUs in .NET applications and write kernels and all supplementary code in pure F\#~\cite{fsharp} that is a functional-first multiparadigmal programming language for .NET platform.
This language combines functional programming, including first-class functions, generics, static strong typing with automatic type inference, with transparent integration with the a platform for business applications development with mature infrastructure.
At the same time, F\# provides an ability to write imperative code that is native for kernel programming.

Core of the tool is a translator of F\# subset to OpenCL C that is based on \emph{code quotations}~\cite{FSharpQuotations} that allows one to get access to annotated tree of the F\# code and transform it during program execution.
This tree can be transformed using regular F\# functions: for example, it can be translated to other language, that is we do to generate OpenCL C code for kernels.
Other words, code quotations is a running time metaprogramming feature that allows us to create running-time configurable kernels.
For example, it is possible, in opposite to compile time metaprogramming, configure work group size dependent parts of kernel (e.g. local buffer size) without recompilation of whole program (look at line 9 of listing~\ref{lst:mXm_kernels}).
The main feature is that all is strongly and statically typed: no unsafe code that uses strings, pointers, objects, etc.
At the user side, compiled quotation (compiled kernel) has the signature that requires parameters of types that are in agreement with initial quotation.

An example of quoted code (actually, part of the generalized mXm kernel) is presented in listing~\ref{lst:mXm_kernels} (lines 6--12).
This code also demonstrates typed composition of quotations: operations \verb|opAdd| and \verb|opMult|, and identity element \verb|zero|, have agreed types and can be specified outside the kernel in run time.
So, we can write highly configurable kernels generator and instantiate specific kernels later, as shown in lines 15--16.

The translator supports not only imperative subset of F\# and primitive types, but also F\#-specific features like structs, tuples, discriminated unions, pattern matching, nested bindings.
Also it supports OpenCL specific features like atomic functions, barriers, local and thread-local allocation arrays allocation.
For data transferring and manipulation Brahma.FSharp provides specified memory primitives (\verb|ClArray<'t>| and \verb|ClCell<'t>|) that is F\#-array-friendly wrappers around \texttt{ClBuffer}.

Brahma.FSharp provides typical workflow to run kernels and implements respective typed wrappers for it\footnote{Configure of path to \texttt{libopencl} making the solution portable.}.
It is worth noting that F\# is friendly to asynchronous programming and provides huge amount of parallel and asyncronious programming primitives~\cite{FSharpAsync}.
Utilization of \emph{mailbox processor}, that is F\#-native massage passing primitive, to wrap command queue allows us to make communication with GPGPU friendly for asynchronous programming in F\#.