\section{Brahma.FSharp}

Brahma.FSharp is a tool that enables GPGPU utilization in .NET applications, allowing developers to write both kernels and supporting code in pure F\#~\cite{fsharp}---a functional-first, multiparadigmal programming language for the .NET platform.
This language combines functional programming features (including first-class functions, generics, and static strong typing with automatic type inference) with seamless integration into a mature business application development platform.
Additionally, F\# supports imperative coding patterns that are natural for kernel programming.

The tool's core is an F\#-subset-to-OpenCL-C translator based on \emph{code quotations}~\cite{FSharpQuotations}---language feature that provides access to an annotated syntax tree of F\# code and to transform it during program execution.
This tree can be processed using standard F\# functions: for instance, we transform it to generate OpenCL C kernel code.
In other words, code quotations enable runtime metaprogramming for creating configurable kernels during program execution.
Unlike compile-time metaprogramming, this approach enables dynamic configuration of work-group-dependent kernel aspects (such as local buffer sizes) without full program recompilation (see line 9 in Listing~\ref{lst:mXm_kernels}). 
Crucially, all operations remain strongly and statically typed, eliminating the need for unsafe code involving strings, pointers, or object manipulation.
From the user's perspective, a compiled quotation (compiled kernel) exposes a type signature that enforces parameter consistency with the original quotation.
In other words, the compiled kernel retains full type information about its arguments, enabling the compiler to verify parameter binding correctness at compile-time without needing additional type annotations.

Actually, creating a truly generic \texttt{compile} function that converts high-level code to compiled kernels is a nontrivial challenge. 
As a result, many other tools either erase all type information or require manual type specifications. 
For example, ILGPU requires manual specification of the compiled kernel type.

Listing~\ref{lst:mXm_kernels} (lines 6-12) shows an example of quoted code (part of a generalized matrix multiplication kernel).
This example demonstrates typed quotation composition: the operations \verb|opAdd| and \verb|opMult|, along with the identity element \verb|zero|, maintain type consistency and can be specified externally at runtime.
Thus, we can create highly configurable kernels generator and instantiate specific kernels as needed (lines 15-16).

\begin{listing}
    \begin{minted}[linenos]{fsharp}
  let mXmKernel    
     (opAdd: Quotations.Expr<'a -> 'b -> 'a>) 
     (opMult: Quotations.Expr<'e -> 'f -> 'b>) 
     (zero: Quotations.Expr<'a>) ... (* other parameters *)  =
        ... // Supplementary code
        let kernel = <@ fun 2dRange m1 m2 res ->  // Quoted code
          ... 
          let acc = %zero // Embedded identity value
          let lBuf = localArray lws // captured from context
          ... 
          acc <- (%opAdd) acc ((%opMult) x y) // Embedded operations
          ... @>
        ... // Supplementary code
    
  let intArithmeticKernel = mXmKernel <@ (+) @> <@ ( * ) @> <@ 0 @>
  let intMinPlusKernel = 
      mXmKernel <@ (min) @> <@ (+) @> <@ Int.MaxValue @>
    \end{minted}
    \caption{An example of generic matrix multiplication kernel}
    \label{lst:mXm_kernels}
  \end{listing}

The translator supports not only the imperative subset of F\# and primitive types, but also F\#-specific features including structs, tuples, discriminated unions, pattern matching, and nested bindings.
Additionally, it implements OpenCL-specific functionality such as atomic operations, memory barriers, and allocation of local/thread-local arrays.
For data transfer and manipulation, Brahma.FSharp provides two key primitives---\verb|ClArray<'t>| and \verb|ClCell<'t>|--- that are F\#-array-friendly wrappers for \texttt{ClBuffer}.

The framework implements a standard kernel execution workflow with typed wrappers\footnote{Portability is achieved through configurable \texttt{libopencl} path specification.}
It is worth noting that F\# is friendly to asynchronous programming and provides huge amount of parallel and asynchronous programming primitives~\cite{FSharpAsync}.
By utilizing \emph{MailboxProcessor}---F\#'s built-in message passing primitive---to wrap command queues, we achieve GPGPU communication patterns that naturally complement F\#'s asynchronous programming model.