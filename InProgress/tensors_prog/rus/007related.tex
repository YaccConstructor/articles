% !TeX encoding = windows-1251
% !TeX spellcheck = ru_RU
% !TEX root = mainrus.tex

Дизайн и реализация GUI~--- горячая тема уже много десятилетий, поэтому можно найти много инструментов, подходов, статей и отчётов по теме. Большая часть из них (если не все) предлагают декларативные и автоматические решения. Но если присмотреться, то их понятия \enquote{декларативности} и \enquote{автоматизации} отличаются от наших.

%GUI design and implementation has been a hot topic for decades. Thus, to no surprise there is a lot of frameworks, approaches, papers
%and reports on the subject. A fair share of them (if not all) present declarative and automatic solutions. A careful study, however,
%discovers that this ``declarativeness'' and ``automation'' is understood differently then in our case.

Во-первых, необходимо упомянуть некоторое количество инструментов для реализации GUI и визуализации данных, например,
\textsc{React}~\cite{react},
\textsc{Jetpack Compose}~\cite{Jetpack}, \textsc{Streamlit}~\cite{Streamlit} и другие.
Они предоставляют пользователю наборы примитивов, которые позволяют отображать данные и пользовательский интерфейс. Например, \textsc{Streamlit}
предоставляет набор встроенных примитивов отображения: \enquote{колонки}, \enquote{контейнеры}, \enquote{модальные диалоги} и т.п.~\cite{StreamlitLayout}, а также множество внешних компонент. Эти примитивы позволяют пользователям абстрагироваться от конкретного вычисления координат и относительного выравнивания. Также они предоставляют разумное поведение при изменении размера холста. Однако, выбор конкретного примитива остаётся на усмотрение разработчика, а не определяется системой.
И если расположение элементов должно по какой-то причине измениться, то эти изменения нужно реализовывать вручную. В нашем случае, разработчики не задают конкретное расположение, а только логическую структуру пользовательского интерфейса.
Предписание определяет конкретное расположение элементов управления,
в зависимости от внешних ограничений, таких как разрешение экрана или региональные настройки (например, письмо справа-налево). Пока логическая структура не изменяется,
не потребуется никакого взаимодействия с программистом для отображения интерфейса по-другому. С другой стороны, данные инструменты могут использоваться совместно c нашим как способ визуализации интерфейса, так как они предоставляют сходные примитивы расположения. В этой работе мы таким образом задействовали Qt/QML.

Программирование в ограничениях уже использовалось для размещения элементов управления GUI.
Одним из примеров реактивного языка программирования в ограничениях является язык \textsc{Wallingford}~\cite{Wallingford2016} и система \textsc{Cassowary}~\cite{Cassowary2001}.
\textsc{Wallingford} позволяет задавать ограничения различной силы к значениям в программе. Система реагирует на изменения времени и обновляет значения, не нарушая ограничения.
Например, можно реализовать элемент управления с шириной, равной синусу текущего времени.
Система \textsc{Cassowary} и её потомки позволяют вычислять размеры и положения элементов динамически, например при изменении размера холста.
Она поддерживает множество ограничений, в том числе глубину по оси Z; арифметические операции (например, ширина одного элемента может быть половиной высоты другого); элементы, накладывающиеся друг на друга и т.д.
Эта система предназначена для задач автоматической изменения размеров элементов при изменении общего размера холста.
Однако она не предоставляет поддержки правил общего вида для корректного позиционирования элементов.
Мы сомневаемся в выразимости неоднозначных расположений элементов в данных системах, например, если вертикально или горизонтальное взаимоположение определяется на основе размеров. С другой стороны, количество различных ограничений больше, чем у нас. Например, поддержка накладывающихся друг на друга элементов управления запрещена у нас с самого начала, и такие расположения не создаются вообще.

В последние годы появились методы на основе машинного обучения. Некоторые работы ставят гораздо более амбициозные цели, чем наши.

Существует направление исследования, занимающееся порождением кода UI на основе картинок~\cite{Cai2023}.
По полученному от дизайнера рисунку интерфейса инструмент распознает элементы управления и их относительное местоположение, и создает код реализации для инструмента создания GUI.
Подход ортогонален и не совместим с предлагаемым нами. Он требует взаимодействия с дизайнером во время получения каждой части интерфейса, у нас же дизайнер задействован только при описании предписания. Также наш подход позволяет создавать много интерфейсов автоматически. В инструменте~\cite{Robust} была поставлена несколько другая задача: по картинке интерфейса синтезируется его реализация в терминах примитивов Android GUI, масштабируемая между различными устройствами и без типичных ошибок. Для выполнения этой задачи из картинки извлекается элементы управления, их местоположения, а также некоторые ограничения.
Эти ограничения напоминают наши примитивы расположения, но специализированы для семантики виджета \textsc{ConstraintLayout}~\cite{ConstraintLayout} из Android.
На основе этих ограничений и набору \emph{свойств надёжности}, разработанному авторами, вероятностная модель, обученная на большем наборе существующих интерфейсов, порождает код.
Эти реализации более устойчивы к измерению размера и  разрешения экрана, чем полученные только путём распознавания картинок.
Любопытно, что авторы мотивируют свою работу, заявляя, что \enquote{одно и то же расположение должно отображаться более чем на 15000 устройствах Android с $\approx$100 различных плотностей пикселей; требовать от программистов разработки и поддержки всех сочетаний входа чрезвычайно не желательно}.
Именно   это делает наша система за несколько минут со 100\% точностью, поэтому мы считаем свой подход более общим.

Также решалась задача согласованного во всём приложении оформления GUI~\cite{LearningGUI}.
Подход основан на идее дополнения:
в предположении, что уже есть набор согласованных расположений, решается проблема добавления ещё одного элемента так, чтобы новое расположение было согласовано со старым. Эта задача связана с нашей, так как мы можем рассматривать уже существующее расположение как неявно заданное предписание, но мы можем указать несколько потенциальных недостатков. Во-первых,  учитывается только добавление элементов, без удаления. Во-вторых, добавление/удаление компонент не обязательно приводит к \enquote{монотонному} изменению расположения: добавление ещё одного поля ввода может существенно поменять расположение. Наконец, начальный согласованный дизайн редко появляется \enquote{из воздуха}, наверняка это результат следования уже существующему предписанию, которое было описано явно.

%Automatic design of consistent (uniform throughout an application) GUI is addressed in~\cite{LearningGUI}. The approach is based on the idea of completion:
%assuming there is already a set of consistent layouts a problem of adding yet another element is addressed; the addition should be consistent with the previous
%designs. While this problem is, indeed, related to that we address (indeed, consider an existing set of designs as an implicitly specified guideline),
%we can identify a number of potential weaknesses. First, only addition of a component is considered, but not removal; second, the addition/subtraction
%of components does not necessarily lead to a ``monotonic'' change of the layout (adding yet another text field may result is a drastically different placement);
%finally, the initial set of designs to be consistent with rarely comes out of a thin air; most likely it is a result of following some
%existing (and perhaps implicit) guidelines, which should be specified and followed explicitly.

В системе~\cite{Grid} поставлена гораздо более широкая задача синтеза без предписания, а только на основе эстетических, эргономических и других метрик.
Для синтеза используется генетический алгоритм, а качество вычисляется на основе отзывов пользователей. Сам синтез работает часами. Хотя подход потенциально позволяет создавать эстетически приятные интерфейсы без участия дизайнера, задача получения корректного расположения для существенно разных структур обходится стороной.

%In~\cite{Grid} a much more ambitious problem of synthesizing a layout with no guidelines, based only on aesthetic, ergonomic, etc., metrics is considered.
%Genetic algorithm is employed for synthesis, and users' feedback is used as a way to measure the quality of the synthesis; the synthesis itself can
%sometimes take hours. While the approach presumably allows to synthesize aesthetically convincing layouts with no designer input, the problem of
%layout consistency for sufficiently different structures is left unaddressed.

Встречается интересная задача~\cite{Scout} исследования различных расположений элементов. Она ставит своей целью помочь дизайнерам разрабатывать убедительные и разнообразные расположения элементов управления. Вводится набор ограничений, с помощью которого дизайнеры составляют требования к результату.
Любопытно, что в наших терминах этот набор ограничений является смесью структурных ограничений и ограничений на расположение: например, можно указывать и порядок элементов, и выравнивание. По набору ограничений система порождает множество расположений, удовлетворяющих им.
Изменяя ограничения, дизайнер исследует возможные интерфейсы.
Для решения ограничений используется метод ветвей и границ. С ростом числа возможных решений применяются эвристики для отсечения эстетически неподходящих ответов.
Несмотря на то, что эта работа похожа на нашу, она нацелена на дизайнеров и может рассматриваться скорее как средство разработки предписаний, чем как средство получения расположения элементов, удовлетворяющего предписанию.

%An interesting problem of layout exploration is considered in~\cite{Scout}. The objective is to help the \emph{designers} to develop convincing and
%diverse layouts. A set of constraints is introduced which designers can use in order to specify some requirements for the design. Interestingly, in our terms the
%set of constraints is a mixture of layout and structural ones: for example, both order and alignment constraints are present. Given
%a number of constraints the system generates a set of layouts consistent with this constraints; by updating the constraints a designer can
%continue the exploration. As a constraint solver modifier branch-and-bound algorithm is used; as the number of feasible solutions
%turned out to be enormous a set of heuristic metrics was developed to rule aesthetically unfeasible designs out. While this work
%shares some similarities with ours, being targeted on designers it can be considered as a mean to \emph{develop guidelines}, not to synthesize
%guideline-consistent designs.
