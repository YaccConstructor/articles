\chapter{Обзор}\label{ch:ch1}
В данной главе введены основные термины и определения, используемые в работе, а также рассмотрены основные алгоритмы вычисления КС-запросов к графам и используемые в ходе исследования инструменты. 

\section{Линейная алгебра}
В данном разделе вводится ряд обозначений, а также представляется основная информация из линейной алгебры.

Операции над матрицами

Операции над векторами

Определение полукольца. Матричное умножение на полукольце.

Произведение Кронекера.

\section{Теория графов}\label{sec:ch1/sec1}
В данном разделе вводится ряд обозначений, а также представляется основная информация из теории графов.

\begin{definition}
	\textit{Граф} $\mathcal{G} = \langle V, E, L \rangle$, где $V$ --- конечное множество вершин, $E$ --- конечное множество рёбер, т.ч. $E \subseteq V \times L \times V$, $L$ --- конечное множество меток на рёбрах.
\end{definition}

В дальнейшем речь будет идти о конечных ориентированных помеченных графах.
Мы будем использовать термин \textit{граф} подразумевая именно конечный ориентированный помеченный граф, если только не оговорено противное.

Также мы будем считать, что все вершины занумерованы подряд с нуля.
То есть можно считать, что $V$ --- это отрезок $[0, |V| - 1]$ неотрицательных целых чисел, где $|V|$ --- размер множества $V$.

\begin{example}[Пример графа и его графического представления]
	Пусть дан граф $$\mathcal{G}_1 = \langle \{0,1,2,3\}, \{(0,a,1), (1,a,2), (2,a,0), (2,b,3), (3,b,2)\}, \{a,b\} \rangle.$$
	Графическое представление графа $\mathcal{G}_1$ изображено на~\cref{fig:example_graph}.
\end{example}

\begin{figure}
	\begin{center}
		\begin{tikzpicture}[on grid, auto]
		\node[state] (q_0)   {$0$};
		\node[state] (q_1) [above right=1.4cm and 1.0cm of q_0] {$1$};
		\node[state] (q_2) [right=2.0cm of q_0] {$2$};
		\node[state] (q_3) [right=2.0cm of q_2] {$3$};
		\path[->]
		(q_0) edge  node {a} (q_1)
		(q_1) edge  node {a} (q_2)
		(q_2) edge  node {a} (q_0)
		(q_2) edge[bend left, above]  node {b} (q_3)
		(q_3) edge[bend left, below]  node {b} (q_2);
		\end{tikzpicture}
	\end{center}
	\caption{Графическое представление графа $\mathcal{G}_1$.}
	\label{fig:example_graph}
\end{figure}

\begin{definition}
	\textit{Ребро} ориентированного помеченного графа $\mathcal{G} = \langle V, E, L \rangle$ это упорядоченная тройка $e = (v_i,l,v_j) \in V \times L \times V$.
\end{definition}

\begin{example}[Пример рёбер графа]
	$(0,a,1)$  и $(3,b,2)$ --- это рёбра графа $\mathcal{G}_1$. При этом, $(3,b,2)$ $(2,b,3)$ --- это разные рёбра, что видно из~\cref{fig:example_graph}.
\end{example}

\begin{definition}
	\textit{Путём} $\pi$ в графе $\mathcal{G}$ будем называть последовательность рёбер такую, что для любых двух последовательных рёбер $e_1=(u_1,l_1,v_1)$ и $e_2=(u_2,l_2,v_2)$ в этой последовательности, конечная вершина первого ребра является начальной вершиной второго, то есть $v_1 = u_2$. Будем обозначать путь из вершины $v_0$ в вершину $v_n$ как $$v_0 \pi v_n = e_0,e_1, \dots, e_{n-1} = (v_0, l_0, v_1),(v_1,l_1,v_2),\dots,(v_{n-1},l_n,v_n).$$
\end{definition}

\begin{example}[Пример путей графа]
	$(0,a,1),(1,a,2) = 0\pi_1 2$  --- путь из вершины 0 в вершину 2 в графе $\mathcal{G}_1$.
	При этом, $(0,a,1),(1,a,2),(2,b,3),(3,b,2) = 0\pi_2 2$ --- это тоже путь из вершины 0 в вершину 2 в графе $\mathcal{G}_1$, но он не равен $0\pi_1 2$.
\end{example}

Кроме того, нам потребуется отношение, отражающее факт существования пути между двумя вершинами.

\begin{definition}\label{def:reach}
	\textit{Отношение достижимости} в графе:
	$(v_i,v_j) \in P \iff \exists v_i \pi v_j$.
\end{definition}

Отметим, что рефлексивность этого отношения часто зависит от контекста.
В некоторых задачах по-умолчанию $(v_i,v_i) \notin P$, а чтобы это было верно, требуется явное наличие ребра-петли.

В данном исследовании мы будем задавать граф через его \textit{матрицу смежности}.

\begin{definition}
	\textit{Матрица смежности} графа $\mathcal{G}=\langle V,E,L \rangle$ --- это квадратная матрица $M$ размера $n \times n$, где $|V| = n$ и ячейки которой содержат множества.
	При этом $l \in M[i,j] \iff \exists e = (i,l,j) \in E$.
\end{definition}

Заметим, что наше определение матрицы смежности отличается от классического, в котором матрица отражает лишь факт наличия хотя бы одного ребра и, соответственно, является булевой. То есть $M[i,j] = 1 \iff \exists e = (i,\_,j) \in E$.

\begin{example}[Пример графа и его матрицы смежности]
	Помеченный граф:
	\begin{center}
		\begin{tikzpicture}[shorten >=1pt,on grid,auto]
		\node[state] (q_0)   {$0$};
		\node[state] (q_1) [above right = 1.4cm and 1cm of q_0] {$1$};
		\node[state] (q_2) [right = 2cm of q_0] {$2$};
		\node[state] (q_3) [right = 2cm of q_2] {$3$};
		\path[->]
		(q_0) edge  node {a} (q_1)
		(q_1) edge  node {a} (q_2)
		(q_2) edge  node {a} (q_0)
		(q_2) edge[bend left = 20]  node {a} (q_3)
		(q_2) edge[bend left = 60]  node {b} (q_3)
		(q_3) edge[bend left, below]  node {b} (q_2);
		\end{tikzpicture}
	\end{center}
	
	И его матрица смежности:
	$$
	\begin{pmatrix}
	\varnothing   & \{a\}       & \varnothing & \varnothing \\
	\varnothing   & \varnothing & \{a\}       & \varnothing \\
	\{a\}         & \varnothing & \varnothing & \{a,b\} \\
	\varnothing   & \varnothing & \{b\}       & \varnothing
	\end{pmatrix}
	$$
\end{example}

Произведение графов

\section{Теория формальных языков}\label{sec:ch1/sec2}
В данном разделе вводится ряд обозначений, а также представляется основная информация из теории формальных языков.

\begin{definition}
	\textit{Алфавит} $\Sigma$ --- это конечное множество.
	Элементы этого множества будем называть \textit{символами}.
\end{definition}

\begin{example}Примеры алфавитов
	\begin{itemize}
		\item Латинский алфавит $\Sigma = \{ a, b, c, \dots, z\}$
		\item Кириллический алфавит $\Sigma = \{ \text{а, б, в, \dots, я}\}$
		\item Алфавит чисел в шестнадцатеричной записи 
		$$\Sigma = \{0, 1, 2, 3, 4, 5, 6, 7 ,8,9, A, B, C, D, E, F \}$$
	\end{itemize}
\end{example}

Традиционное обозначение для алфавита --- $\Sigma$.
Также мы будем использовать различные прописные буквы латинского алфавита. Для обозначения символов алфавита будем использовать строчные буквы латинского алфавита: $a, b, \dots, x, y, z$.

Будем считать, что над алфавитом $\Sigma$ всегда определена операция конкатенации $(\cdot): \Sigma^* \times \Sigma^* \to \Sigma^*$.
При записи выражений символ точки (обозначение операции конкатенации) часто будем опускать: $a \cdot b = ab$.

\begin{definition}
	\textit{Слово} над алфавитом $\Sigma$ --- это конечная конкатенация символов алфавита $\Sigma$: $\omega = a_0 \cdot a_1 \cdot \ldots \cdot a_m$, где $\omega$ --- слово, а для любого $i$ $a_i \in \Sigma$.
\end{definition}

\begin{definition}
	Пусть $\omega = a_0 \cdot a_1 \cdot \ldots \cdot a_m$ --- слово над алфавитом $\Sigma$.
	Будем называть $m + 1$ \textit{длиной слова} и обозначать как $|\omega|$.
\end{definition}

\begin{definition}
	\textit{Язык} над алфавитом $\Sigma$ --- это множество слов над алфавитом $\Sigma$.
\end{definition}

\begin{example}
	
	Примеры языков.
	
	\begin{itemize}
		\item Язык целых чисел в двоичной записи $\{0, 1, -1, 10, 11, -10, -11, \dots\}.$
		\item Язык всех правильных скобочных последовательностей $$\{(), (()), ()(), (())(), \dots\}.$$
	\end{itemize}
\end{example}

Любой язык над алфавитом $\Sigma$ является подмножеством $\Sigma^*$ --- множества всех слов над алфавитом $\Sigma$. Заметим, что язык может является бесконечным множеством.

\begin{definition} 
	Грамматика $G$ --- это четвёрка $\langle \Sigma, N, P, S \rangle$, где 
	\begin{itemize}
		\item $\Sigma$ обозначает конечный алфавит терминальных символов или терминалов, 
		\item $N$ --- алфавит нетерминальных символов или нетерминалов, $\Sigma \cap N=\varnothing$, 
		\item $P$ --- конечное подмножество множества $(\Sigma \cup N)^+ \times (\Sigma \cup N)^*$,  
		
		\item $S$ --- стартовый символ грамматики, $S  \in N$. 
	\end{itemize}
\end{definition}

Элемент $(a, b) \in P$ называется правилом вывода и записывается так: $a \rightarrow b$. При этом $a$ называется левой частью правила, а $b$ --- правой частью. Левая часть любого правила из $P$ обязана содержать хотя бы один нетерминал.


\begin{definition}    
	Вывод цепочки $\omega$ в грамматике $G$.\\  Цепочка $\omega_2 \in  ( \Sigma \cup  N )^*$ \textit{непосредственно выводима} из цепочки   $\omega_1 \in ( \Sigma \cup N )^+$ в грамматике $G=\langle \Sigma, N, P, S \rangle$  (обозначается  $\omega_1 \rightarrow_G \omega_2$ ), если  $\omega_1 = x_1 \cdot y \cdot x_2, \omega_2 = x_1 \cdot z \cdot x_2$, где $x_1, x_2, y \in   (\Sigma \cup N )^*, z \in  (\Sigma \cup N )^+$ и правило вывода  $y \rightarrow z$  содержится в $P$. Индекс $G$ в обозначении $\rightarrow_G$ обычно опускают, если $G$ понятна из контекста.
	
	Цепочка $\omega_2 \in  (\Sigma \cup  N )^*$  \textit{выводима} из цепочки  $\omega_1 \in (\Sigma \cup  N)^+$ в грамматике $G$  (обозначается  $\omega_1 \Rightarrow_G \omega_2$ ), если существуют цепочки $z_0, z_1, \cdots, z_n  (n \geq 0)$ такие, что $\omega_1 = z_0 \rightarrow z_1 \rightarrow ... \rightarrow z_n = \omega_2$ . При этом последовательность $z_0, z_1, ..., z_n$ называется выводом длины $n$.
\end{definition}

\begin{definition}
	Язык, \textit{порождаемый} грамматикой \\ $G = \langle \Sigma, N, P, S \rangle$ --- это множество $L(G)  = \{ \omega \in \Sigma^*~|~S \Rightarrow \omega \}$.
\end{definition}

\begin{definition}
	\textit{Деревом вывода цепочки} $\omega \in \Sigma^*$ в грамматике $G=\langle \Sigma, N, P, S \rangle$ называется упорядоченное дерево со следующими свойствами. 
	\begin{itemize}
		\item Корень помечен $S$.
		
		\item Если его внутренний узел помечен $A \in N$ и $X_1, \ldots , X_k \in \Sigma \cup N$ ---   перечисленные слева направо пометки всех сыновей этого узла, то правило $A \rightarrow X_1 \ldots X_k \in P$.
		
		\item Если его внутренний узел помечен $A \in N$ и $\varepsilon$ --- пометка единственного сына этого внутреннего узла, то правило $A \rightarrow \varepsilon \in P$.
		
		\item $\omega = a_1 \ldots a_m$, где $a_1, \ldots , a_m \in \Sigma \cup \{\varepsilon\} $ перечисленные слева направо пометки всех листьев этого дерева.
		
	\end{itemize}
\end{definition}


Одним из распространённых способов классификации грамматик является иерархия по Хомскому. Грамматики типа 0 1 2 3. КС-грамматика.

Нормальная форма хомского для КС-грамматик.

Конечные автоматы.

Рекурсивные автоматы.


\section{Постановка задачи вычисления КС-запросов к графам}\label{sec:ch1/sec3}
В данном разделе вводится формальная постановка задачи вычисления КС-запросов к графам.

Выделим три возможных семантики запросов и приведем формальные постановки задачи вычисления КС-запросов для них.

Постановка задачи с реляционной семантикой запросов.

Постановка задачи с семантикой запросов одного пути.

Постановка задачи с семантикой запросов всех путей.

Общий мотивационный пример.

\section{Существующие алгоритмы вычисления КС-запросов к графам}\label{sec:ch1/sec4}
В данном разделе рассмотрены основные алгоритмы вычисления КС-запросов к графам.

Hellings/китайцы. Контекстно-свободные отношения $R_A$, и то что мы будем использовать эту формулировку в работе. Для всех семантик, всех графов. Временная сложность.

Брэдфорд. Кратчайшие пути, языки Дика, определенный вид графа. Временная сложность.

GLL, GLR, комбинаторы Merkat, все семантики, все графы. Временная сложность.

Бразильцы. Все графы. Временная сложность.

\section{Используемые инструменты}\label{sec:ch1/sec5}
В данном разделе рассмотрены инструменты, используемые в ходе исследования.

\subsection{Стандарт GraphBLAS}
В данном разделе вводится ряд обозначений, а также представляется основная информация из стандарта GraphBLAS.

Стандарт GraphBLAS. Графы представлены в виде матриц смежности. Используются практические результаты для вычисления операций над разреженными матрицами.

Операции над матрицами и соответсвующие им трансформации графов. Транспонирование, поэлементное сложение/умножение, обычное умножение.

Матричное умножение на полукольце. Ключевая идея GraphBLAS.

Таблица стандартных полуколец в GraphBLAS.

Предстваление матриц в GraphBLAS. CSR, CSC.

Таблица классических алгоритмов на графах с классической и матричными сложностями?

SuiteSparse --- реализация на языке Си. Разреженные матрицы, их формат, вычисление операций на цпу.

\subsection{RedisGraph}
RedisGraph --- графовая база данных. Разреженные матрицы, их формат. Выразительность языка запросов.

\subsection{CFPQ\_data}
Созданный датасет. Описать какие графы RDF и запросы к ним. Таблица.

\section{Выводы}\label{sec:ch1/sec6}
На основе проведённого обзора можно сделать следующие выводы, обосновывающие необходимость проведения исследования в области вычисления КС-запросов к графам.
\begin{itemize}
	\item Проблема вычисления КС-запросов к графам актуальна в нескольких областях: графовые базы данных, биоинформатика, статический анализ программ.
	\item Формулирование алгоритмов на графах в терминах операций линейной алгебры перспективное направление для улучшения производительности при работе с большими графами.
	\item Не проводилось исследований о возможность формулировки алгоритмов вычисления КС-запросов к графам в терминах операций линейной алгебры.
\end{itemize}

Обзор также позволяет выявить следующие подходы, технологии и средства.
\begin{itemize}
	\item Для построения алгоритма КС-запросов к графам с использованием операций линейной алгебры целесообразно придерживаться стандарта GraphBLAS.
	\item Представление матриц должно быть разреженным.
	\item Для вычисления на цпу можно использовать реализацию SuiteSparse.
	\item В качестве хранилища данных можно использовать RedisGraph.
	\item В качестве датасета для экспериментального исследования можно использовать CFPQ\_data.
\end{itemize}


\FloatBarrier
