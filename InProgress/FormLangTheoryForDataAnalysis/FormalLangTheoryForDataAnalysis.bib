@inproceedings{10.1145/3408877.3432464,
author = {Romero, Julien},
title = {Pyformlang: An Educational Library for Formal Language Manipulation},
year = {2021},
isbn = {9781450380621},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3408877.3432464},
doi = {10.1145/3408877.3432464},
abstract = {Formal languages are widely studied, taught and used in computer science. However, only a small part of this domain is brought to a broader audience, and students often have no practical experience in their curriculum. In this tool paper, we introduce Pyformlang, a practical and pedagogical Python library for formal languages. Our library implements the most common algorithms of the domain, accessible by an easy-to-use interface. The code is written exclusively in Python3, with a clear structure, so as to allow students to play and learn with it.},
booktitle = {Proceedings of the 52nd ACM Technical Symposium on Computer Science Education},
pages = {576–582},
numpages = {7},
keywords = {formal languages, python, library, education},
location = {Virtual Event, USA},
series = {SIGCSE '21}
}

@Inbook{Figueira2022,
author="Figueira, Diego",
editor="{\v{S}}imkus, Mantas
and Varzinczak, Ivan",
title="Foundations of Graph Path Query Languages",
bookTitle="Reasoning Web. Declarative Artificial Intelligence : 17th International Summer School 2021, Leuven, Belgium, September 8--15, 2021, Tutorial Lectures",
year="2022",
publisher="Springer International Publishing",
address="Cham",
pages="1--21",
abstract="We survey some foundational results on querying graph-structured data. We focus on general-purpose navigational query languages, such as regular path queries and its extensions with conjunctions, inverses, and path comparisons. We study complexity, expressive power, and static analysis. The course material should be useful to anyone with an interest in query languages for graph structured data, and more broadly in foundational aspects of database theory.",
isbn="978-3-030-95481-9",
doi="10.1007/978-3-030-95481-9_1",
url="https://doi.org/10.1007/978-3-030-95481-9_1"
}

@inproceedings{10.1145/3327964.3328503,
author = {Mishin, Nikita and Sokolov, Iaroslav and Spirin, Egor and Kutuev, Vladimir and Nemchinov, Egor and Gorbatyuk, Sergey and Grigorev, Semyon},
title = {Evaluation of the Context-Free Path Querying Algorithm Based on Matrix Multiplication},
year = {2019},
isbn = {9781450367899},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3327964.3328503},
doi = {10.1145/3327964.3328503},
abstract = {Recently proposed matrix multiplication based algorithm for context-free path querying (CFPQ) offloads the most performance-critical parts onto boolean matrices multiplication. Thus, it is possible to achieve high performance of CFPQ by means of modern parallel hardware and software. In this paper, we provide results of empirical performance comparison of different implementations of this algorithm on both real-world data and synthetic data for the worst cases.},
booktitle = {Proceedings of the 2nd Joint International Workshop on Graph Data Management Experiences \& Systems (GRADES) and Network Data Analytics (NDA)},
articleno = {12},
numpages = {5},
keywords = {transitive closure, matrix multiplication, graph databases, context-free grammar, boolean matrix, GPGPU, Context-free path querying, CUDA},
location = {Amsterdam, Netherlands},
series = {GRADES-NDA'19}
}

@book{10.5555/2501720,
author = {Parr, Terence},
title = {The Definitive ANTLR 4 Reference},
year = {2013},
isbn = {1934356999},
publisher = {Pragmatic Bookshelf},
edition = {2nd},
abstract = {Programmers run into parsing problems all the time. Whether it's a data format like JSON, a network protocol like SMTP, a server configuration file for Apache, a PostScript/PDF file, or a simple spreadsheet macro language--ANTLR v4 and this book will demystify the process. ANTLR v4 has been rewritten from scratch to make it easier than ever to build parsers and the language applications built on top. This completely rewritten new edition of the bestselling Definitive ANTLR Reference shows you how to take advantage of these new features. Build your own languages with ANTLR v4, using ANTLR's new advanced parsing technology. In this book, you'll learn how ANTLR automatically builds a data structure representing the input (parse tree) and generates code that can walk the tree (visitor). You can use that combination to implement data readers, language interpreters, and translators. You'll start by learning how to identify grammar patterns in language reference manuals and then slowly start building increasingly complex grammars. Next, you'll build applications based upon those grammars by walking the automatically generated parse trees. Then you'll tackle some nasty language problems by parsing files containing more than one language (such as XML, Java, and Javadoc). You'll also see how to take absolute control over parsing by embedding Java actions into the grammar. You'll learn directly from well-known parsing expert Terence Parr, the ANTLR creator and project lead. You'll master ANTLR grammar construction and learn how to build language tools using the built-in parse tree visitor mechanism. The book teaches using real-world examples and shows you how to use ANTLR to build such things as a data file reader, a JSON to XML translator, an R parser, and a Java class-interface extractor. This book is your ticket to becoming a parsing guru!What You Need: ANTLR 4.0 and above. Java development tools. Ant build system optional (needed for building ANTLR from source)}
}

@article{10.1145/3093333.3009848,
author = {Zhang, Qirun and Su, Zhendong},
title = {Context-sensitive data-dependence analysis via linear conjunctive language reachability},
year = {2017},
issue_date = {January 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/3093333.3009848},
doi = {10.1145/3093333.3009848},
abstract = {Many program analysis problems can be formulated as graph reachability problems. In the literature, context-free language (CFL) reachability has been the most popular formulation and can be computed in subcubic time. The context-sensitive data-dependence analysis is a fundamental abstraction that can express a broad range of program analysis problems. It essentially describes an interleaved matched-parenthesis language reachability problem. The language is not context-free, and the problem is well-known to be undecidable. In practice, many program analyses adopt CFL-reachability to exactly model the matched parentheses for either context-sensitivity or structure-transmitted data-dependence, but not both. Thus, the CFL-reachability formulation for context-sensitive data-dependence analysis is inherently an approximation. To support more precise and scalable analyses, this paper introduces linear conjunctive language (LCL) reachability, a new, expressive class of graph reachability. LCL not only contains the interleaved matched-parenthesis language, but is also closed under all set-theoretic operations. Given a graph with n nodes and m edges, we propose an O(mn) time approximation algorithm for solving all-pairs LCL-reachability, which is asymptotically better than known CFL-reachability algorithms. Our formulation and algorithm offer a new perspective on attacking the aforementioned undecidable problem - the LCL-reachability formulation is exact, while the LCL-reachability algorithm yields a sound approximation. We have applied the LCL-reachability framework to two existing client analyses. The experimental results show that the LCL-reachability framework is both more precise and scalable than the traditional CFL-reachability framework. This paper opens up the opportunity to exploit LCL-reachability in program analysis.},
journal = {SIGPLAN Not.},
month = jan,
pages = {344–358},
numpages = {15},
keywords = {Context-free language reachability, linear conjunctive grammar, program analysis, trellis automata}
}

@inproceedings{10.1145/3009837.3009848,
author = {Zhang, Qirun and Su, Zhendong},
title = {Context-sensitive data-dependence analysis via linear conjunctive language reachability},
year = {2017},
isbn = {9781450346603},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3009837.3009848},
doi = {10.1145/3009837.3009848},
abstract = {Many program analysis problems can be formulated as graph reachability problems. In the literature, context-free language (CFL) reachability has been the most popular formulation and can be computed in subcubic time. The context-sensitive data-dependence analysis is a fundamental abstraction that can express a broad range of program analysis problems. It essentially describes an interleaved matched-parenthesis language reachability problem. The language is not context-free, and the problem is well-known to be undecidable. In practice, many program analyses adopt CFL-reachability to exactly model the matched parentheses for either context-sensitivity or structure-transmitted data-dependence, but not both. Thus, the CFL-reachability formulation for context-sensitive data-dependence analysis is inherently an approximation. To support more precise and scalable analyses, this paper introduces linear conjunctive language (LCL) reachability, a new, expressive class of graph reachability. LCL not only contains the interleaved matched-parenthesis language, but is also closed under all set-theoretic operations. Given a graph with n nodes and m edges, we propose an O(mn) time approximation algorithm for solving all-pairs LCL-reachability, which is asymptotically better than known CFL-reachability algorithms. Our formulation and algorithm offer a new perspective on attacking the aforementioned undecidable problem - the LCL-reachability formulation is exact, while the LCL-reachability algorithm yields a sound approximation. We have applied the LCL-reachability framework to two existing client analyses. The experimental results show that the LCL-reachability framework is both more precise and scalable than the traditional CFL-reachability framework. This paper opens up the opportunity to exploit LCL-reachability in program analysis.},
booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
pages = {344–358},
numpages = {15},
keywords = {Context-free language reachability, linear conjunctive grammar, program analysis, trellis automata},
location = {Paris, France},
series = {POPL '17}
}

@article{10.1145/3704854,
author = {Conrado, Giovanna Kobus and Kjelstr\o{}m, Adam Husted and van de Pol, Jaco and Pavlogiannis, Andreas},
title = {Program Analysis via Multiple Context Free Language Reachability},
year = {2025},
issue_date = {January 2025},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {9},
number = {POPL},
url = {https://doi.org/10.1145/3704854},
doi = {10.1145/3704854},
abstract = {Context-free language (CFL) reachability is a standard approach in static analyses, where the analysis question (e.g., is there a dataflow from x to y?) is phrased as a language reachability problem on a graph G wrt a CFL L. However, CFLs lack the expressiveness needed for high analysis precision. On the other hand, common formalisms for context-sensitive languages are too expressive, in the sense that the corresponding reachability problem becomes undecidable. Are there useful context-sensitive language-reachability models for static analysis?  In this paper, we introduce Multiple Context-Free Language (MCFL) reachability as an expressive yet tractable model for static program analysis. MCFLs form an infinite hierarchy of mildly context sensitive languages parameterized by a dimension d and a rank r. Larger d and r yield progressively more expressive MCFLs, offering tunable analysis precision. We showcase the utility of MCFL reachability by developing a family of MCFLs that approximate interleaved Dyck reachability, a common but undecidable static analysis problem.  Given the increased expressiveness of MCFLs, one natural question pertains to their algorithmic complexity, i.e., how fast can MCFL reachability be computed? We show that the problem takes O(n2d+1) time on a graph of n nodes when r=1, and O(nd(r+1)) time when r>1. Moreover, we show that when r=1, even the simpler membership problem has a lower bound of n2d based on the Strong Exponential Time Hypothesis, while reachability for d=1 has a lower bound of n3 based on the combinatorial Boolean Matrix Multiplication Hypothesis. Thus, for r=1, our algorithm is optimal within a factor n for all levels of the hierarchy based on the dimension d (and fully optimal for d=1).  We implement our MCFL reachability algorithm and evaluate it by underapproximating interleaved Dyck reachability for a standard taint analysis for Android. When combined with existing overapproximate methods, MCFL reachability discovers all tainted information on 8 out of 11 benchmarks, while it has remarkable coverage (confirming 94.3\% of the reachable pairs reported by the overapproximation) on the remaining 3. To our knowledge, this is the first report of high and provable coverage for this challenging benchmark set.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {18},
numpages = {30},
keywords = {CFL reachability, Dyck reachability, context-sensitive languages, static analysis}
}

@article{doi:10.1137/S0097539798337716,
author = {Barrett, Chris and Jacob, Riko and Marathe, Madhav},
title = {Formal-Language-Constrained Path Problems},
journal = {SIAM Journal on Computing},
volume = {30},
number = {3},
pages = {809-837},
year = {2000},
doi = {10.1137/S0097539798337716},

URL = { 
    
        https://doi.org/10.1137/S0097539798337716
    
    

},
eprint = { 
    
        https://doi.org/10.1137/S0097539798337716
    
    

}
,
    abstract = { Given an alphabet \$\Sigma\$, a (directed) graph G whose edges are weighted and \$\Sigma\$-labeled, and a formal language \$L\subseteq\Sigma^*\$, the formal-language-constrained shortest/simple path problem consists of finding a shortest (simple) path p in G complying with the additional constraint that l(p) \in L\$. Here l(p) denotes the unique word obtained by concatenating the \$\Sigma\$-labels of the edges along the path p. The main contributions of this paper include the following: We show that the formal-language-constrained shortest path problem is solvable efficiently in polynomial time when L is restricted to be a context-free language (CFL). When L is specified as a regular language we provide algorithms with improved space and time bounds. In contrast, we show that the problem of finding a simple path between a source and a given destination is NP-hard, even when L is restricted to fixed simple regular languages and to very simple classes of graphs (e.g., complete grids). For the class of treewidth-bounded graphs, we show that (i) the problem of finding a regular-language-constrained simple path between source and destination is solvable in polynomial time and (ii) the extension to finding CFL-constrained simple paths is NP-complete. Our results extend the previous results in [SIAM J. Comput., 24 (1995), pp. 1235--1258; Proceedings of the 76th Annual Meeting of the Transportation Research Board, 1997; and Proceedings of the 9th ACM SIGACT-SIGMOD-SIGART Symposium on Database Systems, 1990, pp. 230--242]. Several additional extensions and applications of our results in the context of transportation problems are presented. For instance, as a corollary of our results, we obtain a polynomial-time algorithm for the best k-similar path problem studied in Proceedings of the 76th Annual Meeting of the Transportation Reasearch Board, 1997]. The previous best algorithm was given by [ Proceedings of the 76th Annual Meeting of the Transportation Research Board, 1997] and takes exponential time in the worst case. }
}


@inproceedings{terekhov2021multiple,
  title={Multiple-Source Context-Free Path Querying in Terms of Linear Algebra.},
  author={Terekhov, Arseniy and Pogozhelskaya, Vlada and Abzalov, Vadim and Zinnatulin, Timur and Grigorev, Semyon V},
  booktitle={EDBT},
  pages={487--492},
  year={2021}
}

@INPROCEEDINGS{8731467,
  author={Miao, Hui and Deshpande, Amol},
  booktitle={2019 IEEE 35th International Conference on Data Engineering (ICDE)}, 
  title={Understanding Data Science Lifecycle Provenance via Graph Segmentation and Summarization}, 
  year={2019},
  volume={},
  number={},
  pages={1710-1713},
  keywords={Data models;Data science;Semantics;Databases;Pipelines;Skeleton;Writing;provenance management;graph query;model management;context free language},
  doi={10.1109/ICDE.2019.00179}}

  @article{SevonEronen+2008+157+172,
url = {https://doi.org/10.1515/jib-2008-100},
title = {Subgraph Queries by Context-free Grammars},
title = {},
author = {Petteri Sevon and Lauri Eronen},
pages = {157--172},
volume = {5},
number = {2},
journal = {Journal of Integrative Bioinformatics},
doi = {doi:10.1515/jib-2008-100},
year = {2008},
lastchecked = {2025-02-18}
}




