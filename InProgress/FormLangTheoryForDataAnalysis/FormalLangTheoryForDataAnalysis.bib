@inproceedings{10.1145/3408877.3432464,
author = {Romero, Julien},
title = {Pyformlang: An Educational Library for Formal Language Manipulation},
year = {2021},
isbn = {9781450380621},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3408877.3432464},
doi = {10.1145/3408877.3432464},
abstract = {Formal languages are widely studied, taught and used in computer science. However, only a small part of this domain is brought to a broader audience, and students often have no practical experience in their curriculum. In this tool paper, we introduce Pyformlang, a practical and pedagogical Python library for formal languages. Our library implements the most common algorithms of the domain, accessible by an easy-to-use interface. The code is written exclusively in Python3, with a clear structure, so as to allow students to play and learn with it.},
booktitle = {Proceedings of the 52nd ACM Technical Symposium on Computer Science Education},
pages = {576–582},
numpages = {7},
keywords = {formal languages, python, library, education},
location = {Virtual Event, USA},
series = {SIGCSE '21}
}

@Inbook{Figueira2022,
author="Figueira, Diego",
editor="{\v{S}}imkus, Mantas
and Varzinczak, Ivan",
title="Foundations of Graph Path Query Languages",
bookTitle="Reasoning Web. Declarative Artificial Intelligence : 17th International Summer School 2021, Leuven, Belgium, September 8--15, 2021, Tutorial Lectures",
year="2022",
publisher="Springer International Publishing",
address="Cham",
pages="1--21",
abstract="We survey some foundational results on querying graph-structured data. We focus on general-purpose navigational query languages, such as regular path queries and its extensions with conjunctions, inverses, and path comparisons. We study complexity, expressive power, and static analysis. The course material should be useful to anyone with an interest in query languages for graph structured data, and more broadly in foundational aspects of database theory.",
isbn="978-3-030-95481-9",
doi="10.1007/978-3-030-95481-9_1",
url="https://doi.org/10.1007/978-3-030-95481-9_1"
}

@inproceedings{10.1145/3327964.3328503,
author = {Mishin, Nikita and Sokolov, Iaroslav and Spirin, Egor and Kutuev, Vladimir and Nemchinov, Egor and Gorbatyuk, Sergey and Grigorev, Semyon},
title = {Evaluation of the Context-Free Path Querying Algorithm Based on Matrix Multiplication},
year = {2019},
isbn = {9781450367899},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3327964.3328503},
doi = {10.1145/3327964.3328503},
abstract = {Recently proposed matrix multiplication based algorithm for context-free path querying (CFPQ) offloads the most performance-critical parts onto boolean matrices multiplication. Thus, it is possible to achieve high performance of CFPQ by means of modern parallel hardware and software. In this paper, we provide results of empirical performance comparison of different implementations of this algorithm on both real-world data and synthetic data for the worst cases.},
booktitle = {Proceedings of the 2nd Joint International Workshop on Graph Data Management Experiences \& Systems (GRADES) and Network Data Analytics (NDA)},
articleno = {12},
numpages = {5},
keywords = {transitive closure, matrix multiplication, graph databases, context-free grammar, boolean matrix, GPGPU, Context-free path querying, CUDA},
location = {Amsterdam, Netherlands},
series = {GRADES-NDA'19}
}

@book{10.5555/2501720,
author = {Parr, Terence},
title = {The Definitive ANTLR 4 Reference},
year = {2013},
isbn = {1934356999},
publisher = {Pragmatic Bookshelf},
edition = {2nd},
abstract = {Programmers run into parsing problems all the time. Whether it's a data format like JSON, a network protocol like SMTP, a server configuration file for Apache, a PostScript/PDF file, or a simple spreadsheet macro language--ANTLR v4 and this book will demystify the process. ANTLR v4 has been rewritten from scratch to make it easier than ever to build parsers and the language applications built on top. This completely rewritten new edition of the bestselling Definitive ANTLR Reference shows you how to take advantage of these new features. Build your own languages with ANTLR v4, using ANTLR's new advanced parsing technology. In this book, you'll learn how ANTLR automatically builds a data structure representing the input (parse tree) and generates code that can walk the tree (visitor). You can use that combination to implement data readers, language interpreters, and translators. You'll start by learning how to identify grammar patterns in language reference manuals and then slowly start building increasingly complex grammars. Next, you'll build applications based upon those grammars by walking the automatically generated parse trees. Then you'll tackle some nasty language problems by parsing files containing more than one language (such as XML, Java, and Javadoc). You'll also see how to take absolute control over parsing by embedding Java actions into the grammar. You'll learn directly from well-known parsing expert Terence Parr, the ANTLR creator and project lead. You'll master ANTLR grammar construction and learn how to build language tools using the built-in parse tree visitor mechanism. The book teaches using real-world examples and shows you how to use ANTLR to build such things as a data file reader, a JSON to XML translator, an R parser, and a Java class-interface extractor. This book is your ticket to becoming a parsing guru!What You Need: ANTLR 4.0 and above. Java development tools. Ant build system optional (needed for building ANTLR from source)}
}

@article{10.1145/3093333.3009848,
author = {Zhang, Qirun and Su, Zhendong},
title = {Context-sensitive data-dependence analysis via linear conjunctive language reachability},
year = {2017},
issue_date = {January 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/3093333.3009848},
doi = {10.1145/3093333.3009848},
abstract = {Many program analysis problems can be formulated as graph reachability problems. In the literature, context-free language (CFL) reachability has been the most popular formulation and can be computed in subcubic time. The context-sensitive data-dependence analysis is a fundamental abstraction that can express a broad range of program analysis problems. It essentially describes an interleaved matched-parenthesis language reachability problem. The language is not context-free, and the problem is well-known to be undecidable. In practice, many program analyses adopt CFL-reachability to exactly model the matched parentheses for either context-sensitivity or structure-transmitted data-dependence, but not both. Thus, the CFL-reachability formulation for context-sensitive data-dependence analysis is inherently an approximation. To support more precise and scalable analyses, this paper introduces linear conjunctive language (LCL) reachability, a new, expressive class of graph reachability. LCL not only contains the interleaved matched-parenthesis language, but is also closed under all set-theoretic operations. Given a graph with n nodes and m edges, we propose an O(mn) time approximation algorithm for solving all-pairs LCL-reachability, which is asymptotically better than known CFL-reachability algorithms. Our formulation and algorithm offer a new perspective on attacking the aforementioned undecidable problem - the LCL-reachability formulation is exact, while the LCL-reachability algorithm yields a sound approximation. We have applied the LCL-reachability framework to two existing client analyses. The experimental results show that the LCL-reachability framework is both more precise and scalable than the traditional CFL-reachability framework. This paper opens up the opportunity to exploit LCL-reachability in program analysis.},
journal = {SIGPLAN Not.},
month = jan,
pages = {344–358},
numpages = {15},
keywords = {Context-free language reachability, linear conjunctive grammar, program analysis, trellis automata}
}

@inproceedings{10.1145/3009837.3009848,
author = {Zhang, Qirun and Su, Zhendong},
title = {Context-sensitive data-dependence analysis via linear conjunctive language reachability},
year = {2017},
isbn = {9781450346603},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3009837.3009848},
doi = {10.1145/3009837.3009848},
abstract = {Many program analysis problems can be formulated as graph reachability problems. In the literature, context-free language (CFL) reachability has been the most popular formulation and can be computed in subcubic time. The context-sensitive data-dependence analysis is a fundamental abstraction that can express a broad range of program analysis problems. It essentially describes an interleaved matched-parenthesis language reachability problem. The language is not context-free, and the problem is well-known to be undecidable. In practice, many program analyses adopt CFL-reachability to exactly model the matched parentheses for either context-sensitivity or structure-transmitted data-dependence, but not both. Thus, the CFL-reachability formulation for context-sensitive data-dependence analysis is inherently an approximation. To support more precise and scalable analyses, this paper introduces linear conjunctive language (LCL) reachability, a new, expressive class of graph reachability. LCL not only contains the interleaved matched-parenthesis language, but is also closed under all set-theoretic operations. Given a graph with n nodes and m edges, we propose an O(mn) time approximation algorithm for solving all-pairs LCL-reachability, which is asymptotically better than known CFL-reachability algorithms. Our formulation and algorithm offer a new perspective on attacking the aforementioned undecidable problem - the LCL-reachability formulation is exact, while the LCL-reachability algorithm yields a sound approximation. We have applied the LCL-reachability framework to two existing client analyses. The experimental results show that the LCL-reachability framework is both more precise and scalable than the traditional CFL-reachability framework. This paper opens up the opportunity to exploit LCL-reachability in program analysis.},
booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
pages = {344–358},
numpages = {15},
keywords = {Context-free language reachability, linear conjunctive grammar, program analysis, trellis automata},
location = {Paris, France},
series = {POPL '17}
}

@article{10.1145/3704854,
author = {Conrado, Giovanna Kobus and Kjelstr\o{}m, Adam Husted and van de Pol, Jaco and Pavlogiannis, Andreas},
title = {Program Analysis via Multiple Context Free Language Reachability},
year = {2025},
issue_date = {January 2025},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {9},
number = {POPL},
url = {https://doi.org/10.1145/3704854},
doi = {10.1145/3704854},
abstract = {Context-free language (CFL) reachability is a standard approach in static analyses, where the analysis question (e.g., is there a dataflow from x to y?) is phrased as a language reachability problem on a graph G wrt a CFL L. However, CFLs lack the expressiveness needed for high analysis precision. On the other hand, common formalisms for context-sensitive languages are too expressive, in the sense that the corresponding reachability problem becomes undecidable. Are there useful context-sensitive language-reachability models for static analysis?  In this paper, we introduce Multiple Context-Free Language (MCFL) reachability as an expressive yet tractable model for static program analysis. MCFLs form an infinite hierarchy of mildly context sensitive languages parameterized by a dimension d and a rank r. Larger d and r yield progressively more expressive MCFLs, offering tunable analysis precision. We showcase the utility of MCFL reachability by developing a family of MCFLs that approximate interleaved Dyck reachability, a common but undecidable static analysis problem.  Given the increased expressiveness of MCFLs, one natural question pertains to their algorithmic complexity, i.e., how fast can MCFL reachability be computed? We show that the problem takes O(n2d+1) time on a graph of n nodes when r=1, and O(nd(r+1)) time when r>1. Moreover, we show that when r=1, even the simpler membership problem has a lower bound of n2d based on the Strong Exponential Time Hypothesis, while reachability for d=1 has a lower bound of n3 based on the combinatorial Boolean Matrix Multiplication Hypothesis. Thus, for r=1, our algorithm is optimal within a factor n for all levels of the hierarchy based on the dimension d (and fully optimal for d=1).  We implement our MCFL reachability algorithm and evaluate it by underapproximating interleaved Dyck reachability for a standard taint analysis for Android. When combined with existing overapproximate methods, MCFL reachability discovers all tainted information on 8 out of 11 benchmarks, while it has remarkable coverage (confirming 94.3\% of the reachable pairs reported by the overapproximation) on the remaining 3. To our knowledge, this is the first report of high and provable coverage for this challenging benchmark set.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {18},
numpages = {30},
keywords = {CFL reachability, Dyck reachability, context-sensitive languages, static analysis}
}

@article{10.1137/S0097539798337716,
author = {Barrett, Chris and Jacob, Riko and Marathe, Madhav},
title = {Formal-Language-Constrained Path Problems},
journal = {SIAM Journal on Computing},
volume = {30},
number = {3},
pages = {809-837},
year = {2000},
doi = {10.1137/S0097539798337716},

URL = { 
    
        https://doi.org/10.1137/S0097539798337716
    
    

},
eprint = { 
    
        https://doi.org/10.1137/S0097539798337716
    
    

}
,
    abstract = { Given an alphabet \$\Sigma\$, a (directed) graph G whose edges are weighted and \$\Sigma\$-labeled, and a formal language \$L\subseteq\Sigma^*\$, the formal-language-constrained shortest/simple path problem consists of finding a shortest (simple) path p in G complying with the additional constraint that l(p) \in L\$. Here l(p) denotes the unique word obtained by concatenating the \$\Sigma\$-labels of the edges along the path p. The main contributions of this paper include the following: We show that the formal-language-constrained shortest path problem is solvable efficiently in polynomial time when L is restricted to be a context-free language (CFL). When L is specified as a regular language we provide algorithms with improved space and time bounds. In contrast, we show that the problem of finding a simple path between a source and a given destination is NP-hard, even when L is restricted to fixed simple regular languages and to very simple classes of graphs (e.g., complete grids). For the class of treewidth-bounded graphs, we show that (i) the problem of finding a regular-language-constrained simple path between source and destination is solvable in polynomial time and (ii) the extension to finding CFL-constrained simple paths is NP-complete. Our results extend the previous results in [SIAM J. Comput., 24 (1995), pp. 1235--1258; Proceedings of the 76th Annual Meeting of the Transportation Research Board, 1997; and Proceedings of the 9th ACM SIGACT-SIGMOD-SIGART Symposium on Database Systems, 1990, pp. 230--242]. Several additional extensions and applications of our results in the context of transportation problems are presented. For instance, as a corollary of our results, we obtain a polynomial-time algorithm for the best k-similar path problem studied in Proceedings of the 76th Annual Meeting of the Transportation Reasearch Board, 1997]. The previous best algorithm was given by [ Proceedings of the 76th Annual Meeting of the Transportation Research Board, 1997] and takes exponential time in the worst case. }
}


@inproceedings{terekhov2021multiple,
  title={Multiple-Source Context-Free Path Querying in Terms of Linear Algebra.},
  author={Terekhov, Arseniy and Pogozhelskaya, Vlada and Abzalov, Vadim and Zinnatulin, Timur and Grigorev, Semyon V},
  booktitle={EDBT},
  pages={487--492},
  year={2021}
}

@INPROCEEDINGS{8731467,
  author={Miao, Hui and Deshpande, Amol},
  booktitle={2019 IEEE 35th International Conference on Data Engineering (ICDE)}, 
  title={Understanding Data Science Lifecycle Provenance via Graph Segmentation and Summarization}, 
  year={2019},
  volume={},
  number={},
  pages={1710-1713},
  keywords={Data models;Data science;Semantics;Databases;Pipelines;Skeleton;Writing;provenance management;graph query;model management;context free language},
  doi={10.1109/ICDE.2019.00179}}

  @article{SevonEronen+2008+157+172,
url = {https://doi.org/10.1515/jib-2008-100},
title = {Subgraph Queries by Context-free Grammars},
title = {},
author = {Petteri Sevon and Lauri Eronen},
pages = {157--172},
volume = {5},
number = {2},
journal = {Journal of Integrative Bioinformatics},
doi = {doi:10.1515/jib-2008-100},
year = {2008},
lastchecked = {2025-02-18}
}

@techreport{2013sparql,
  added-at = {2014-01-01T17:11:54.000+0100},
  biburl = {https://www.bibsonomy.org/bibtex/2596d86dd94ca36ee283d9c4fdc543622/jullybobble},
  editor = {Prud'hommeaux, Eric and Harris, Steve and Seaborne, Andy},
  institution = {W3C},
  interhash = {decbded2e443a4f743e82572e211366b},
  intrahash = {596d86dd94ca36ee283d9c4fdc543622},
  keywords = {intro phd sparql},
  timestamp = {2014-07-27T15:43:19.000+0200},
  title = {{SPARQL 1.1 Query Language}},
  url = {http://www.w3.org/TR/sparql11-query},
  year = 2013
}

@techreport{2024gql,
  type = {Standard},
key = {ISO/IEC 39075:2024},
month = april,
year = {2024},
title = {{Information technology -- Database languages -- GQL}},
volume = {2024},
address = {Geneva, CH},
institution = {International Organization for Standardization},
url = {https://www.iso.org/standard/76120.html}
}

@inproceedings{10.1145/3335783.3335791,
author = {Kuijpers, Jochem and Fletcher, George and Yakovets, Nikolay and Lindaaker, Tobias},
title = {An Experimental Study of Context-Free Path Query Evaluation Methods},
year = {2019},
isbn = {9781450362160},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3335783.3335791},
doi = {10.1145/3335783.3335791},
abstract = {Context-free path queries extend regular path queries for increased expressiveness. A context-free grammar is used to recognize accepted paths by their label strings, or traces. Such queries arise naturally in graph analytics, e.g., in bioinformatics applications. Currently, the practical performance of methods for context-free path query evaluation is not well understood. In this work, we study three state of the art context-free path query evaluation methods. We measure the performance of these methods on diverse query workloads on various data sets and compare their results. We showcase how these evaluation methods scale as graphs get bigger and queries become larger or more ambiguous. We conclude that state of the art solutions are not able to cope with large graphs as found in practice.},
booktitle = {Proceedings of the 31st International Conference on Scientific and Statistical Database Management},
pages = {121–132},
numpages = {12},
location = {Santa Cruz, CA, USA},
series = {SSDBM '19}
}

@inproceedings{10.1145/3167132.3167265,
author = {Medeiros, Ciro M. and Musicante, Martin A. and Costa, Umberto S.},
title = {Efficient evaluation of context-free path queries for graph databases},
year = {2018},
isbn = {9781450351911},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3167132.3167265},
doi = {10.1145/3167132.3167265},
abstract = {We present a context-free path query evaluation algorithm inspired by top-down parsing techniques. Given a graph and a query defined over a context-free grammar, our algorithm identifies paths on the graph which form words of the language generated by the grammar. We show that our algorithm is correct. We conduct performance evaluation experiments with some popular ontologies and synthetic databases to endorse the efficiency of our approach. The algorithm presents a cubic worst-case runtime complexity in terms of the number of nodes in the graph, which is an improvement over previous work.},
booktitle = {Proceedings of the 33rd Annual ACM Symposium on Applied Computing},
pages = {1230–1237},
numpages = {8},
keywords = {top-down parsing, query languages, graph databases, context-free paths in graphs, context-free grammars},
location = {Pau, France},
series = {SAC '18}
}

@article{HELLINGS2025102475,
title = {Explaining results of path queries on graphs: Single-path results for context-free path queries},
journal = {Information Systems},
volume = {128},
pages = {102475},
year = {2025},
issn = {0306-4379},
doi = {https://doi.org/10.1016/j.is.2024.102475},
url = {https://www.sciencedirect.com/science/article/pii/S0306437924001339},
author = {Jelle Hellings},
keywords = {Graphs, Path results, Path queries, Shortest paths, Context-free grammars},
abstract = {Many graph query languages use, at their core, path queries that yield node pairs (m,n) that are connected by a path of interest. For the end-user, such node pairs only give limited insight as to why this result is obtained, as the pair does not directly identify the underlying path of interest. In this paper, we propose the single-path semantics to address this limitation of path queries. Under single-path semantics, path queries evaluate to a single path connecting nodes m and n and that satisfies the conditions of the query. To put our proposal in practice, we provide an efficient algorithm for evaluating context-free path queries using the single-path semantics. Additionally, we perform a short evaluation of our techniques that shows that the single-path semantics is practically feasible, even when query results grow large. In addition, we explore the formal relationship between the single-path semantics we propose the problem of finding the shortest string in the intersection of a regular language (representing a graph) and a context-free language (representing a path query). As our formal results show, there is a distinction between the complexity of the single-path semantics for queries that use a single edge label and queries that use multiple edge labels: for queries that use a single edge label, the length of the shortest path is linearly upper bounded by the number of nodes in the graph; whereas for queries that use multiple edge labels, the length of the shortest path has a worst-case quadratic lower bound.}
}

@inproceedings{10.1145/3398682.3399163,
author = {Terekhov, Arseniy and Khoroshev, Artyom and Azimov, Rustam and Grigorev, Semyon},
title = {Context-Free Path Querying with Single-Path Semantics by Matrix Multiplication},
year = {2020},
isbn = {9781450380218},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3398682.3399163},
doi = {10.1145/3398682.3399163},
abstract = {A recent study showed that the applicability of context-free path querying (CFPQ) algorithms with relational query semantics integrated with graph databases is limited because of low performance and high memory consumption of existing solutions. In this work, we implement a matrix-based CFPQ algorithm by using appropriate high-performance libraries for linear algebra and integrate it with RedisGraph graph database. Also, we introduce a new CFPQ algorithm with single-path query semantics that allows us to extract one found path for each pair of nodes. Finally, we provide the evaluation of our algorithms for both semantics which shows that matrix-based CFPQ implementation for Redis-Graph database is performant enough for real-world data analysis.},
booktitle = {Proceedings of the 3rd Joint International Workshop on Graph Data Management Experiences \& Systems (GRADES) and Network Data Analytics (NDA)},
articleno = {5},
numpages = {12},
keywords = {Boolean matrix, CUDA, Context-free path querying, GPGPU, RedisGraph database, context-free grammar, graph databases, linear algebra, matrix multiplication, transitive closure},
location = {Portland, OR, USA},
series = {GRADES-NDA'20}
}

@article{suitesparse,
author = {Davis, Timothy A.},
title = {Algorithm 1000: SuiteSparse:GraphBLAS: Graph Algorithms in the Language of Sparse Linear Algebra},
year = {2019},
issue_date = {December 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {45},
number = {4},
issn = {0098-3500},
url = {https://doi.org/10.1145/3322125},
doi = {10.1145/3322125},
abstract = {SuiteSparse:GraphBLAS is a full implementation of the GraphBLAS standard, which defines a set of sparse matrix operations on an extended algebra of semirings using an almost unlimited variety of operators and types. When applied to sparse adjacency matrices, these algebraic operations are equivalent to computations on graphs. GraphBLAS provides a powerful and expressive framework for creating graph algorithms based on the elegant mathematics of sparse matrix operations on a semiring. An overview of the GraphBLAS specification is given, followed by a description of the key features and performance of its implementation in the SuiteSparse:GraphBLAS package.},
journal = {ACM Trans. Math. Softw.},
month = {dec},
articleno = {44},
numpages = {25},
keywords = {Graph algorithms, GraphBLAS, sparse matrices}
}

@article{MEDEIROS201975,
title = {LL-based query answering over RDF databases},
journal = {Journal of Computer Languages},
volume = {51},
pages = {75-87},
year = {2019},
issn = {2590-1184},
doi = {https://doi.org/10.1016/j.cola.2019.02.002},
url = {https://www.sciencedirect.com/science/article/pii/S1045926X18301915},
author = {Ciro M. Medeiros and Martin A. Musicante and Umberto S. Costa},
keywords = {Context-Free graph patterns, Graph databases, RDF, SPARQL},
abstract = {We present a method based on top-down parsing techniques for evaluating context-free path queries on RDF Graph Databases. The syntax of the query language is based on SPARQL. The language extends SPARQL by allowing the use of non-terminal symbols of a context-free grammar to specify paths on the graph. In this manner, the language subsumes the definition of regular graph patterns present in SPARQL. Our query evaluator takes an RDF graph, a context-free grammar and a declarative query, and produces tuples of values. The query evaluator proceeds in two stages: Firstly, the RDF graph is enriched with edges representing paths which correspond to strings derived by the grammar. We show that this algorithm is correct and presents a cubic worst-case run-time complexity on the number of nodes in the graph, which is an improvement over some previous work. The second stage of the evaluator uses the produced graph to identify tuples of values defined by a declarative query. In order to validate our approach, we conducted experiments by using some popular ontologies as well as synthetic databases. We compare performance results of our method with some related work.}
}

@InProceedings{10.1007/978-3-319-91662-0_17,
author="Santos, Fred C.
and Costa, Umberto S.
and Musicante, Martin A.",
editor="Mikkonen, Tommi
and Klamma, Ralf
and Hern{\'a}ndez, Juan",
title="A Bottom-Up Algorithm for Answering Context-Free Path Queries in Graph Databases",
booktitle="Web Engineering",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="225--233",
abstract="Many computing applications require processing of data that are directly collected from the Internet. In this context, the use of the Resource Description Framework (RDF) has became a common feature. The query and analysis of RDF data is paramount to explore the full potential of the data available on the Web. Query languages for RDF graph databases rely on the use of regular expressions to identify paths over the data. Some interesting queries, such as same-generation queries, cannot be expressed by regular expressions. We are interested in extending the expressiveness of queries over graph databases by using paths defined by context-free grammars. We introduce a new query algorithm to process context-free path queries over graph databases. Our approach is inspired by the LR(1) parsing techniques. A prototype was implemented and experiments were conducted to validate and compare the results of our algorithm with those obtained by similar approaches.",
isbn="978-3-319-91662-0"
}

@article{BarHillel61,
  added-at = {2008-03-17T11:27:54.000+0100},
  author = {Bar-Hillel, Yehoshua and Perles, M. and Shamir, E.},
  biburl = {https://www.bibsonomy.org/bibtex/2656bc6c94082c9291f6ca8a304807c1d/nlp},
  interhash = {3c7f040358ce6e3ed6826b2277d31b2b},
  intrahash = {656bc6c94082c9291f6ca8a304807c1d},
  journal = {Zeitschrift {f\" ur} Phonetik, Sprachwissenschaft und
  Kommunikationsforschung},
  keywords = {2000 book nlp},
  note = {Reprinted in Y. Bar-Hillel. (1964). {\em Language and Information:
  Selected Essays on their Theory and Application}, Addison-Wesley 1964,
  116--150},
  pages = {143--172},
  timestamp = {2008-03-17T11:32:43.000+0100},
  title = {On Formal Properties of Simple Phrase Structure Grammars},
  volume = 14,
  year = 1961
}


@InProceedings{10.1007/978-3-662-46663-6_5,
author="Afroozeh, Ali
and Izmaylova, Anastasia",
editor="Franke, Bj{\"o}rn",
title="Faster, Practical GLL Parsing",
booktitle="Compiler Construction",
year="2015",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="89--108",
abstract="Generalized LL (GLL) parsing is an extension of recursivedescent (RD) parsing that supports all context-free grammars in cubic time and space. GLL parsers have the direct relationship with the grammar that RD parsers have, and therefore, compared to GLR, are easier to understand, debug, and extend. This makes GLL parsing attractive for parsing programming languages.",
isbn="978-3-662-46663-6"
}

@inproceedings{10.1145/3166094.3166104,
author = {Grigorev, Semyon and Ragozina, Anastasiya},
title = {Context-free path querying with structural representation of result},
year = {2017},
isbn = {9781450363969},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3166094.3166104},
doi = {10.1145/3166094.3166104},
abstract = {Graph data model and graph databases are popular in such areas as bioinformatics, semantic web, and social networks. One specific problem in the area is a path querying with constraints formulated in terms of formal grammars. The query in this approach is written as a grammar and paths querying is graph parsing with respect to the grammar. There are several solutions to it, but they are based mostly on CYK or Earley algorithms which impose some restrictions in comparison with other parsing techniques, and employing of advanced parsing techniques for graph parsing is still an open problem. In this paper we propose a graph parsing technique which is based on generalized top-down parsing algorithm (GLL) and allows one to build finite structural query result representation with respect to the given grammar in polynomial time and space for arbitrary context-free grammar and graph.},
booktitle = {Proceedings of the 13th Central \& Eastern European Software Engineering Conference in Russia},
articleno = {10},
numpages = {7},
keywords = {top-down parsing, path query, graph parsing, graph database, context-free grammar, LL, GLL, CFPQ},
location = {St. Petersburg, Russia},
series = {CEE-SECR '17}
}

@article{10.1145/3583660.3583664,
author = {Pavlogiannis, Andreas},
title = {CFL/Dyck Reachability: An Algorithmic Perspective},
year = {2023},
issue_date = {October 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {9},
number = {4},
url = {https://doi.org/10.1145/3583660.3583664},
doi = {10.1145/3583660.3583664},
abstract = {CFL/Dyck reachability is a simple graph-theoretic problem: given a CFL/Dyck language L over an alphabet Σ, a graph G = (V, E) of Σ-labeled edges, and two distinguished nodes s, t ∈ V, does there exist a path from s to t that spells out a word in L? This simple notion of language-based graph reachability serves as the algorithmic formulation of a large number of problems in diverse domains, such as graph databases and program static analysis. This paper takes an algorithmic perspective on CFL/Dyck reachability, and overviews several recent advances concerning the decidability and complexity of the problem and some its close variants, as realized in the areas of automata theory and program verification.},
journal = {ACM SIGLOG News},
month = feb,
pages = {5–25},
numpages = {21}
}

@article{URMA2015127,
title = {Source-code queries with graph databases—with application to programming language usage and evolution},
journal = {Science of Computer Programming},
volume = {97},
pages = {127-134},
year = {2015},
note = {Special Issue on New Ideas and Emerging Results in Understanding Software},
issn = {0167-6423},
doi = {https://doi.org/10.1016/j.scico.2013.11.010},
url = {https://www.sciencedirect.com/science/article/pii/S0167642313002943},
author = {Raoul-Gabriel Urma and Alan Mycroft},
keywords = {Programming language evolution, Source-code queries and DSLs, Graph databases},
abstract = {Program querying and analysis tools are of growing importance, and occur in two main variants. Firstly there are source-code query languages which help software engineers to explore a system, or to find code in need of refactoring as coding standards evolve. These also enable language designers to understand the practical uses of language features and idioms over a software corpus. Secondly there are program analysis tools in the style of Coverity which perform deeper program analysis searching for bugs as well as checking adherence to coding standards such as MISRA. The former class are typically implemented on top of relational or deductive databases and make ad-hoc trade-offs between scalability and the amount of source-code detail held—with consequent limitations on the expressiveness of queries. The latter class are more commercially driven and involve more ad-hoc queries over program representations, nonetheless similar pressures encourage user-visible domain-specific languages to specify analyses. We argue that a graph data model and associated query language provides a unifying conceptual model and gives efficient scalable implementation even when storing full source-code detail. It also supports overlays allowing a query DSL to pose queries at a mixture of syntax-tree, type, control-flow-graph or data-flow levels. We describe a prototype source-code query system built on top of Neo4j using its Cypher graph query language; experiments show it scales to multi-million-line programs while also storing full source-code detail.}
}

@InProceedings{10.1007/978-3-030-54832-2_6,
author="Orachev, Egor
and Epelbaum, Ilya
and Azimov, Rustam
and Grigorev, Semyon",
editor="Darmont, J{\'e}r{\^o}me
and Novikov, Boris
and Wrembel, Robert",
title="Context-Free Path Querying by Kronecker Product",
booktitle="Advances in Databases and Information Systems",
year="2020",
publisher="Springer International Publishing",
address="Cham",
pages="49--59",
abstract="Context-free path queries (CFPQ) extend the regular path queries (RPQ) by allowing context-free grammars to be used as constraints for paths. Algorithms for CFPQ are actively developed, but J. Kuijpers et al. have recently concluded, that existing algorithms are not performant enough to be used in real-world applications. Thus the development of new algorithms for CFPQ is justified. In this paper, we provide a new CFPQ algorithm which is based on such linear algebra operations as Kronecker product and transitive closure and handles grammars presented as recursive state machines. Thus, the proposed algorithm can be implemented by using high-performance libraries and modern parallel hardware. Moreover, it avoids grammar growth which provides the possibility for queries optimization.",
isbn="978-3-030-54832-2"
}

@misc{muravev2024optimizationcontextfreelanguagereachability,
      title={Optimization of the Context-Free Language Reachability Matrix-Based Algorithm}, 
      author={Ilia Muravev},
      year={2024},
      eprint={2401.11029},
      archivePrefix={arXiv},
      primaryClass={cs.PL},
      url={https://arxiv.org/abs/2401.11029}, 
}

@inproceedings{conf/icdt/Hellings14,
  added-at = {2017-05-23T00:00:00.000+0200},
  author = {Hellings, Jelle},
  biburl = {https://www.bibsonomy.org/bibtex/2118a89304a7ce7aeb5a3523ffadca17e/dblp},
  booktitle = {ICDT},
  editor = {Schweikardt, Nicole and Christophides, Vassilis and Leroy, Vincent},
  ee = {https://doi.org/10.5441/002/icdt.2014.15},
  interhash = {bf4bb42ab14d5fcf8b67609b50fbda2d},
  intrahash = {118a89304a7ce7aeb5a3523ffadca17e},
  keywords = {dblp},
  pages = {119-130},
  publisher = {OpenProceedings.org},
  timestamp = {2018-01-17T11:40:30.000+0100},
  title = {Conjunctive Context-Free Path Queries.},
  url = {http://dblp.uni-trier.de/db/conf/icdt/icdt2014.html#Hellings14},
  year = 2014
}

@inproceedings{10.1145/3210259.3210264,
author = {Azimov, Rustam and Grigorev, Semyon},
title = {Context-free path querying by matrix multiplication},
year = {2018},
isbn = {9781450356954},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3210259.3210264},
doi = {10.1145/3210259.3210264},
abstract = {Context-free path querying is a technique, which recently gains popularity in many areas, for example, graph databases, bioinformatics, static analysis, etc. In some of these areas, it is often required to query large graphs, and existing algorithms demonstrate a poor performance in this case. The generalization of matrix-based Valiant's context-free language recognition algorithm for graph case is widely considered as a recipe for efficient context-free path querying; however, no progress has been made in this direction so far.We propose the first generalization of matrix-based Valiant's algorithm for context-free path querying. Our generalization does not deliver a truly sub-cubic worst-case complexity algorithm, whose existence still remains a hard open problem in the area. On the other hand, the utilization of matrix operations (such as matrix multiplication) in the process of context-free path query evaluation makes it possible to efficiently apply a wide class of optimizations and computing techniques, such as GPGPU (General-Purpose computing on Graphics Processing Units), parallel processing, sparse matrix representation, distributed-memory computation, etc. Indeed, the evaluation on a set of conventional benchmarks shows, that our algorithm outperforms the existing ones.},
booktitle = {Proceedings of the 1st ACM SIGMOD Joint International Workshop on Graph Data Management Experiences \& Systems (GRADES) and Network Data Analytics (NDA)},
articleno = {5},
numpages = {10},
keywords = {GPGPU, context-free grammar, context-free path querying, graph databases, matrix multiplication, transitive closure},
location = {Houston, Texas},
series = {GRADES-NDA '18}
}

@misc{belyanin2024singlesourceregularpathquerying,
      title={Single-Source Regular Path Querying in Terms of Linear Algebra}, 
      author={Georgiy Belyanin and Semyon Grigoriev},
      year={2024},
      eprint={2412.10287},
      archivePrefix={arXiv},
      primaryClass={cs.DS},
      url={https://arxiv.org/abs/2412.10287}, 
}

@misc{abzalov2023gllbasedcontextfreepathquerying,
      title={GLL-based Context-Free Path Querying for Neo4j}, 
      author={Vadim Abzalov and Vlada Pogozhelskaya and Vladimir Kutuev and Semyon Grigorev},
      year={2023},
      eprint={2312.11925},
      archivePrefix={arXiv},
      primaryClass={cs.DB},
      url={https://arxiv.org/abs/2312.11925}, 
}