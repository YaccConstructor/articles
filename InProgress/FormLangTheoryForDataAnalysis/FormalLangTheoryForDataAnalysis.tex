% Contributions of all types should be up to 5 pages in length (excluding references, which have no page limit) in the ACM Proceedings Format,
% two-column (sigconf), with shorter submissions (2 pages in length) being encouraged. Reviewing will be single-anonymous, such that submissions include author names. 
% Pending approval, all accepted papers will be published in the ACM Digital Library.


%%
%% This is file `sample-sigconf.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0

\DocumentMetadata{}
%%
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigconf]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Woodstock '18]{Woodstock '18: ACM Symposium on Neural
  Gaze Detection}{June 03--05, 2018}{Woodstock, NY}
\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
  June 03--05, 2018, Woodstock, NY}
\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Teach Formal Languages Together With Graph Querying for Great Power}
%\title{Bring Graph Querying and Formal Language Theory Together for Great Power}
%\title{Teach Formal Languages Together With Graph Querying for Great Good}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Nikolai Ponomarev}
\orcid{0009-0000-2382-5687}
\affiliation{%
  \institution{Saint Petersburg State University}
  \streetaddress{7-9 Universitetskaya Embankment}
  \city{St. Petersburg}
  \country{Russia}
}
\email{n.ponomarev@spbu.ru}

\author{Efim Kubishkin}
\orcid{0009-0009-5531-1758}
\affiliation{%
  \institution{Saint Petersburg State University}
  \streetaddress{7-9 Universitetskaya Embankment}
  \city{St. Petersburg}
  \country{Russia}
  \postcode{199034}
}
\email{st098235@student.spbu.ru}

\author{Egor Orachev}
\orcid{0000-0002-0424-4059}
\affiliation{%
  \institution{Saint Petersburg State University}
  \streetaddress{7-9 Universitetskaya Embankment}
  \city{St. Petersburg}
  \country{Russia}
}
\email{egor.orachev@gmail.com}

%\author{Vadim Abzalov}
%\affiliation{%
%  \institution{The Th{\o}rv{\"a}ld Group}
%  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
%  \city{Hekla}
%  \country{Iceland}}
%\email{larst@affiliation.org}

\author{Rustam Azimov}
\orcid{0000-0003-0223-5172}
\affiliation{%
  \institution{Saint Petersburg State University}
  \streetaddress{7-9 Universitetskaya Embankment}
  \city{St. Petersburg}
  \country{Russia}
}
\email{r.azimov@spbu.ru}

\author{Semyon Grigorev}
\orcid{0000-0002-7966-0698}
\affiliation{%
  \institution{Saint Petersburg State University}
  \streetaddress{7-9 Universitetskaya Embankment}
  \city{St. Petersburg}
  \country{Russia}
  \postcode{199034}
}
\email{s.v.grigoriev@mail.spbu.ru}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
%\renewcommand{\shortauthors}{N. Ponomarev and !!!, et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  Formal language theory has deep interconnection with graph structured data analysis: it is required to develop both query processing engines' frontend (parser and lexer) and formal language constrained path querying (FLPQ) evaluation algorithms.
  Efficient solution of respective problems requires strong theoretical background and applied skills not only in formal languages, but also in other areas such as graph theory and high-performance computing.
  We propose a course that is developed for software engineers, and focused on formal language related aspects of graph analysis, including query parsing and FLPQ evaluation algorithms.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
  <concept>
      <concept_id>10003456.10003457.10003527</concept_id>
      <concept_desc>Social and professional topics~Computing education</concept_desc>
      <concept_significance>500</concept_significance>
      </concept>
  <concept>
      <concept_id>10003752.10003766</concept_id>
      <concept_desc>Theory of computation~Formal languages and automata theory</concept_desc>
      <concept_significance>500</concept_significance>
      </concept>
  <concept>
      <concept_id>10002951.10002952.10003197</concept_id>
      <concept_desc>Information systems~Query languages</concept_desc>
      <concept_significance>500</concept_significance>
      </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Social and professional topics~Computing education}
\ccsdesc[500]{Theory of computation~Formal languages and automata theory}
\ccsdesc[500]{Information systems~Query languages}
%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Graph querying, formal language theory, formal language constrained path querying, regular path querying, RPQ, context-free path querying, CFPQ, education}


%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

Bridging the gap between fundamental disciplines and their applications is one of the important problems of education in software engineering.
Graph structured data analysis involves a broad range of areas including graph theory, high-performance computing, complexity analysis.
Development of high-quality data analysis solutions requires both deep theory knowledge and strong applied experience. 
It is a challenge for education to provide a comprehensive view of the area and to develop the necessary skills.

One of the disciplines that has deep interconnection with graph structured data analysis is formal language theory.
Formal languages are a fundamental part of graph query languages in at least two senses.
First of all, formal language theory is necessary to design query engines frontend, namely parser and lexer.
The second one is that formal language constrained path querying is an important part of modern graph query languages. 
An ability to utilize regular languages to specify path constraints (RPQ) is a part of GQL query language that is an ISO standard~\cite{2024gql}, and it is a part of SPARQL that is W3C standard~\cite{2013sparql}.
Context-free languages constrained path querying (CFPQ) is studied intensively~\cite{10.1145/3335783.3335791,10.1145/3167132.3167265,HELLINGS2025102475,10.1145/3398682.3399163}.
Moreover, respective proposal for Cypher language exists\footnote{OpenCypher Path Pattern Queries that allows one to specify context-free constraints: \url{https://github.com/opencypher/openCypher/pull/187}.}.

Even these two directions should be investigated together to find the best way to design query language to be able to express respective formal language constraints.
At the same time, to apply formal languages for graph analysis efficiently we should involve graph theory and high-performance computing.
Many questions regarding query language expressiveness power, query evaluation results representation, creation of respective algorithms that can handle huge graphs, may be answered more easily by using techniques from these disciplines together.

In this work we propose a course\footnote{Materials for the course: \url{https://github.com/FormalLanguageConstrainedPathQuerying/formal-lang-course/blob/main/README.en.md}.} that is developed for software engineers, and focused on formal language related aspects of graph analysis, including query parsing and formal language constrained path query execution algorithms.
This work is organized as follows.
\begin{itemize}
  \item The first part is motivation where we argue why we do exactly what we do and why we do it exactly in such a way. 
  \item The second part is a course structure description that consists of technical environment description, high-level structure of the course, including exercises and tests examples.
  \item The third part is a discussion of existing course that includes current limitations and drawbacks, and comparison with other related courses.
  \item The last part is a brief conclusion and possible future improvements of the presented course.
\end{itemize}  

\section{Motivation}

We are aimed to create an engineering-oriented course with relatively low but strong fundamental prerequirements that allows students to investigate interconnection between formal languages, graph analysis, high performance computing techniques and respective fundamentals.
To do so we provide a formal-language-centric point of view on graph query engines.
The idea of the course is to apply formal languages to design query engines and allows students to touch at least two areas of formal languages application: parsing and graph querying.
At the same time, both parsing and formal language constrained path querying (FLPQ)~\cite{10.1137/S0097539798337716} widely used not only in graph databases, but also in software analysis~\cite{10.1145/3583660.3583664}.
Moreover, graph databases have become a popular tool for code analysis~\cite{URMA2015127}.
So, we can smoothly combine different areas and demonstrate students a deep interconnection between them, and as a result, the course or its' parts may be useful for a broad range of students who study different areas of software engineering.

While parsing is a typical application of formal language theory, FLPQ allows us to demonstrate immediate and direct usage of a wider range of theoretical results to solve practical tasks.
For example, such fundamental results, as closure properties (e.g. Bar-Hillel theorem~\cite{BarHillel61} or the closure of regular languages under intersection) required to restrict graph query language expressive power and to provide respective query evaluation algorithms.
Moreover, formal-language-centric view on query evaluation provides a native way to represent infinite result in convenient finite form with well-established tools for analysis: since result of languages intersection is a language, any finite representation (e.g. grammar or automata) of respective language class is a representation of an answer.

Having strong theoretical results, one should put them into user-friendly form to develop query language, that requires discussion of language design and implementation, particularly parsing.
Well-established parsing algorithm, such as LR(k) or LL(k), and actively developed generalized versions (e.g. Generalized LL (GLL)~\cite{10.1007/978-3-662-46663-6_5}) can be used not only for parsing, but also as a base for CFPQ algorithms~\cite{MEDEIROS201975,10.1007/978-3-319-91662-0_17, 10.1145/3166094.3166104}.
At the same time, combination with graph analysis allows students to get a refreshed view on parsing algorithms and old problems that became actual again in the new context.
For example, incrementalization and parallelization of parsing algorithms in the context of huge graph processing, variability of both grammars (queries) and graphs, require discussion of dynamic graph problems, parallel and distributed graph processing.
Another example is a grammar disambiguation that is a classical problem in parsing.
But sometimes ambiguous queries can be evaluated faster than disambiguated versions, especially for reachability querying.

High-performance solutions are necessary for real-world graph analysis and one promising way to achieve required performance is an utilization of linear algebra~\cite{suitesparse}.
Also, linear algebra provides a suitable abstraction level that hides lots of technical details but requires application level optimizations techniques to achieve high performance.
So, we include a number of FLPQ algorithms that are based on operations over boolean matrices and vectors to introduce students to high-performance graph analysis techniques without huge preliminary work.
At the same time, native description of these algorithms requires a custom semirings introduction that forces students to refresh linear algebra knowledge. 

Thus, based on strong fundamentals of formal language theory we cover several applied aspects of graph query engines, such as query language parsing and formal language constrained path queries evaluation algorithms for different classes of languages.
Also we touch other important applied and fundamental areas such as graph analysis, linear algebra, high-performance computing.

\section{The Course}

The course was initially designed for third year bachelor students studying software engineering.
But with tiny modification it is also used for first year masters in software engineering.
Presented version of the course is used in two universities during several years but is still under development.

\subsection{Prerequirements}

This course is designed for programming engineers so it requires basic engineering skills in Git version control system and GitHub infrastructure, including CI actions and code review mechanisms.

We expect an intermediate level in Python programming, including experience with testing frameworks, linters, formatters, dependency managers. 

Also, we expect a basic level of linear algebra.
Students should be fluent in such concepts as matrices, vectors, semirings.
They should know definitions and properties of matrix-matrix operations such as Kronecker product, elementwise operations, matrix-matrix multiplications, matrix-vector multiplication. 

Basic level of graph theory is required, including definitions and properties of directed edge-labeled graphs and relative concepts like path and cycle.
We expect an experience in basic graph analysis algorithms analysis and implementation, such as traversal algorithms (BFS and DFS), path problems related, and reachability problem related algorithms (transitive closure computation, Dijkstra's algorithm, Floyd–Warshall algorithm).

Programming languages theory is also required. 
Particularly, we expect basic knowledge in formal semantics, type systems, experience in interpreters implementation.

\subsection{Learning Outcomes}

Upon completing the course, students will be able to explain where and how formal language constrained path querying (including RPQ, CFPQ) can be applied, and how graph databases and static code analysis are interconnected.

Also, students will be able to formulate FLPQ problem and explain differences between query semantics.
Additionally, they will be able to explain the interconnection between formal language classes and fundamental aspects of FPLQ, including decidability and results representation.

Students will be able to operate with regular languages and its representations, particularly to convert regular expressions to finite automata and back, to intersect regular languages, and to implement linear algebra based algorithms for RPQ. 

The same holds true for context-free languages and their representations.
Students will be able to convert context-free grammar (CFG) to recursive state machine (RSM), to build derivation trees, to implement various algorithms for CFPQ, including linear algebra based and GLL based, and to explain how language and grammar properties interconnect with respective algorithms' properties. 

Additionally, students will be able to use linear algebra for graph analysis. 
Particularly, they will be able to reduce RPQ and CFPQ related problems to boolean linear algebra, to analyze the performance of respective algorithms, to explain the importance of matrices formats and basic optimization techniques.

Finally, students will be able to develop query languages: to use ANTLR parser generator to create parsers, to craft interpreters that use FLPQ algorithms to evaluate queries, provide type checking, and grammar (query) consistency checking.
They will be able to explain basic parsing algorithms, including LL, LR, GLL, to describe differences between them, and limitations of respective tools. 


\subsection{The Structure}

The course is structured with respect to the hierarchy of languages and respective computation machines (Chomsky hierarchy), that often uses to organize materials in the typical formal language theory related courses.
Almost all parts combine the theory, respective algorithms and its analysis, including discussion of performance-critical implementation details, possible optimization techniques. 
Brief content of the parts is provided below.

\begin{enumerate}
  \item \label{fl_intro} \textbf{Introduction to formal languages.} This section includes basic definitions such as alphabet, word, language, basic operations over words and languages, including set-theoretic ones. 
  Here, we also introduce the classical Chomsky hierarchy of languages and respective computation machines.
  
  \item \label{graphs_intro} \textbf{Introduction to graphs and linear algebra.} This part should be tuned with respect to initial level of students such that finally students will be familiar with basic definitions and algorithms, such as definitions of directed and undirected edge-labelled graphs, paths, and cycles, formulation of reachability and paths problems, and respective algorithms. 
  Additionally, graph representations, including adjacency matrix and its boolean decomposition, and basic graph analysis algorithms in terms of linear algebra, such as transitive closure and multiple-source BFS, should be introduced.
  
  \item \label{flpq_intro} \textbf{Introduction to formal language constrained path querying.} 
  This part introduces the formal language constrained path querying (FLPQ)~\cite{10.1137/S0097539798337716} problem statement in the most general form, and describes different semantics, including reachability, all-paths, all-pairs, multiple-sources. 
  Fundamental problems, such as infinite number of paths, and, as a result, inability to represent the answer as a set explicitly in some cases, decidability for different language classes, are also discussed here.
  To bring the gap between two areas we demonstrate that string parsing or recognition problem is a partial case of FLPQ. 
  At the same time we show that there is a number of differences with classical languages processing, such as the fact that language is not fixed in graph querying: while in classical language processing cases we assume that the language is fixed and the string is varying, in graph querying both graph and language can varying.
  Also, we discuss the history of FLPQ from Mihalis Yannakakis and Thomas Reps to nowadays, including areas of applications, examples, the difference and interconnection between static code analysis and graph databases.

  \item \label{regular_languages_intro} \textbf{Regular languages.} Here, we introduce regular languages and ways to specify them, such as regular expression, regular grammars, and finite automata, with transformations between them. 
  We discuss formal properties of languages and show how they relate with RPQ.
  For example, the fact that regular languages are closed under intersection is the base of RPQ that allows one to consider respective algorithms and query evaluation results representation.
  Respective algorithms are introduced here.
  
  \item \label{cf_languages_intro} \textbf{Context-Free languages.} Here, we introduce context-free languages and ways to specify them, including grammars, recursive state machines (RSMs) and conversions between them.
  Similarly to regular languages, we introduce formal properties that are important for CFPQ, such as Bar-Hillel theorem that claims context-free languages are closed under intersection with regular ones, and respective algorithms.
  Also, we discuss differences and interconnections between CFPQ and parsing.
  
  \item \label{new_old_problems_discussion} \textbf{Discussion of well-known old challenges that became actual again.} 
  Parallel and distributed parsing is not a so hot problem, but parallel and distributed query processing is. 
  Another problem is a handling changes in input that still actual for parsing but became more complex challenge in graph querying.
  The main reason is that in FLPQ both graph and grammar can vary while in parsing only string can.
  
  \item \label{parsing_techniques} \textbf{Query language implementation.}
  Here, we introduce classical LL(k) and LR(k) parsing algorithms, among with generalized algorithms like GLL, and provide a comparison of respective language classes.
  We describe typical language processing workflow: lexing, parsing, abstract syntax tree construction, and interpretation (with respect to previously introduced FLPQ algorithms).
  ANTLR as one of the modern production-quality parser generation tool is introduced.
  
  \item \label{beyond_chomsky_hierarchy} \textbf{Beyond Context-Free languages and Chomsky hierarchy.}
  In this part language classes that are more expressive than context-free languages are introduced (namely, Multiple Context-Free languages (MCFL), Conjunctive and Boolean languages), because these classes of languages are used for static code analysis.~\cite{10.1145/3009837.3009848, 10.1145/3704854}. 
  For now, we discuss only basic definitions and properties without algorithms. 
\end{enumerate}


\subsection{Exercises}

Exercises are focused on FLPQ algorithms implementation and evaluation rather than basic concepts implementation.
So we force students to use libraries such as PyFormLang and sciPy to operate with languages, automata, or matrices.
The main part of exercises is focused on reachability problem for different classes of languages because this problem is often simpler to implement than path problem.
For example, it does not require special semirings in linear algebra based algorithms, the boolean one is enough.  
Different variations, such as all-pairs and multiple sources, are included.

Almost the all tasks are conceptually interconnected: students start from basic FLPQ algorithms, goes through that's evaluation, and create simple graph analysis system as a result of the course.
As an additional bonus, such scheme limits tasks skipping because some of them are necessary to complete another one.

A brief description of the tasks is presented below, in order that corresponds to the structure represented in the previous section.
\begin{enumerate}
  \item Implementation of all-pairs RPQ with reachability semantics, using Kronecker product, that is the basic finite automaton intersection algorithm.
  \item Implementation of multiple-source linear-algebra-based RPQ algorithm~\cite{belyanin2024singlesourceregularpathquerying}.%, including different versions such as one-to-many and many-to-many.
  \item RPQ algorithms evaluation and performance analysis including analysis of sparse matrix representation formats.
  \item Hellings's CFPQ algorithm~\cite{conf/icdt/Hellings14} implementation. This algorithm is a pretty simple, does not require linear algebra. and will be used as a baseline for evaluation.
  \item Matrix multiplication based CFPQ algorithm~\cite{10.1145/3210259.3210264} implementation that requires grammar in Chomsky normal form.
  \item Kronecker product based CFPQ algorithm~\cite{10.1007/978-3-030-54832-2_6} implementation that utilizes RSM for grammar representation.
  \item Implementation of GLL-based CFPQ algorithm~\cite{abzalov2023gllbasedcontextfreepathquerying} that does not use linear algebra and utilizes RSM to represent queries. 
  \item Evaluation performance analysis of implemented CFPQ algorithms with focus on different algorithms comparison. 
  \item Implementation of a parser for simple predefined query language using ANTLR. The language is focused on formal language constrained path querying, not a subset of GQL.
  \item Interpreter of simple graph query language implementation that uses previously implemented algorithms for queries evaluation and provides some additional static query checks.
\end{enumerate}

Exercises can be split into subtasks or equipped with additional introductory tasks, for example, with simple challenges aimed to investigate a new library.
All exercises also grouped in blocks that are three in total: Regular Languages, Context-Free Languages, and Parsing techniques.
This division is formal to introduce tests.
While blocks are almost synchronized with lectures, we do not separate introduction block because first two modules (\ref{fl_intro} and~\ref{graphs_intro}) sizes significantly varies with respect to initial level of students.


\subsection{Tests}

Each block is equipped with test to check related basics.
There is a bunch of questions for each block and each student randomly gets one of them and should provide an answer in 5 minutes. 
This allows us to check that student has mastered the basics related to exercises from the respective block.
Tests are used to weight students' score in a block of exercises. 
The main idea is that if the student cannot pass the test, then it is highly possible that exercises, even be passed, done with cheats.
Examples of questions are presented below.
\begin{enumerate}
   \item Convert the given regular expression to finite automaton.
   \item Provide a derivation tree for the given string and grammar.
   \item Convert the given context-free grammar to RSM.
\end{enumerate}


\subsection{Environment}

The course designed for engineers and includes a number of exercises that require unified coding environment for all students, simplifying work of tutor and mentors.
We chose the Python programming language as one of the most popular languages, particularly among students.
Additionally, all the required libraries available in Python and provide easy to use and well-documented interface.
Namely, we need libraries for formal languages, sparse linear algebra, parsers creation, and we choose the following ones.

PyFormLang\footnote{PyFormLang repository: \url{https://github.com/Aunsiels/pyformlang}}~\cite{10.1145/3408877.3432464} is used to provide basic formal languages concepts such as regular expressions, finite automata, context-free grammars, recursive automata, and operations over them such as automata minimization, regular expression to finite automata conversion, grammar to normal forms conversion and so on. 

SciPy\footnote{SciPy home page: \url{https://scipy.org/}} is used for sparse boolean linear algebra.
It provides different formats for sparse matrix representations, thus allows us to demonstrate a correlation between matrix representation format and performance of matrix-based algorithms. 

We use ANTLR~\cite{10.5555/2501720} as a parser generation tool.
ANTLR is one of the modern tools for parser development that supports Python as a target language: it can generate parsers in Python and appropriate runtime libraries are provided.

Also we use CFPQ-Data\footnote{CFPQ-Data project: \url{https://github.com/FormalLanguageConstrainedPathQuerying/CFPQ_Data}} for algorithms evaluation.
This dataset allows us to provide real-world graphs and queries from such areas as RDF analysis and static code analysis. 

Initial project structure with dependencies and checkers configured is provided as a GitHub repository to be forked by students.
The repository contains configured actions for CI, supplementary code, placeholders for exercises, functions signatures to implement, and other stuff to minimize preparation to assignments completing.
Rye\footnote{Rye project home page: \url{https://rye.astral.sh}} is used for dependencies management.

Automation is done using GitHub actions that trigger on pushes and pull requests, and includes tests execution, code style guide checking.
Note that actions should be extended by students to handle parser generation.
It allows us to automate control of assignments completing and use code review mechanisms to discuss assignments with students.

We use only open tests implemented using the Pytest framework, and they consist of two types.
The first one is a set of ordinary unit tests that check corner cases of algorithms.
The second one is a set of property-like tests that use the fact that students should implement algorithms for closely related problems.
Thus, different algorithms from different assignments should return the same results for randomly generated input.
This way we can simplify the testing system (no private tests) and avoid implementation fitting. 

\section{Discussion}

Smooth integration of different areas together with clear problems and challenges allows students to be involved in related research during course or right after it. 
Evaluation of matrix-based CFPQ algorithm, represented by Nikita Mishin, Iaroslav Sokolov et al. in ``Evaluation of the Context-Free Path Querying Algorithm Based on Matrix Multiplication''~\cite{10.1145/3327964.3328503} is an improved results of experiments done as the course exercises. 
Similarly, Egor Orachev~\cite{10.1007/978-3-030-54832-2_6}, and Ilia Muravev~\cite{muravev2024optimizationcontextfreelanguagereachability} done research as a development of exercises.

Courses that discuss fundamentals of graph querying often limited to RPQ-related classes (e.g. CRPQ), as in ``Foundations of Graph Path Query Languages'' by Diego Figueira~\cite{Figueira2022}, and do not cover other language classes. 
Some courses combine different techniques for graph processing, including parallel processing models, approximation techniques, path expressions and so on\footnote{The university of Edinburgh, Querying Large Graphs course: \url{http://www.drps.ed.ac.uk/16-17/dpt/cxinfr11121.htm}.}$^{,}$\footnote{University of Buffalo, Data Models and Query Languages course: \url{https://catalogs.buffalo.edu/preview_course_nopop.php?catoid=1&coid=1061}.}, rather than focusing on particular class of queries and respective techniques.
Query languages discussion is a typical part of data analysis related courses, but with focus on particular databases, query languages and its applications.
While SQL fundamentals and optimization techniques are often included in such courses, discussion of graph querying is limited\footnote{Charles University, Query Languages course (\url{https://www.ksi.mff.cuni.cz/~svoboda/courses/241-NDBI049/}), Advanced Database Systems course(\url{https://www.ksi.mff.cuni.cz/~svoboda/courses/241-NIE-PDB/}).}.


Also, we want to highlight some drawbacks and weakness of our course.
The first one is that practice with non-linear-algebra-based algorithm for FLPQ and parsing is very limited. 
%In some cases it is not a problem because students have compiler construction course that covers parsing-related topics.
But in the context of CFPQ these algorithms are important because they can natively solve all-paths multiple-sources queries, but require special techniques that cannot be natively inferred from linear-algebra-based algorithms.
Currently, only GLL-based algorithm implementation is included into exercises, but in restricted reachability version.

Some subtasks of the last part --- interpreter implementation --- requires special knowledge on programming language theory (e.g. type theory) and experience in programming languages processing.
One possible solution is to make this part more configurable and to introduce less specific subtasks.
So, interpreter development can be split into basic tasks that do not require advanced programming language theory, and advanced ones.


The proposed course, especially structure of exercises, hides basics of some concepts, such as sparse linear algebra or automata implementation.
But this way we learn to use existing libraries that is a useful skill for engineers, and allow students to touch real-world problems and tasks without huge amount of preliminary work.

Regarding the environment, one of the drawbacks is that it is necessary to check manually whether the requested algorithm was implemented by students.
It is necessary because exercises include several algorithms for the same (or similar) problems, for example four algorithms for CFPQ, and possible students' cheat is to resubmit single one implementation with slightly changed top level API.


\section{Conclusion And Future Work}

We describe the course that brings together formal language theory and graph analysis and involves linear algebra and high performance computing techniques in such a way that smoothly combines different areas with focus on applied graph analysis problems. 
Note that while this course has been taught for several years now, there is room for improvements.

One of the important technical improvements is to extend the testing system to provide performance testing. 
For now, performance analysis of the implemented algorithms can be done only in respective tasks on algorithms evaluation and comparison.
There is no automatic control on performance of implemented algorithms. 
So, students are not forced to provide not na\"ive solutions.
Moreover, they often provide solutions that contains trivial performance issues: no early exit in transitive-closure-like procedures, no analysis of sparse matrix format (so, randomly selected format is used) and so on.
Additionally, missing of optimizations can dramatically slow down property-based testing (both CI and local runs), and also lead to failure of CI for some students.

The next technical challenge is to replace sciPy with python-graphblas\footnote{Python wrapper for SuiteSparse:GraphBLAS: \url{https://github.com/python-graphblas/python-graphblas}.} in order to enforce studying of specific tools for high-performance graph analysis. 
It is not clear, whether sciPy should be replaced, or python-graphblas should be provided as an optional alternative for sciPy because sciPy is easier for beginners, but python-graphblas allows one to pay more attention on performance.
Also, sciPy provide straightforward control of matrix format, that is important for performance analysis, while in python-graphblas such a control is quite tricky.

Also, we want to show some ways to extend the course. 
First of all, more algorithms and related tasks can be added.
For example, multiple sources version of linear algebra based algorithm for CFPQ, proposed by Arseniy Terekhov et al~\cite{terekhov2021multiple}.
Other candidates to be added are path problem related linear algebra based algorithms for both RPQ and CFPQ.
All these algorithms allow students to touch new types of problems and investigate linear algebra based approach to graph analysis deeper.
But introduction of some of these algorithms is related to migration to python-graphblas because sciPy is not enough to implement them: some specific operations and ways to custom semirings specification and utilization is not provided in this library.

Important way to extend the course is to add more materials on languages beyond context-free, such as multiple context-free, boolean and conjunctive languages. 
These languages play an important role in static analysis, and deeper studying is important to realize the boundaries of expressivity power of graph query languages.
Also, discussion of these languages leads to nontrivial decidability analysis for FLPQ-related problems.
As a result, it leads to the introduction of approximation algorithms that are an important class of algorithms not covered by the current version of the course.
Not only theory, but also respective algorithmic exercises should be added.

Data for algorithms evaluation also should be extended to represent more different areas of FLPQ applications.
For example, for CFPQ it is necessary to add biological data~\cite{SevonEronen+2008+157+172}, data provenance related graphs and queries~\cite{8731467}, more code analysis related data.

All of the above leads to big number of exercises and one the possible solution is to make a significant number of them optional.
But finally it should be possible to configure consistent subset of exercises in terms that even subset of tasks allows students to a create self-contained application for graph analysis.
Globally, we want to achieve high flexibility of materials such that we would be able to use specific submodules in other related courses.
For example, in courses on formal languages, or static code analysis.


%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{FormalLangTheoryForDataAnalysis}


\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'.
