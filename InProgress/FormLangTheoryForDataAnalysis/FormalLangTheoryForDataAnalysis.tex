% Contributions of all types should be up to 5 pages in length (excluding references, which have no page limit) in the ACM Proceedings Format,
% two-column (sigconf), with shorter submissions (2 pages in length) being encouraged. Reviewing will be single-anonymous, such that submissions include author names. 
% Pending approval, all accepted papers will be published in the ACM Digital Library.


%%
%% This is file `sample-sigconf.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0

\DocumentMetadata{}
%%
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigconf]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Woodstock '18]{Woodstock '18: ACM Symposium on Neural
  Gaze Detection}{June 03--05, 2018}{Woodstock, NY}
\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
  June 03--05, 2018, Woodstock, NY}
\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Bring Graph Querying and Formal Language Theory Together for Great Power}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Semyon Grigorev}
\affiliation{%
  \institution{Institute for Clarity in Documentation}
  \streetaddress{P.O. Box 1212}
  \city{Dublin}
  \state{Ohio}
  \country{USA}
  \postcode{43017-6221}
}
\email{!!!@corporation.com}
\orcid{1234-5678-9012}

\author{Egor Orachev}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

\author{Vadim Abzalov}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

\author{Rustam Azimov}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

\author{Ekaterina Shemetova}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Trovato and Tobin, et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  A clear and well-documented \LaTeX\ document is presented as an
  article formatted for publication by ACM in a conference proceedings
  or journal publication. Based on the ``acmart'' document class, this
  article presents and explains many of the common variations, as well
  as many of the formatting elements an author may use in the
  preparation of the documentation of their work.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Graph querying, formal language theory, formal language constrained path querying, education}


%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

Bridging the gap between fundamental disciplines and applications is one of the important problems of education in software engineering.
Theory without applications --- bad idea.
At the same time, real-world problems requires huge amount of preparatory work before the !!!

Data analysis involves broad range of !!! .
Graph analysis.
Application of fundamental ones.
Motivation for students which focused on applied areas to study fundamental disciplines 

Formal languages is a basis for graph query languages. 
GQL ISO, Cypher, 

Integration of formal language theory + HPC + linear algebra + graphs to show interconnection between different areas.
How concepts and ideas from one area can be applied in another one with significant effect. 

For engineers, so it is important to equip theory with practical tasks to !!!motivate!!!. 

Historically, programming languages and natural language processing form an area of formal languages theory application 

In this work we describe our experience on such a course for third-year bachelor students.
Software engineering.
Structure of this work:
\begin{itemize}
  \item Motivation: why we do exactly what we do and why we do it exactly such a way. 
  \item Course structure: technical environment, Exercises and how they are related to !!!
  \item Discussion of existing course. 
  \item Conclusion and future work.
\end{itemize}  

\section{Motivation}

We are aimed to create an applied course with relatively low prerequirements and strong fundamental !!! which allows students to touch !!!! !!! !!!

Why formal language constrained path querying. 
Formal languages is not only parsing. 
It allows Smoothly combine different areas 
Main: data analysis and formal languages.
FLPQ part of the GQL ISO standard.

Immediate and direct usage of theory to solve practical tasks: Closure properties.
Languages intersection.
Results representation --- languages representation.
Complexity analysis.

Parsing algorithms and new old problems: incremental parsing, parallel parsing. In wew context (amount of data to process, variability of grammars, not only graphs etc).
Disambiguation of grammar.
Ambiguity not evil: sometimes ambiguous queries faster.
Especially for querying.
But not parsing.

Linear algebra provides a suitable abstraction level. Application level independent optimizations !!! HPC, matrices, easy to abstract.
One can easily replace one library with another without significant algorithm changes (but technical effort for different API-s).
As a result, easy to apply for real-world data.
Which also helps to solve a motivation problem (small synthetic tasks looks disconnected with real-world).

Selected algorithms can be expressed in terms of boolean matrices and vectors: easy to start.
No need to create custom semirings.
At the same time, native description of these algorithms requires custom semirings introduction.
Conversion techniques.
Weaker than semirings structure. 

Language design and implementation. 
Tooling for language implementation.
Parsing algorithm (LR, LL).
GLL. 
ANTLR is not a magic. 

Relations with other areas such as graph theory, dynamic graph problems, algebra.

Touch open problems (truly subcubic CFPQ) and motivate to study them (and respective fundamentals eg fine-grained complexity).
Performance on real-life problems.

\section{The Course}

Third year bachelor students.
Software engineering. 
To design query engines.

Not only linear algebra, but classical algorithms, parsing techniques.


\subsection{Prerequirements}

Git/github/CI

Python programming (intermediate level), testing frameworks, tets creation. 

Linear algebra basics: matrices, vectors, semirings, matrix-matrix operations such as Kronecker, elementwise operations, matrix-matrix multiplications, matrix-vector multiplication.

Basic graph theory: directed edge-labeled graphs, path problems, traversals (BFS, DFS), reachability problem and respective algorithms, transitive closure.

Programming languages theory: type systems, interpreters, so on.

\subsection{Learning Outcomes}

Upon completing this course, students will be able to ...

\begin{enumerate}
  \item Formal language constrained path querying, including RPQ, and CFPQ
  \item Basic theory on regular languages
  \item Basic theory on context-free languages
  \item Algorithms for RPQ
  \item Algorithms for CFPQ
  \item Graph analysis with linear algebra (GraphBLAS)
  \item Applications for RPQ, CFPQ
  \item Parsing algorithms: LL, LR, GLL
  \item Use ANTLR parser generator to create parsers., interpreters, etc.
\end{enumerate}

\subsection{The Structure}

The course is structured with respect to typical formal language theory course. 
Important aspects of formal language theory 
The following parts
\begin{enumerate}
  \item Introduction to formal languages that includes basic definitions such as \emph{alphabet}, \emph{word}, \emph{language}, basic operations, 
  \item Introduction to graphs and linear algebra.
  Path problems, reachability problems. Respective algorithms. 
  Matrices, edge-labelled graphs, directed, undirected. Transitive closure in terms of linear algebra, BFS in terms of linear algebra. Kronecker product and graph product.
  With respect to initial level of students.
  \item Introduction to formal language constrained path querying. problem statement (FLPQ), different semantics (reachability, paths, all-pairs, multiple-sources). 
  Problems (infinite number of paths, representation of such a set, desidability for different languages classes). 
  String to graph generalization. 
  History (Form Thomas Reps and Mihalis Yannakakis) and applications (examples, differences in static code analysis). 
  Differences with languages processing (grammar not fixed, input not fixed).
  \item Regular languages. Closure properties, languages representations (regular expression, finite automata). Regular path queries
  \item Context-Free languages. Grammars, RSM-s, closure properties. Derivation tree and SPPF as a way to represent paths. Context-Free path queries. 
  Closure properties. 
  Language representations (grammars, RSMs). 
  Bar-Hillel theorem. 
  Complexity. 
  Partial cases (Bradford, Pavlogianis, etc).
  \item New old problems. Parallel and distributed processing. Basic ideas from graphs and matrices to dynamic. 
  \item Query language design and implementation. On the top of previously implemented algorithms. ANTLR. Parsing algorithms. Parsing techniques.
  \item Beyond Context-Free languages and Chomsky hierarchy. Multiple Context-Free languages (MCFL). Conjunctive and boolean languages. Static code analysis.
\end{enumerate}

\subsection{Exercises}


Focused on reachability problem as on a simplest one. 
Different variations, including all-pairs and multiple source.
Practical part is oriented to engineering, not theory. 
Algorithms implementation.: use libs. 
No basic concepts reimplementation. PyFormLang.
This problem can be naturally described using boolean matrices. 
Applicable for real-world problems. 
Almost the all tasks are conceptually connected: starting from basics, through algorithms, to simple graph analysis system.

\begin{enumerate}
  \item All-pairs RPQ, tensors. Basic FA intersection algorithm. (commutativity of Kronecker product)
  \item RPQ multiple-source BFS-based. Another algorithm for automata intersection. Different versions of multiple-source BFS problem (set-to-set, etc).  
  \item RPQ evaluation and performance analysis. Different matrices formats etc. All-pairs vs multiple sources. Advanced: GPU or GraphBLAS. Easy switch.
  \item CFPQ Hellings. Pretty simple algorithm without linear algebra. Baseline for comparison with other algorithms. 
  \item CFPQ matrices (associativity and commutativity of operations), normal form for grammar.
  \item CFPQ tensors (unification of RPQ and CFPQ), RSF introduction.
  \item CFPQ GLL. 
  \item CFPQ evaluation and performance analysis. Different algorithms comparison. Advanced: GPU or GraphBLAS 
  \item Query language design. Introduction of GQL and other real-world languages. 
  \item Query language implementation. Graph query language introduction. GQL. Language design principles and problems. Interpreter. Other language implementation related tasks.
\end{enumerate}

Exercises can be splitted in subtasks or equipped with additional introductory tasks, for example, with simple tasks aimed to investigate a new library.

\subsection{Tests}

engineers, so less theorems, more practice.

Short tests on the main topics to check basic knowledge.
Each test before block. 

Three blocks:
\begin{enumerate}
  \item Regular Languages
  \item Context-free Languages
  \item Parsing techniques
\end{enumerate}

Each block contains a set of questions on basic concepts, theory, algorithms.
Examples of questions.
\begin{enumerate}
   \item To show whether Kronecker product is commutative operation. 
   \item To convert simple regular expression to finite automaton.
   \item To provide a derivation tree for the given string and grammar.
   \item To convert context-free grammar to recursive state machine.
   \item To provide an example of $k-MCFL(r)$ language for the given $k$ and $r$.
\end{enumerate} 

There is a bunch of questions for each block and each student randomly gets one of them and should provide an answer in 5 minutes. 
This allows us to check that student has mastered basics almost the all of which was used to complete exercises from the block.

\subsection{Environment}

Applied course, so programming tasks, needs automatization.

Python programming language.
PyFormLang\footnote{\url{https://github.com/Aunsiels/pyformlang}}~\cite{10.1145/3408877.3432464} is ued to provide basics formal languages concepts such as regular expressions, finite automata, context-free grammars, recursive automata, and operations over them such as automata minimization, regular expression to finite automata conversion and so on.
sciPy\footnote{\url{https://scipy.org/}} is used for sparse boolean linear algebra.
CFPQ-Data\footnote{\url{https://github.com/FormalLanguageConstrainedPathQuerying/CFPQ_Data}} as a collection of graphs and queries for algorithms evaluation.
ANTLR with Python target for parsers creation.

Initial structure as a repository to fork is provided. 
Placeholders, functions signatures,supplementary code.

Automation is done using GitHub actions and includes tests execution, code style guide checking, !!!!

We provide an open tests of two types.
The first one is a set of ordinary unit tests that check corner cases of algorithms.
The second one is a set of property-like tests: algorithms should return the same results for random input.
Previously created algorithms to tests tne new one.

\section{Discussion}

Motivation to study formal languages, refresh linear algebra, HPC....
Why matrices: pretty simple ideas and algorithms, rather than LR, hides implementation complexity, clear abstraction (it is easy to realize that one library of linear algebra operations can be replaced with another one). More over, students can do it yourself.

Simple formulation of engineering tasks, problems, challenges regarding performance allows students to be involved in related research during course or right after it. 
Evaluation of matrix-based CFPQ algorithm, represented by Nikita Mishin, Iaroslav Sokolov et al. in ``Evaluation of the Context-Free Path Querying Algorithm Based on Matrix Multiplication''~\cite{10.1145/3327964.3328503} is an improved results of experiments done as the course exercise. 

Orachev.
Muraviev.

Also we want to highlight some drawbacks and weakness of our course.
First is that practice with non-linear-algebra-based algorithm for FLPQ (and parsing, respectively) is limited. 
Different algorithms, based on GLR, GLL and other parsing algorithms. 
Only GLL, but reachability, not paths.
These algorithms are powerful (can natively solve all-paths queries), but require special techniques that cannot be natively inferred from linear-algebra-based algorithms.
Especially high-performance solution.
Looks like advanced block. 

Proposed structure hides basics of some concepts. 
For example, sparse linear algebra.
But this way we learn to use existing libraries that is a useful skill for engineers, and allow students to touch real-world problems and tasks without huge amount of preliminary work.

Manual control needed to check wether the requested algorithm implemented.
Few algorithms for the same (or similar) problems: it is possible to resubmit single one implementation.

Last part requires programming languages theory. May be omitted. Other blocks can be used independently in other courses.

Other courses ~\cite{Figueira2022}
%http://www.drps.ed.ac.uk/16-17/dpt/cxinfr11121.htm
% KNOWLEDGE GRAPHS  Lecture 11: Querying Property Graphs with Cypher

\section{Conclusion And Future Work}

We propose a course on !!! 

Possible directions 

Extend testing system: performance testing. 
For now performance analysis only in respective tasks.
No automatic control on performance of implemented algorithm. 
N\"ive solutions with performance issues: no early exit, no analysis of sparse matrix format.

Move it to python-graphblas\footnote{\url{https://github.com/python-graphblas/python-graphblas}.}

More algorithms.
Multiple sources versions of algorithms for CFL-r (linear-algebra based).
But it should be simplified first.
A bit more concepts required.

More optional tasks. 

More non-matrix-based algorithms.

More Beyond context-free (MCFG). 
Static analysis.
Matrices.

Decidability problems, so on.

To build an advanced course on data analysis. 
Materials (in Russian)\footnote{!!!}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{FormalLangTheoryForDataAnalysis}


\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'.
