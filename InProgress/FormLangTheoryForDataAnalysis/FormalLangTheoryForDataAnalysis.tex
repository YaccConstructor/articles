% Contributions of all types should be up to 5 pages in length (excluding references, which have no page limit) in the ACM Proceedings Format,
% two-column (sigconf), with shorter submissions (2 pages in length) being encouraged. Reviewing will be single-anonymous, such that submissions include author names. 
% Pending approval, all accepted papers will be published in the ACM Digital Library.


%%
%% This is file `sample-sigconf.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0

\DocumentMetadata{}
%%
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigconf]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Woodstock '18]{Woodstock '18: ACM Symposium on Neural
  Gaze Detection}{June 03--05, 2018}{Woodstock, NY}
\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
  June 03--05, 2018, Woodstock, NY}
\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Bring Graph Querying, Formal Language Theory, and Linear Algebra Together to Make It Better}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Semyon Grigorev}
\affiliation{%
  \institution{Institute for Clarity in Documentation}
  \streetaddress{P.O. Box 1212}
  \city{Dublin}
  \state{Ohio}
  \country{USA}
  \postcode{43017-6221}
}
\email{!!!@corporation.com}
\orcid{1234-5678-9012}

\author{Egor Orachev}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

\author{Vadim Abzalov}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

\author{Rustam Azimov}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

\author{Ekaterina Shemetova}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Trovato and Tobin, et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  A clear and well-documented \LaTeX\ document is presented as an
  article formatted for publication by ACM in a conference proceedings
  or journal publication. Based on the ``acmart'' document class, this
  article presents and explains many of the common variations, as well
  as many of the formatting elements an author may use in the
  preparation of the documentation of their work.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Graph querying, formal language theory, formal language constrained path querying, education}


%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

Bridging the gap between fundamental disciplines and applications is one of the important problems of education in software engineering.
At the same time, real-world problems requires huge amount of preparatory work before the !!!

Data analysis involves broad range of !!! .
Graph analysis.
Application of fundamental ones.
Motivation for students which focused on applied areas to study fundamental disciplines 

Formal languages is a basis for graph query languages. 
GQL ISO, Cypher, 

Integration of formal language theory + HPC + linear algebra + graphs to show interconnection between different areas. How concepts and ideas from one area can be applied in another one with significant effect. 

For engineers, so it is important to equip theory with practical tasks to !!!motivate!!!. Historically, programming languages and natural language processing form an area of formal languages theory application 

In this work we describe our experience on such a course for third-year bachelor students.
Software engineering.
Structure of this work:
\begin{itemize}
  \item Motivation: why we do exactly what we do and why we do it exactly such a way. 
  \item Course structure: technical environment, Exercises and how they are related to !!!
  \item Discussion of !!! and future work.
\end{itemize}  

\section{Motivation}

We are aimed to create an applied course with relatively low prerequirements and strong fundamental !!! which allows students to touch !!!! !!! !!!

Why formal language constrained path querying. 
Formal languages is not only parsing. 
It allows Smoothly combine different areas 
Main: data analysis and formal languages.
FLPQ part of the GQL ISO standard.

Immediate and direct usage of theory to solve practical tasks: Closure properties.
Languages intersection.
Results representation --- languages representation.
Complexity analysis.

Parsing algorithms and new old problems: incremental parsing, parallel parsing. In wew context (amount of data to process, variability of grammars, not only graphs etc).
Disambiguation of grammar.
Ambiguity not evil: sometimes ambiguous queries faster.
Especially for querying.
But not parsing.

Linear algebra provides a suitable abstraction level. Application level independent optimizations !!! HPC, matrices, easy to abstract.
One can easily replace one library with another without significant algorithm changes (but technical effort for different API-s).
As a result, easy to apply for real-world data.
Which also helps to solve a motivation problem (small synthetic tasks looks disconnected with real-world).

Selected algorithms can be expressed in terms of boolean matrices and vectors: easy to start.
No need to create custom semirings.
At the same time, native description of these algorithms requires custom semirings introduction.
Conversion techniques.
Weaker than semirings structure. 

Language design and implementation. 
Tooling for language implementation.
Parsing algorithm (LR, LL).
GLL. 
ANTLR is not a magic. 

Relations with other areas such as graph theory, dynamic graph problems, algebra.

Touch open problems (truly subcubic CFPQ) and motivate to study them (and respective fundamentals eg fine-grained complexity).

\section{The Course}

Third year bachelor students.
Software engineering. 

\subsection{Prerequirements}



Git/github/CI

linear algebra basics: matrices, vectors, semirings, matrix-matrix operations such as Kronecker, elementwise operations, matrix-matrix multiplications, matrix-vector muliplication.

Python programming (intermediate level), testing frameworks, tets creation. 

Basic graph theory: directed edge-labeled graphs, path problems, traversals (BFS, DFS), reachability problem and respective algorithms, transitive closure.

\subsection{Learning Outcomes}

\begin{enumerate}
  \item Formal language constrained path querying, including RPQ, and CFPQ
  \item Basic theory on regular languages
  \item Basic theory on context-free languages
  \item Algorithms for RPQ
  \item Algorithms for CFPQ
  \item Graph analysis with linear algebra (GraphBLAS)
  \item Applications for RPQ, CFPQ
  \item Parsing algorithms: LL, LR, GLL
  \item Experience with ANTLR, interpreters, etc.
\end{enumerate}

\subsection{Structure}

The course is structured with respect to typical FL. 
Important aspects of formal language theory  
\begin{enumerate}
  \item Introduction to formal languages, problem statement (FLPQ), different semantics (reachability, paths). 
  Problems (infinite number of paths, representation of such a set, desidability for different languages classes). 
  String to graph generalization. 
  History (Reps, Yannacacis) and applications (examples, differences in static code analysis). 
  Differences with languages processing (grammar not fixed, input not fixed).
  \item Introduction to graphs and linear algebra. 
  Matrices, edge-labelled graphs, directed, undirected. 
  With respect to initial level of students.
  \item Regular languages, queries. Closure properties, languages representations (regular expression, finite automata).
  \item Context-Free languages, queries. 
  Closure properties. 
  Language representations (grammars, RSMs). 
  Bar-Hillel theorem. 
  Complexity. 
  Partial cases (Bradford, Pavlogianis, etc).
  \item New old problems. Basic ideas from graphs and matrices to dynamic. 
  \item Query language design and implementation. On the top of previously implemented algorithms. ANTLR. Parsing algorithms. Parsing techniques.
  \item Beyond Context-free and Chomsky hierarchy. MCFL.
\end{enumerate}

\subsection{Exercises}

Focused on reachability problem as on a simplest one. 
Different variations, including all-pairs and multiple source.
Practical part is oriented to engineering, not theory. Algorithms implementation.: use libs. PyFormLang.
This problem can be naturally described using boolean matrices. 
Applicable for real-world problems. 
Starting form basics, throu algorithms, to simple graph analysis system.

\begin{enumerate}
  \item All-pairs RPQ, tensors. Basic FA intersection algorithm. (commutativity of Kronecker product)
  \item RPQ multiple-source BFS-based. Another algorithm for automata intersection. Different versions of multiple-source BFS problem (set-to-set, etc).  
  \item RPQ evaluation and performance analysis. Different matrices formats etc. All-pairs vs multiple sources. Advanced: GPU or GraphBLAS. Easy switch.
  \item CFPQ Hellings. Pretty simple algorithm without linear algebra. Baseline for comparison with other algorithms. 
  \item CFPQ matrices (associativity and commutativity of operations), normal form for grammar.
  \item CFPQ tensors (unification of RPQ and CFPQ), RSF introduction.
  \item CFPQ GLL. 
  \item CFPQ evaluation and performance analysis. Different algorithms comparison. Advanced: GPU or GraphBLAS 
  \item Query language design. Introduction of GQL and other real-world languages. 
  \item Query language implementation. Graph query language introduction. GQL. Language design principles and problems.
\end{enumerate}

Exercises can be splitted in subtasks or equipped with additional introductory tasks, for example, with simple tasks aimed to investigate a new library.

\subsection{Tests}

engineers, so less theorems, more practice.

Short tests on the main topics to check basic knowledge.
Each test before block. 

Three blocks:
\begin{enumerate}
  \item Regular Languages
  \item Context-free Languages
  \item Parsing techniques
\end{enumerate}

\subsection{Environment}

Automatization. 
Python programming language, PyFormLang\footnote{!!!}~\cite{10.1145/3408877.3432464} for basis forma languages concepts: regular expressions, finite automata, context-free grammars, recursive automata, and operations over them (automata minimization, regular expression to finite automata conversion) , CFPQ-Data\footnote{!!!} as a collection of graphs and queries, sciPy\footnote{!!!} for sparse linear algebra.

Testing (unit tests), code style guide checkers, automation using GitHub actions.

We provide an open tests of two types.
The first one is a set of ordinary unit tests that check corner cases of algorithms.
Te second one is a set of property-like tests. : algorithms should return the same results for random input.
Previously created algorithms to tests tne new one.


\section{Discussion}

Motivation to study formal languages, refresh linear algebra, HPC....
Why matrices: pretty simple ideas and algorithms, rather than LR, hides implementation complexity, clear abstraction (it is easy to realize that one library of linear algebra operations can be replaced with another one). More over, students can do it yourself.

Also we want to highlight some drawbacks and weakness of our course.
First is that practice with non-linear-algebra-based algorithm for FLPQ (and parsing, respectively) is limited. 
Different algorithms, based on GLR, GLL and other parsing algorithms. 
Only GLL, but reachability, not paths.
These algorithms are powerful (can natively solve all-paths queries), but require special techniques that cannot be natively inferred from linear-algebra-based algorithms.
Especially high-performance solution.
Looks like advanced block. 

Proposed structure hides basics of some concepts. 
For example, sparse linear algebra.
But this way we learn to use existing libraries that is a useful skill for engineers, and allow students to touch real-world problems and tasks without huge amount of preliminary work.

\section{Conclusion And Future Work}

We propose a course on !!! 

Possible directions 

Move it to python-graphblas\footnote{\url{https://github.com/python-graphblas/python-graphblas}.}

Algorithms. Multiple sources versions of algorithms for CFL-r (linear-algebra based).
But it should be simplified first.
A bit more concepts required.

Optional tasks. 

Non matrix based algorithms.

More Beyond context-free (MCFG). 
Static analysis.

Decidability problems, so on.

To build an advanced course on data analysis. 
Materials (in Russian)\footnote{!!!}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{FormalLangTheoryForDataAnalysis}


\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'.
