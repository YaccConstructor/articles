% Contributions of all types should be up to 5 pages in length (excluding references, which have no page limit) in the ACM Proceedings Format,
% two-column (sigconf), with shorter submissions (2 pages in length) being encouraged. Reviewing will be single-anonymous, such that submissions include author names. 
% Pending approval, all accepted papers will be published in the ACM Digital Library.


%%
%% This is file `sample-sigconf.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0

\DocumentMetadata{}
%%
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigconf]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Woodstock '18]{Woodstock '18: ACM Symposium on Neural
  Gaze Detection}{June 03--05, 2018}{Woodstock, NY}
\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
  June 03--05, 2018, Woodstock, NY}
\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Teach Formal Languages Together With Graph Querying for Great Power}
%\title{Bring Graph Querying and Formal Language Theory Together for Great Power}
%\title{Teach Formal Languages Together With Graph Querying for Great Good}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Semyon Grigorev}
\email{!!!@corporation.com}
\orcid{1234-5678-9012}
%\author{Nikolay Ponomarev}
%\email{!!!@corporation.com}
%\orcid{!!!!}
%\author{Efim Kubishkin}
%\email{!!!@corporation.com}
%\orcid{!!!}
\affiliation{%
  \institution{Institute for Clarity in Documentation}
  \streetaddress{P.O. Box 1212}
  \city{Dublin}
  \state{Ohio}
  \country{USA}
  \postcode{43017-6221}
}

\author{Egor Orachev}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

\author{Vadim Abzalov}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

\author{Rustam Azimov}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

\author{Ekaterina Shemetova}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Trovato and Tobin, et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  A clear and well-documented \LaTeX\ document is presented as an
  article formatted for publication by ACM in a conference proceedings
  or journal publication. Based on the ``acmart'' document class, this
  article presents and explains many of the common variations, as well
  as many of the formatting elements an author may use in the
  preparation of the documentation of their work.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Graph querying, formal language theory, formal language constrained path querying, education}


%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

Bridging the gap between fundamental disciplines and applications is one of the important problems of education in software engineering.
One of the fundamental disciplines that has broad range of applications is a formal language theory.
One of the applied area is a data analysis.

Data analysis involves broad range of !!! .
Graph analysis.
Application of fundamental ones.
Motivation for students which focused on applied areas to study fundamental disciplines 

Formal languages is a fundamental part of graph query languages in two senses at least.
First of all, formal language theory is necessary to design query engines frontend, namely parser and lexer.
The second one is that formal language constrained path querying is a part of modern graph query languages. 
Regular languages. It is stanartyzed GQL ISO, it is a part of Cypher, SPARQL, W3C 
Context-free proposal for Cypher.
Combined: how to design query language to be able to express formal language constraints.

At the same time, to apply formal languages for graph analysis we should involves graph theory.
And to do it efficiently, we should apply high performance data analysis techniques, such as linear algebra that allows one to build highly parallel graph analysis algorithms.
Integration of formal language theory + high-performance techniques + linear algebra + graphs to show interconnection between different areas.
How concepts and ideas from one area can be applied in another one with significant effect. 
For example, Formal languages allows one to specify path constraints.
How should we restrict query language power to be able to provide evaluation algorithm?
How can we represent a query evaluation result?
But how to build such a representation efficiently for huge graphs?
How can linear algebra helps to solve this challenge?
The answers on these questions were easier if utilize formal language theory, graph theory, high performance techniques together.

For engineers, so it is important to equip theory with practical tasks to !!!motivate!!!. 

Historically, programming languages and natural language processing form an area of formal languages theory application
We propose to move focus on wide ... classical parsing is a partial case of CFPQ. 

In this work we propose a course\footnote{Materials are available \url{!!!}.} that is focused on software engineers, and focused on formal language related aspects of graph analysis, including query parsing and formal language constrained path query execution algorithms.
This work is organized as follows.
\begin{itemize}
  \item The first part is motivation where we argue why we do exactly what we do and why we do it exactly such a way. 
  \item The second part is a course structure description. It includes technical environment description, high-level structure of the course, including main modules, exercises and tests examples.
  \item The third part is a discussion of existing course that includes current limitations and drawbacks, and comparison with other related courses.
  \item The last part is a brief conclusion and possible future improvements of the presented course.
\end{itemize}  

\section{Motivation}

We are aimed to create an applied course with relatively low but strong fundamental prerequirements that allows students to learn interconnection between formal languages, graph analysis and high performance techniques and respective fundamentals.

Formal language theory centric view on graph query engine.
The idea of the course is to apply formal languages to design query engines and allows students to touch at least two areas of formal languages application: parsing and graph querying.

Graph is a fundamental concept that arises in broad range of applications Static code analysis. Graph databases. Query languages.

Why formal language constrained path querying. 
Formal languages is not only parsing.
But query engines requires parsing too.
It allows us Smoothly combine different areas and demonstrate deep interconnection between them.
Main: data analysis and formal languages.
FLPQ part of the GQL ISO standard.

Immediate and direct usage of theory to solve practical tasks: Closure properties.
Fundamental questions in graph query expressive power and query result representation. 
Formal language theory is necessary to answer !!!
 Languages intersection.
Query results representation --- languages representation.
Any finite representation of regular language is a representation of an answer.
A way to represent infinite result in convenient finite form with well-established tools for analysis.
Complexity analysis.

At the same time, combination with graph analysis allows one to get a refreshed view on parsing algorithms and old problems that became actual again in new context.
For example, incremental parsing, parallel parsing. 
In a new context (amount of data to process, variability of grammars, not only graphs etc).
Another example is a grammar disambiguation that is classical problem for parer developers.
On the one hand, generalized parsing is a base for querying algorithms. 
At the same time time ambiguity is not an evil: sometimes ambiguous queries faster then disambiguated versions.
Especially for reachability querying.
But not for parsing or path problems.

Linear algebra provides a suitable abstraction level. 
Application level independent optimizations !!! HPC, matrices, easy to abstract.
One can easily replace one library with another without significant algorithm changes (but technical effort for different API-s).
As a result, easy to apply for real-world data.
Which also helps to solve a motivation problem (small synthetic tasks looks disconnected with real-world).

Significant part of the selected algorithms can be expressed in terms of boolean matrices and vectors: easy to start.
No need to create custom semirings.
At the same time, native description of these algorithms requires custom semirings introduction.
Conversion techniques.
Weaker than semirings structure: linear algebra, operation properties. 

Language design and implementation. 
Tooling for language implementation.
Well-established parsing algorithm (LR, LL).
Actively developed promising Generalized GLL. 
Moreover, CFPQ algorithms is based on parsing algorithms ~\cite{!!!,!!!,!!!}.
One of the most popular tool ANTLR is not a magic. 

Relations with other areas such as graph theory, dynamic graph problems, algebra, distributed graph processing.

Touch open problems (truly subcubic CFPQ) and motivate to study them (and respective fundamentals eg fine-grained complexity).
Performance on real-life problems.

Thus based on strong general fundamentals of formal language theory we cover several applied aspects of graph query engines, such as query language parsing and formal language constrained path queries evaluation algorithms for different classes of languages.
Also we touch other important applied and fundamental areas such as graph analysis, linear algebra, high-performance techniques.

\section{The Course}

The course was initially designed for third year bachelor students studying software engineering.
But with tiny modification also used for first year master students who also studying software engineering.
Presented version of the course were used in two universities during several years but still under development.

\subsection{Prerequirements}

This course is designed for programming engineers so it requires basic engineering skills in git version control system and GitHub infrastructure, including GitHub actions for CI, code review mechanisms and so on.

We expect an intermediate level in Python programming, including experience with testing frameworks, linters, formatters, dependency managers. 

We expect a basic level of linear algebra.
Students should freely operates with matrices, vectors, semirings.
They should know definitions and properties of matrix-matrix operations such as Kronecker product, elementwise operations, matrix-matrix multiplications, matrix-vector multiplication. 

Basic level of graph theory is required, including definitions and properties of directed edge-labeled graphs and relative concepts like path and cycle.

We expect an experience in basic graph analysis algorithms implementation and its fundamental properties, such as traversal algorithms (BFS and DFS), path problems related, and reachability problem related algorithms (transitive closure computation, Dijkstra's algorithm, Floydâ€“Warshall algorithm).

Programming languages theory is also required. 
Particularly, basic knowledge in formal semantics, type systems, experience in interpreters implementation.

\subsection{Learning Outcomes}

Upon completing the course, students will be able to explain where and how formal language constrained path querying (including RPQ, CFPQ) can de applied, and how graph databases and static code analysis are interconnected.

Also students will be able to formulate FLPQ problem and explain differences between its semantics.
Additionally they will be able to explain interconnection between formal languages classes and fundamental aspects of FPLQ, including decidability and results representation.

Students will be able to operate with regular languages and its representations, particularly to convert regular expression to finite automata and back, to intersect regular languages, and to implement linear algebra based algorithms algorithms for RPQ. 

The same for context-free languages and its representations. 
Students will be able to convert context-free grammar (CFG) to recursive state machine (RSM), to build derivation trees,to implement various algorithms for CFPQ, including linear algebra based abd GLL based, and to explain how language and grammar properties interconnect with respective algorithms' properties. 

Additionally, students will bw able to use linear algebra for graph analysis. 
Particularly, they will be able to reduce RPQ and CFPQ related problems to boolean linear algebra, to analyze performance of respective algorithms, to explain importance of matrices formats and basic optimization techniques.

Finally, students will be able to develop query languages, including ability to use ANTLR parser generator to create parsers, to craft interpreters that use FLPQ algorithms to evaluate queries, provide type checking, and grammar (query) consistancy checking. 
They will be able to explain basic parsing algorithms, including LL, LR, GLL, to describe differences between them, and limitations of respective tools. 


\subsection{The Structure}

The course is structured with respect to typical formal language theory related course meaning that there is a hierarchy of languages and respective computation machines (Chomsky hierarchy) that often uses to organize materials. 
Almost the all parts combines the theory, respective algorithms and its analysis, including discussion of performance-critical implementation details, possible optimization techniques. 
Brief content of parts is provided below.

\begin{enumerate}
  \item \label{fl_intro} \textbf{Introduction to formal languages} that includes basic definitions such as \emph{alphabet}, \emph{word}, \emph{language}, basic operations over words and languages, including set-theoretic ones. 
  Here we also introduce the classical Chomsky hierarchy of languages and respective computation machines.
  
  \item \label{graphs_intro} \textbf{Introduction to graphs and linear algebra} should be tuned with respect to initial level of students such that after this part students will be familiar with basic definitions and algorithms, such as definitions of directed and undirected edge-labelled graphs, paths, and cycles, formulation of reachability and paths problems, and respective algorithms. 
  Additionally, graph representations, including adjacency matrix and its boolean decomposition, and basic graph analysis algorithms in terms of linear algebra, such as transitive closure and multiple-source BFS, should be introduced.
  
  \item \label{flpq_intro} \textbf{Introduction to formal language constrained path querying.} 
  This part introduces the formal language constrained path querying (FLPQ)~\cite{doi:10.1137/S0097539798337716} problem statement in the most general form, and describes different semantics including reachability, all-paths, all-pairs, multiple-sources. 
  Fundamental problems, such as infinite number of paths, and, as a result, inability to represent the answer explicitly as a set in some cases, decidability for different languages classes, also discussed here. 
  To bring the gap between two areas we demonstrate that string parsing or recognition problem is a partial case of FLPQ. 
  At the same time we show that there is a number of differences with classical languages processing, such as the fact that language is not fixed in graph querying: while in classical language processing cases we assume that the language is fixed and the string is varying, in graph querying both graph and language can varying.
  Also we discuss history of FLPQ form Mihalis Yannakakis and Thomas Reps to now days, including areas of applications, examples, differences and interconnection between static code analysis and graph databases.

  \item \label{regular_languages_intro} \textbf{Regular languages} and ways to specify them, such as regular expression, regular grammars, and finite automata, with transformations between them. 
  We discuss formal properties of languages and show how they relate with RPQ.
  For example, the fact that regular languages are closed under intersection is the base of RPQ that allows one to consider respective algorithms and query evaluation results representation.
  Respective algorithms introduced here.
  
  \item \label{cf_languages_intro} \textbf{Context-Free languages} and ways to specify them, including grammars, recursive sate machines (RSM-s) and conversions between them.
  Similarly to regular languages, we introduce formal properties that are important for CFPQ, such as Bar-Hillel theorem that claims context-free languages are closed under intersection with regular ones, and respective algorithms.
  Also we discuss differences and interconnections between CFPQ and parsing.
  
  \item \label{new_old_problems_discussion} \textbf{Discussion of well-known old challenges that becomes actual again.} 
  Parallel and distributed parsing is not so hot problem, but parallel and distributed query processing is. 
  Another problem is a handling changes in input that still actual for parsing but became more complex challenge in context of querying because both graph and grammar can vary while in parsing only string can.
  
  \item \label{parsing_techniques} \textbf{Query language design and implementation}
  where we introduce classical LL(k) and LR(k) parsing algorithms, among with generalized algorithms like GLL, and provide a comparison of respective language classes.
  We describe typical language processing workflow including lexing, parsing, abstract syntax tree construction, and interpretation (with respect to previously introduced FLPQ algorithms).
  ANTLR as one of the modern production-quality parser generation tool is introduced.
  
  \item \label{beyond_chomsky_hierarchy} \textbf{Beyond Context-Free languages and Chomsky hierarchy.}
  In this part language classes that are more expressive than context-free languages introduced. 
  Namely, Multiple Context-Free languages (MCFL), Conjunctive and Boolean languages because these classes of languages are used for static code analysis~\cite{10.1145/3009837.3009848, 10.1145/3704854}. 
  For now we discuss only basic definitions and properties without algorithms. 
\end{enumerate}


\subsection{Exercises}

Exercises are focused on FLPQ algorithms implementation and evaluation rather that basic concepts implementation.
So we allow students to use libraries such as PyFormLang and sciPy to operate with languages, automata, or matrices.
The main part of exercises is focused on reachability problem for different classes of languages because the reachability problem is often simpler to implement than path problem.
For example it does not require special semirings in linear algebra based algorithms, the boolean one is enough.  
Different variations, such as all-pairs and multiple source, included.

Almost the all tasks are conceptually interconnected: starting from basic FLPQ algorithms, through its evaluation, simple graph analysis system will be created as a result of the course.
As an additional bonus, such scheme limits tasks skipping because some of them are necessary to complete another one.

Brief description of tasks are presented below in order that corresponds to the structure represented in the previous section.
\begin{enumerate}
  \item Implementation of all-pairs RPQ with reachability semantics, using Kronecker product, that is the basic finite automaton intersection algorithm.
  \item Implementation of multiple-source BFS-based RPQ algorithm, including different versions such as one-to-many and many-to-many.
  \item RPQ algorithms evaluation and performance analysis including analysis of sparse matrix representation formats.
  \item Hellings's CFPQ algorithm implementation that is a pretty simple algorithm without linear algebra and will be used as a baseline for evaluation. 
  \item Matrix multiplication based CFPQ algorithm implementation that requires grammar in Chomsky normal form.
  \item Kronecker product CFPQ algorithm implementation that utilizes RSM for grammar representation.
  \item Implementation of GLL-based CFPQ algorithm that do not use linear algebra and utilize RSM for query representation. 
  \item Evaluation performance analysis of implemented CFPQ algorithms with focus on different algorithms comparison. 
  \item Implementation of parser for simple predefined graph query language using ANTLR. The language is focused on formal language constrained path querying, not a subset of GQL.
  \item Interpreter of simple graph query language implementation that uses previously implemented algorithms for queries evaluation and provides some additional static query checks.
\end{enumerate}

Exercises can be splitted in subtasks or equipped with additional introductory tasks, for example, with simple challenges aimed to investigate a new library.

All exercises also grouped in blocks that are three in total: Regular Languages, Context-Free Languages, and Parsing techniques.
This division is formal to introduce tests.
While blocks are almost synchronised with lectures, we do not separate introduction block because first two modules (\ref{fl_intro} and~\ref{graphs_intro}) size significantly varying with respect to initial level of students.


\subsection{Tests}

Each block equipped with short tests to check related basic knowledge.
There is a bunch of questions for each block and each student randomly gets one of them and should provide an answer in 5 minutes. 
This allows us to check that student has mastered basics almost the all of which were used to complete exercises from the respective block.
Tests used to weight tasks.
The main idea is that is the student can not pass test, then highly possible that exercises, even be passed, done with cheats.
Examples of questions are presented below.
\begin{enumerate}
   \item Show whether Kronecker product is commutative operation. 
   \item Convert the given regular expression to finite automaton.
   \item Provide a derivation tree for the given string and grammar.
   \item Convert the given context-free grammar to RSM.
   % \item Provide an example of \emph{k-MCFL(r)} language for the given $k$ and $r$.
\end{enumerate}


\subsection{Environment}

The course is applied and include a number of programming-related exercises that requires respective environment to unify settings for all students and to simplify work of tutor and mentors.

We choose Python programming language as one of the most popular language, particularly among students.
Additionally, there are all required libraries implemented in Python and provide easy to use and well-documented interface.
Namely, we need libraries for formal languages, sparse linear algebra, parsers creation, and we choose the following ones.

PyFormLang\footnote{\url{https://github.com/Aunsiels/pyformlang}}~\cite{10.1145/3408877.3432464} is ued to provide basic formal languages concepts such as regular expressions, finite automata, context-free grammars, recursive automata, and operations over them such as automata minimization, regular expression to finite automata conversion, grammar to normal forms conversion and so on. 

SciPy\footnote{\url{https://scipy.org/}} is used for sparse boolean linear algebra.
It provides different formats for sparse matrices representations, thus allows us to demonstrate correlation between matrix representation format and performance of matrix-based algorithms. 

We use ANTLR\footnote{ANTLR (ANother Tool for Language Recognition) home page: \url{https://www.antlr.org/}}~\cite{10.5555/2501720} as a parser generation tool.
ANTLR is one of the modern tools for parsers development that supports Python as a target language: it can generates parser in Python and appropriate runtime libraries are provided.

Also we use CFPQ-Data\footnote{\url{https://github.com/FormalLanguageConstrainedPathQuerying/CFPQ_Data}} for algorithms evaluation.
This dataset allows us to provide real-world graphs and queries from such areas as RDF analysis and static code analysis. 

Initial project structure with dependencies and checkers configured is provided as a GitHub repository\footnote{In Russian \url{https://github.com/FormalLanguageConstrainedPathQuerying/formal-lang-course}} to be forked by students.
The repository contains configured actions for CI, supplementary code, placeholders for exercises, functions signatures to implement, and other stuff to minimize preparation to assignments completing.
Rye\footnote{\url{https://rye.astral.sh}} is used for dependencies management.

Automation is done using GitHub actions that trigger on pushes and pull requests, and includes tests execution, code style guide checking.
Note that actions should be extended by students to handle parser generation.
It allows us to automate control of assignments completing and use code review mechanisms to discuss assignments with students.

We use only an open tests implemented using Pytest framework and they consist of of two types.
The first one is a set of ordinary unit tests that check corner cases of algorithms.
The second one is a set of property-like tests that use the fact that students should implements algorithms for closely related problems.
Thus different algorithms form different assignments should return the same results for randomly generated input. 
This way we can simplify testing system (no private tests) and avoid algorithms fitting. 

\section{Discussion}

The proposed course is aimed to motivate students to investigate formal languages theory in , refresh linear algebra, HPC....
Why matrices: pretty simple ideas and algorithms, rather than LR, hides implementation complexity, clear abstraction (it is easy to realize that one library of linear algebra operations can be replaced with another one).

Simple formulation of engineering tasks, problems, challenges regarding performance allows students to be involved in related research during course or right after it. 
Evaluation of matrix-based CFPQ algorithm, represented by Nikita Mishin, Iaroslav Sokolov et al. in ``Evaluation of the Context-Free Path Querying Algorithm Based on Matrix Multiplication''~\cite{10.1145/3327964.3328503} is an improved results of experiments done as the course exercises. 
Similarly, Egor Orachev ~\cite{!!!}. 
Ilya Muraviev and optimizations of linear algebra based CFPQ algorithm.

Also we want to highlight some drawbacks and weakness of our course.
The first one is that practice with non-linear-algebra-based algorithm for FLPQ and parsing is very limited. 
In some cases it is not a problem because students have compiler construction course that covers parsing-related topics.
But in the context of CFPQ these algorithms are important because the can natively solve all-paths multiple-sources queries, but require special techniques that cannot be natively inferred from linear-algebra-based algorithms.
Currently, only GLL-based algorithm is introduced, but in restricted reachability version.

Some subtasks of the last part --- interpreter implementation --- requires special knowledge on programming language theory (e.g. type theory).
One of possible solution is to make this part more configurable and to introduce less specific tasks.

The proposed course, especially structure of exercises, hides basics of some concepts, such as sparse linear algebra or automata implementation.
But this way we learn to use existing libraries that is a useful skill for engineers, and allow students to touch real-world problems and tasks without huge amount of preliminary work.

Regarding environment, one of the drawbacks is that manual control needed to check wether the requested algorithm implemented by students.
It is necessary because exercises include several algorithms for the same (or similar) problems, for example four different algorithms for CFPQ, and possible students' cheat is to resubmit single one implementation with slightly changed top level API.

Other courses ~\cite{Figueira2022} on data querying related areas.
\footnote{\url{http://www.drps.ed.ac.uk/16-17/dpt/cxinfr11121.htm}}
% KNOWLEDGE GRAPHS  Lecture 11: Querying Property Graphs with Cypher
\footnote{\url{https://www.ksi.mff.cuni.cz/~svoboda/courses/241-NDBI049/}}
\footnote{\url{https://www.ksi.mff.cuni.cz/~svoboda/courses/241-NIE-PDB/}}
\footnote{\url{https://catalogs.buffalo.edu/preview_course_nopop.php?catoid=1&coid=1061}}
Advanced SQL, Graph databases, GQL, 

\section{Conclusion And Future Work}

We describe the course that bringing together formal language theory and graph analysis and involves linear algebra and high performance computing techniques such a way smoothly combines different areas with focus on applied graph analysis problems. 
Note that while this course has been taught for several years now, there is a room for improvements.

One of the important technical improvements is to extend testing system to provide performance testing. 
For now, performance analysis of the implemented algorithms can be done only in respective tasks on algorithms evaluation and comparison.
There is no automatic control on performance of implemented algorithms. 
So, students not forced to provide not n\"ive solutions.
Moreover, they often provide solutions with trivial performance issues: no early exit in transitive-closure-like procedures, no analysis of sparse matrix format (so, randomly selected format is used) and so on.
Additionally, we generate a bunch of property-based tests and these missed optimizations can slow down CI check (and even local ones) to tens of minutes, and also lead to failure on CI for some students.

The next technical challenge is to replace sciPy with python-graphblas\footnote{Python wrapper for SuiteSparse:GraphBLAS: \url{https://github.com/python-graphblas/python-graphblas}.} in order to enforce studying of specific tools for high-performance graph analysis. 
It is not clear, whether sciPy should be replaced, or python-graphblas should be provided as an optional alternative for sciPy because sciPy is easier for beginners, but python-graphblas allows one to pay more attention on performance.
Also, sciPy provide straightforward control of matrix format, that is important for performance analysis, while in python-graphblas such a control id quiet tricky.

Also we want to show some ways to extend the course. 
First of all, more algorithms and related tasks should be added.
For example, multiple sources version of linear algebra based algorithm for CFPQ, proposed by Arseniy Terekhov et al~\cite{terekhov2021multiple}.
Another candidates to be added are path problem related linear algebra based algorithms for both RPQ and CFPQ.
All these algorithms allows students to touch new types of problems and investigate linear algebra based approach to graph analysis deeper.
But introduction of some of these algorithms is related to migration to python-graphblas because sciPy is not enough to implement them: some specific operations and ways to custom semirings specification and utilization is not provided in this library.
Additionally, the current last tasks on query language development should be done more fine-grained. 
Interpreter development can be splitted into several tasks: basic that do not require advanced programming language theory, and advanced one.

One of important way to extend the course is to add more materials on languages beyond context-free, such as multiple context-free languages, boolean and conjunctive languages. 
Currently only basic introduction only presented. 
But these languages play important role in static analysis, and deeper studying is important to realize boundaries of expressivity power of graph query languages.
Discussion of some classes beyond context-free leads to nontrivial decidability analysis for FLPQ-related problems.
As a result, it leads to introduction of approximation algorithms that an important class of of algorithms that do not discuss in the current version of the course.
Not only theory, but also respective algorithmic exercises should be added.

Data for algorithms evaluation also should be extended to represent more different areas of FLPQ applications.
For example, for CFPQ it is necessary to add biological data~\cite{SevonEronen+2008+157+172}, data provenance related graphs and queries~\cite{8731467}, more code analysis related data.

All above leads to big number of exercises and one of possible solution is to make significant number of them optional.
But finally it should be possible to configure consistent subset of exercises in terms that even subset of tasks allows student to create self-contained application for graph analysis.
Globally we want to achieve high flexibility of materials such that it would be abel to use specific submodules in other related course.
For example, in courses on formal languages, or static code analysis.


%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{FormalLangTheoryForDataAnalysis}


\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'.
