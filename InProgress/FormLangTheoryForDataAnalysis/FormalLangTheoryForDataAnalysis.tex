% Contributions of all types should be up to 5 pages in length (excluding references, which have no page limit) in the ACM Proceedings Format,
% two-column (sigconf), with shorter submissions (2 pages in length) being encouraged. Reviewing will be single-anonymous, such that submissions include author names. 
% Pending approval, all accepted papers will be published in the ACM Digital Library.


%%
%% This is file `sample-sigconf.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0

\DocumentMetadata{}
%%
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigconf]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Woodstock '18]{Woodstock '18: ACM Symposium on Neural
  Gaze Detection}{June 03--05, 2018}{Woodstock, NY}
\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
  June 03--05, 2018, Woodstock, NY}
\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Teach Formal Languages Together With Graph Querying for Great Power}
%\title{Bring Graph Querying and Formal Language Theory Together for Great Power}
%\title{Teach Formal Languages Together With Graph Querying for Great Good}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Semyon Grigorev}
\affiliation{%
  \institution{Institute for Clarity in Documentation}
  \streetaddress{P.O. Box 1212}
  \city{Dublin}
  \state{Ohio}
  \country{USA}
  \postcode{43017-6221}
}
\email{!!!@corporation.com}
\orcid{1234-5678-9012}

\author{Egor Orachev}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

\author{Vadim Abzalov}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

\author{Rustam Azimov}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

\author{Ekaterina Shemetova}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Trovato and Tobin, et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  A clear and well-documented \LaTeX\ document is presented as an
  article formatted for publication by ACM in a conference proceedings
  or journal publication. Based on the ``acmart'' document class, this
  article presents and explains many of the common variations, as well
  as many of the formatting elements an author may use in the
  preparation of the documentation of their work.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Graph querying, formal language theory, formal language constrained path querying, education}


%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

Bridging the gap between fundamental disciplines and applications is one of the important problems of education in software engineering.
Theory without applications --- bad idea.
At the same time, real-world problems requires huge amount of preparatory work before the !!!


Data analysis involves broad range of !!! .
Graph analysis.
Application of fundamental ones.
Motivation for students which focused on applied areas to study fundamental disciplines 

Formal languages is a basis for graph query languages. 
GQL ISO, Cypher, SPARQL, W3C 

Integration of formal language theory + HPC + linear algebra + graphs to show interconnection between different areas.
How concepts and ideas from one area can be applied in another one with significant effect. 

For engineers, so it is important to equip theory with practical tasks to !!!motivate!!!. 

Formal languages Closure properties. Regular languages are closed under intersection. Any finite representation of regular language is s representation of an answer.

Historically, programming languages and natural language processing form an area of formal languages theory application 

In this work we describe our experience on such a course for third-year bachelor students.
Software engineering.
Structure of this work:
\begin{itemize}
  \item Motivation: why we do exactly what we do and why we do it exactly such a way. 
  \item Course structure: technical environment, Exercises and how they are related to !!!
  \item Discussion of existing course. Comparison with other related courses.
  \item Conclusion and future work.
\end{itemize}  

\section{Motivation}

We are aimed to create an applied course with relatively low prerequirements and strong fundamental !!! which allows students to touch !!!! !!! !!!

Why formal language constrained path querying. 
Formal languages is not only parsing.
But query engines requires parsing too.
It allows us Smoothly combine different areas 
Main: data analysis and formal languages.
FLPQ part of the GQL ISO standard.

Immediate and direct usage of theory to solve practical tasks: Closure properties.
Languages intersection.
Query results representation --- languages representation.
A way to represent infinite result in convenient finite form with well-established tools for analysis.
Complexity analysis.

Parsing algorithms and new old problems: incremental parsing, parallel parsing. In wew context (amount of data to process, variability of grammars, not only graphs etc).
Disambiguation of grammar.
Ambiguity not evil: sometimes ambiguous queries faster.
Especially for querying.
But not parsing.

Linear algebra provides a suitable abstraction level. Application level independent optimizations !!! HPC, matrices, easy to abstract.
One can easily replace one library with another without significant algorithm changes (but technical effort for different API-s).
As a result, easy to apply for real-world data.
Which also helps to solve a motivation problem (small synthetic tasks looks disconnected with real-world).

Selected algorithms can be expressed in terms of boolean matrices and vectors: easy to start.
No need to create custom semirings.
At the same time, native description of these algorithms requires custom semirings introduction.
Conversion techniques.
Weaker than semirings structure. 

Language design and implementation. 
Tooling for language implementation.
Parsing algorithm (LR, LL).
Generalized GLL. 
Moreover, CFPQ algorithms is based on parsing algorithms.
ANTLR is not a magic. 

Relations with other areas such as graph theory, dynamic graph problems, algebra, destributed graph processing.

Touch open problems (truly subcubic CFPQ) and motivate to study them (and respective fundamentals eg fine-grained complexity).
Performance on real-life problems.

\section{The Course}

The course was initially designed for third year bachelor students studying software engineering.
But with tiny modification also used for first year master students who also studying software engineering.
Presented version of the course were used in two !!! but still under development.


Formal language theory centric view on graph query engine.
The idea of the course is to apply formal languages to design query engines and allows students to touch at least two areas of formal languages application: parsing and graph querying.

Not only linear algebra, but classical algorithms, parsing techniques.
But without deep technical details.

\subsection{Prerequirements}

This course is designed for programming engineers so it requires basic engineering skills in git version control system and GitHub infrastructure, including GitHub actions for CI, code review mechanisms and so on.

We expect an intermediate level in Python programming, including experience with testing frameworks, linters, formatters, dependency managers. 

We expect a basic level of linear algebra.
Students should freely operates with matrices, vectors, semirings.
They should know definitions and properties of matrix-matrix operations such as Kronecker product, elementwise operations, matrix-matrix multiplications, matrix-vector multiplication. 

Basic level of graph theory is required, including definitions and properties of directed edge-labeled graphs and relative concepts like path and cycle.

We expect an experience in basic graph analysis algorithms implementation and its fundamental properties, such as traversal algorithms (BFS and DFS), path problems related, and reachability problem related algorithms (transitive closure computation, Dijkstra's algorithm, Floyd–Warshall algorithm).

Programming languages theory is also required. 
Particularly, basic knowledge in formal semantics, type systems, experience in interpreters implementation.

\subsection{Learning Outcomes}

Upon completing this course, students will be able to ...

\begin{enumerate}
  \item To explain where and how formal language constrained path querying (including RPQ, CFPQ) can de applied. 
  Graph databases, static code analysis. 
  Interconnection between graph databases and static code analysis.
  \item To formulate FLPQ problem and explain differences between semantics. 
  To explain interconnection between languages classes and fundamental !!!
  \item To operate with regular languages and its representations: to convert regexp to  FA and back, Grammar to FA. 
  To intersect regular languages.
  \item To operate with context-free languages and its representations: to convert grammar to RSM, to build derivation trees. 
  To explain when ambiguity os bad and good.
  \item To know that libs and to use it
  \item To implement linear algebra based algorithms Algorithms for RPQ. 
  \item To implement Algorithms for CFPQ, including linear algebra based, GLL based.
  \item To use linear algebra for Graph analysis with linear algebra (GraphBLAS). 
  To reduce problems to boolean linear algebra. 
  \item To analyze performance, to explain importance of formats and basic optimization techniques.
  \item To Parsing algorithms: LL, LR, GLL Differences and limitations. 
  \item To use ANTLR parser generator to create parsers. Basic abilities and limitations of the tool, 
  \item To interpreters, etc. To use plt for graph query languages. To use implemented algorithms as parts of interpreter
\end{enumerate}

\subsection{The Structure}

The course is structured with respect to typical formal language theory related course meaning that there is a hierarchy of languages and respective computation machines (Chomsky hierarchy) that often uses to organize materials. 
Almost the all parts combines the theory, respective algorithms and its analysis, including discussion of performance-critical implementation details, possible optimization techniques. 
Brief content of each part is provided below.

\begin{enumerate}
  \item \label{fl_intro} \textbf{Introduction to formal languages} that includes basic definitions such as \emph{alphabet}, \emph{word}, \emph{language}, basic operations over words and languages, including set-theoretic ones. 
  Here we also introduce the classical Chomsky hierarchy of languages and respective computation machines.
  
  \item \label{graphs_intro} \textbf{Introduction to graphs and linear algebra} should be tuned with respect to initial level of students such that after this part students will bw familiar with basic definitions and algorithms. 
  Namely, definitions of directed and undirected edge-labelled graphs, paths, and cycles. 
  Graph representations, including adjacency matrix and its boolean decomposition.
  Formulation of reachability and paths problems, and respective algorithms.  
  Basic graph analysis algorithms in terms of linear algebra, such as transitive closure and multiple-source BFS.
  Graph product and Kronecker product.
  
  \item \label{flpq_intro} \textbf{Introduction to formal language constrained path querying.} 
  This part introduces the formal language constrained path querying (FLPQ)~\cite{doi:10.1137/S0097539798337716} problem statement in the most general form, and describes different semantics including reachability, all-paths, all-pairs, multiple-sources. 
  History of FLPQ form Mihalis Yannakakis and Thomas Reps to now days, including areas of applications discussion (examples, differences in static code analysis). 
  Cypher, GQL, RPQ, Graph databases. 
  Fundamental problems, such as infinite number of paths, and, as a result, inability to represent the answer explicitly as a set in some cases, decidability for different languages classes, also discussed here. 
  To bring the gap between two areas we demonstrate that string parsing or recognition problem is a partial case of FLPQ. 
  At the same time we show that there is a number of differences with classical languages processing, such as the fact that language is not fixed in graph querying: while in classical language processing cases we assume that the language is fixed and the string is varying, in graph querying both graph and language can varying.

  \item \label{regular_languages_intro} \textbf{Regular languages} and the ways to specify them, such as regular expression, regular grammars, and finite automata, with transformations between them.
  Closure properties. Regular languages are closed under intersection that is RPQ base.
  Algorithms for regular path queries.
  All pairs that exactly the languages intersection. 
  Multiple source. 
  Algorithms analysis.
  
  \item \label{cf_languages_intro} \textbf{Context-Free languages}. Grammars, RSM-s, closure properties. Derivation tree and SPPF as a way to represent paths. Context-Free path queries. 
  Closure properties. 
  Language representations (grammars, RSMs). 
  Bar-Hillel theorem that clime that context-free languages are closed under intersection wit regular ones.
  Thus it is one of the fundamental theorem for CFPQ.
  Complexity. 
  Partial cases (Bradford, Pavlogianis, etc).
  Algorithms: Hellings, matrices, tensor. All-pairs reachability.
  
  \item \label{new_old_problems_discussion} \textbf{Discussion of well-known old challenges that becomes actual again.} 
  Parallel and distributed parsing is not so hot problem, but parallel and distributed query processing is. 
  Handling changes in input. 
  Still actual for parsing. 
  Became more complex challenge in context of querying because both graph and grammar can vary while in parsing only string can. 
  
  \item \label{parsing_techniques} \textbf{Query language design and implementation.}
  Parsing algorithms. Classical LL(k) and LR(k) algorithms. Comparison of respective language classes. Generalized paring. GLL.
  Parsing techniques. 
  Typical frontend structure: lexing, parsing, scanerless, abstract syntax, concrete syntax.
  ANTLR as one of the modern production-quality parser generation tool.
  Query language design on the top of previously implemented algorithms. 
    
  \item \label{beyond_chomsky_hierarchy} \textbf{Beyond Context-Free languages and Chomsky hierarchy.}
  In this part language classes that are more expressive than context-free languages introduced. 
  Namely, Multiple Context-Free languages (MCFL), Conjunctive and Boolean languages. 
  Basic definitions and properties. Without algorithms. 
  These classes of languages are used for static code analysis~\cite{10.1145/3009837.3009848, 10.1145/3704854}.

\end{enumerate}

Modules grouped in blocks that are three in total, all listed below.
\begin{enumerate}
  \item Regular Languages
  \item Context-free Languages
  \item Parsing techniques
\end{enumerate}

This division is formal to introduce tests.
We do not introduce introduction block because first two modules (\ref{fl_intro} and~\ref{graphs_intro}) size significantly varying with respect to initial level of students.
So it includes in the first block for now. \ref{fl_intro}, \ref{flpq_intro}


\subsection{Exercises}

Exercises are oriented to algorithms implementation and evaluation, not theory. 
The main part of exercises is focused on reachability problem for different classes of languages because the reachability problem is often simpler to implement than path problem.
For example it does not require special semirings in linear algebra based algorithms, the boolean one is enough.  
Different variations, such as all-pairs and multiple source, included.

Exercises are focused on FLPQ algorithms implementation rather that basic concepts implementation.
So we allow students to use libraries such as PyFormLang and sciPy to operate with languages, automata, or matrices.

We argue that algorithms and approaches (but not libraries) applicable for real-world problems. 
Almost the all tasks are conceptually connected: starting from basics, through algorithms, to simple graph analysis system.
Interconnection between parts. 
Inability to skip tasks. 

Brief description of tasks are presented below in order that corresponds to the structure represented in the previous section.
\begin{enumerate}
  \item To implement all-pairs RPQ with reachability semantics, using Kronecker product. Basic FA intersection algorithm. (commutativity of Kronecker product)
  \item To implement RPQ multiple-source BFS-based. Another algorithm for automata intersection. Different versions of multiple-source BFS problem (set-to-set, etc).
  \item RPQ evaluation and performance analysis. Different matrices formats etc. All-pairs vs multiple sources. Advanced: GPU or GraphBLAS. Easy switch.
  \item To implement Hellings's algorithm for CFPQ. Pretty simple algorithm without linear algebra. Baseline for comparison with other algorithms. 
  \item To implement CFPQ matrices (associativity and commutativity of operations), normal form for grammar.
  \item To implement CFPQ tensors (unification of RPQ and CFPQ), RSM introduction.
  \item To implement GLL-based CFPQ algorithm with reachability semantics. RSM for query representation. 
  \item To evaluate implemented CFPQ algorithm and to provide performance analysis. Different algorithms comparison. Advanced: GPU or GraphBLAS 
  \item To implement parser of simple graph query language. Query language design. Introduction of GQL and other real-world languages. Query language implementation. Graph query language introduction. GQL. Language design principles and problems. Proposed language is focused on language constrained path querying, not a subset of GQL.
  \item To implement interpreter of simple query language. Use previously implemented algorithms for operations. Other language implementation related tasks. Type inference. Grammar checks.
\end{enumerate}

Exercises can be splitted in subtasks or equipped with additional introductory tasks, for example, with simple challenges aimed to investigate a new library.

All exercises also grouped regarding blocks Regular, Context-Free, Parsing techniques.

\subsection{Tests}

The course equipped with short tests on the main topics to check basic knowledge.
Three tests in total: one test before each block. 

Each block contains a set of questions on basic concepts, theory, algorithms.
Examples of questions are presented below.
\begin{enumerate}
   \item To show whether Kronecker product is commutative operation. 
   \item To convert te given regular expression to finite automaton.
   \item To provide a derivation tree for the given string and grammar.
   \item To convert the given context-free grammar to recursive state machine.
   \item To provide an example of \emph{k-MCFL(r)} language for the given $k$ and $r$.
\end{enumerate} 

There is a bunch of questions for each block and each student randomly gets one of them and should provide an answer in 5 minutes. 
This allows us to check that student has mastered basics almost the all of which were used to complete exercises from the respective block.

Tests used to tune tasks. Main idea is that is the student can not pass test, then highly possible that exercises, even be passed, done with cheats.


\subsection{Environment}

The course is applied and include a number of programming-related exercises that requires respective environment to unify settings for all students and to simplify work of tutor and mentors.

We choose Python programming language as one of the most popular language, particularly among students.
Additionally, there are all required libraries implemented in Python and provide easy to use and well-documented interface.
Namely, we need libraries for formal languages, sparse linear algebra, parsers creation, and we choose the following ones.

PyFormLang\footnote{\url{https://github.com/Aunsiels/pyformlang}}~\cite{10.1145/3408877.3432464} is ued to provide basic formal languages concepts such as regular expressions, finite automata, context-free grammars, recursive automata, and operations over them such as automata minimization, regular expression to finite automata conversion, grammar to normal forms conversion and so on. 

SciPy\footnote{\url{https://scipy.org/}} is used for sparse boolean linear algebra.
It provides different formats for sparse matrices representations, thus allows us to demonstrate correlation between matrix representation format and performance of matrix-based algorithms. 

We use ANTLR\footnote{ANTLR (ANother Tool for Language Recognition) home page: \url{https://www.antlr.org/}}~\cite{10.5555/2501720} as a parser generation tool.
ANTLR is one of the modern tools for parsers development that supports Python as a target language: it can generates parser in Python and appropriate runtime libraries are provided.

Also we use CFPQ-Data\footnote{\url{https://github.com/FormalLanguageConstrainedPathQuerying/CFPQ_Data}} as a collection of graphs and queries for algorithms evaluation.
This dataset allows us to provide real-world graph and queries from such areas as RDF analysis and static code analysis. 

Initial project structure with dependencies and checkers configured is provided as a GitHub repository\footnote{In Russian \url{https://github.com/FormalLanguageConstrainedPathQuerying/formal-lang-course}} to be forked by students.
The repository contains configured actions for CI, supplementary code, placeholders for exercises, functions signatures to implement, and other stuff to minimize preparation to assignments completing.
Rye\footnote{\url{https://rye.astral.sh}} is used for dependencies management.

Automation is done using GitHub actions that trigger on pushes and pull requests, and includes tests execution, code style guide checking, parser generation related actions. 
It allows us to automate control of assignments completing and use code review mechanisms to discuss assignments with students.

We use only an open tests implemented using Pytest testing framework and they consist of of two types.
The first one is a set of ordinary unit tests that check corner cases of algorithms.
The second one is a set of property-like tests that use the fact that students should implements algorithms for closely related problems.
Thus different algorithms form different assignments should return the same results for randomly generated input. 
This way we can simplify testing system (no private tests) and avoid algorithms fitting. 

\section{Discussion}

Motivation to study formal languages, refresh linear algebra, HPC....
Why matrices: pretty simple ideas and algorithms, rather than LR, hides implementation complexity, clear abstraction (it is easy to realize that one library of linear algebra operations can be replaced with another one). More over, students can do it yourself.

Simple formulation of engineering tasks, problems, challenges regarding performance allows students to be involved in related research during course or right after it. 
Evaluation of matrix-based CFPQ algorithm, represented by Nikita Mishin, Iaroslav Sokolov et al. in ``Evaluation of the Context-Free Path Querying Algorithm Based on Matrix Multiplication''~\cite{10.1145/3327964.3328503} is an improved results of experiments done as the course exercise. 

Orachev.
Muraviev.

Also we want to highlight some drawbacks and weakness of our course.
The first one is that practice with non-linear-algebra-based algorithm for FLPQ (and parsing, respectively) is very limited. 
Different algorithms, based on GLR, GLL and other parsing algorithms. 
Only GLL, but reachability, not paths.
These algorithms are powerful (can natively solve all-paths queries), but require special techniques that cannot be natively inferred from linear-algebra-based algorithms.
Especially high-performance solution.
Looks like advanced block. 
Last block requires special knowledge. 
Can de optional. 
Ore replaced with.

Proposed structure hides basics of some concepts. 
For example, sparse linear algebra.
But this way we learn to use existing libraries that is a useful skill for engineers, and allow students to touch real-world problems and tasks without huge amount of preliminary work.

Manual control needed to check wether the requested algorithm implemented.
Few algorithms for the same (or similar) problems: it is possible to resubmit single one implementation.

Last part requires programming languages theory. May be omitted. Other blocks can be used independently in other courses.

Other courses ~\cite{Figueira2022}
%http://www.drps.ed.ac.uk/16-17/dpt/cxinfr11121.htm
% KNOWLEDGE GRAPHS  Lecture 11: Querying Property Graphs with Cypher
%https://www.ksi.mff.cuni.cz/~svoboda/courses/241-NDBI049/
%https://www.ksi.mff.cuni.cz/~svoboda/courses/241-NIE-PDB/
%https://catalogs.buffalo.edu/preview_course_nopop.php?catoid=1&coid=1061

Advanced SQL, Graph databases, GQL, 

\section{Conclusion And Future Work}

We describe the course that aimed to graph query engine development !!! 
Formal languages anf graph theory.
While this course has been taught for several years now, there is a room for improvements.

One of the important technical improvements is to extend testing system to provide performance testing. 
For now, performance analysis of the implemented algorithms can be done only in respective tasks on algorithms evaluation and comparison.
There is no automatic control on performance of implemented algorithms. 
So, students not forced to provide not n\"ive solutions.
Moreover, they often provide solutions with trivial performance issues: no early exit in transitive-closure-like procedures, no analysis of sparse matrix format (so, randomly selected format is used) and so on.

The next technical challenge is to replace sciPy with python-graphblas\footnote{Python wrapper for SuiteSparse:GraphBLAS: \url{https://github.com/python-graphblas/python-graphblas}.} in order to enforce studying of specific tools for high-performance graph analysis. 
It is not clear, whether sciPy should be replaced, or python-graphblas should be provided as an optional alternative for sciPy because sciPy is easier for beginners, but python-graphblas allows one to pay more attention on performance.

More algorithms.
Multiple sources versions of algorithms for CFL-r (linear-algebra based).
But it should be simplified first.
A bit more concepts required.

Custom semiring and path problems.
Related to migration to python-graphnas.

More non-matrix-based algorithms. Comparison.

More Beyond context-free (MCFG), boolean, conjunctive. 
Static analysis.
Matrices. 
Decidability analysis. Approximations.
Practical tasks.

More data for evaluation form wider range of applications.
Biological data, data provenance, more code analysis.

All above leads to more optional tasks.
But all of them consistent in terms tah allows student to create self-contained application for graph analysis.

Decidability problems, so on.

Flexibility. 
To create a set of reuseable modules for !!! cources for fromal languegaes, graph querying etc.

To build an advanced course on data analysis. 
Materials (in Russian)\footnote{!!!}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{FormalLangTheoryForDataAnalysis}


\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'.
