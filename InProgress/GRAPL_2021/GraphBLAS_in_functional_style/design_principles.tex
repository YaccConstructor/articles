\section{Design Principles}

Basic principles of proposed design described in this section.
Here we will use .NET-like style for generic types: $\texttt{Type}_1\langle\texttt{Type}_2\rangle$ means that the type $\texttt{Type}_1$ is generic and $\texttt{Type}_2$ is a type parameter.
Also we use F\#-like type notations and syntax in our examples.

\subsection{Types of Graphs, Matrices, and Operations}

Suppose one have an edge-labelled graph $G$ where labels have type $\texttt{T}_{\texttt{lbl}}$. 
Suppose also one declare a generic type $\texttt{Matrix} \langle \texttt{T} \rangle$ to use this type for graph representation where type parameter \texttt{T} is a type of matrix cell. 
It is obvious that type of cell of adjacency matrix of graph $G$ should a special type which has only two values: some value of type $\texttt{T}_{\texttt{lbl}}$ or special value \texttt{Nothing}.
This idea can be naturally expressed using discriminated unions (or sum types) which actively used not only in functional languages such as F\#, OCalm, or Haskell, but also in TypeScript, Swift and other popular languages. 
Moreover, the described case is widely used and there is a standard type in almost all languages which supports discriminated unions: $\texttt{Option} \langle \texttt{T} \rangle$ in F\# or OCaml, or $\texttt{Maybe} \langle \texttt{T} \rangle$ in Haskell. 
In F\# this type defined as presented in listing~\ref{lst:optionType}.

\begin{listing}[h]
\begin{minted}{fsharp}
type Option<T> =
| None
| Some of T
\end{minted}
\caption{\texttt{Option} type definition}
\label{lst:optionType}
\end{listing}


Thus, to represent the graph $G$ as a matrix one should use an instance of $\texttt{Matrix} \langle \texttt{Option}\langle \texttt{T}_{\texttt{lbl}} \rangle \rangle $  of generic type $\texttt{Matrix}\langle \texttt{T} \rangle$.
This way we can explicitly separate non-zero and zero cells in terms of sparse matrix: non-zero cells are cells with value \texttt{Some(x)} for which \texttt{x} should be stored, and zero cells are cells with value \texttt{None}.

In these settings, natural type for binary operation is $$\texttt{Option}\langle T_1 \rangle \to \texttt{Option}\langle T_2 \rangle \to \texttt{Option}\langle T_3 \rangle.$$ But this type is not restrictive enough: it allows one to define operation which returns some non-zero (\texttt{Some(x)}) value for two zeroes (\texttt{None}-s), while we expect that $$\texttt{None op None = None}$$ for any operation \texttt{op}.   

To solve this problem one can introduce additional constraints, but such constraints can not be expressed in F\#.
Actually, one need more power type system whish supports dependetn types.
An alternative solution is to introduce a type $\texttt{AtLeastOne} \langle T_1, T_2 \rangle$ as presented in listing~\ref{lst:AtLeastOneType}. This type is less flexible (for example it disallows one to apply operation partially) but is explicitly shows that we expect that at least one argument of operation should be non-zero. 

\begin{listing}[h]
    \begin{minted}{fsharp}
    type AtLeastOne<T1,T2> =
    | Both of T1 * T2
    | Left of T1
    | Right of T2
    \end{minted}
    \caption{\texttt{AtLeastOne} type definition}
    \label{lst:AtLeastOneType}
\end{listing}

Finally in this settings binary operations should have the following type: $$\texttt{AtLeastOne} \langle T_1, T_2 \rangle \to \texttt{Option}\langle T_3 \rangle.$$
This type disallows one to build non-zero value from two zeroes, and explicitly shows whether result should be stored or not.
Thus, proposed typing scheme solves problem of explicit and implicit zeroes.
Moreover it allows to generalize element-wise operations.
For example, binary operations for element-wise addition, element-wise multiplication, and even for masking can be specified as presented in listings~\ref{lst:opIntAdd}, \ref{lst:opIntMult}, \ref{lst:opMask} respectively.

\begin{listing}[h]
    \begin{minted}{fsharp}
let op_int_add args =
    match args with
    | Both (x, y) -> 
        ler res = x + y 
        if res = 0 
        then None 
        else Some res 
    | Left x -> Some x
    | Right y -> Some y
    \end{minted}
    \caption{An example of element-wise addition operation definition}
    \label{lst:opIntAdd}
\end{listing}

\begin{listing}[h]
    \begin{minted}{fsharp}
let op_int_mult args =
    match args with
    | Both (x, y) -> 
        ler res = x * y 
        if res = 0 
        then None 
        else Some res 
    | Left x -> None
    | Right y -> None
    \end{minted}
    \caption{An example of element-wise multiplication operation definition}
    \label{lst:opIntMult}
\end{listing}

\begin{listing}[h]
    \begin{minted}{fsharp}
let op_mask args =
    match args with
    | Both (x, y) -> Some x
    | Left x -> None
    | Right y -> None
    \end{minted}
    \caption{An example of masking operation definition}
    \label{lst:opMask}
\end{listing}

\subsection{Operations Over Matrices and Vectors}

GraphBLAS API introduces \textbf{monoid} and \textbf{semiring} abstraction to specify element-wise operations for functions over matrices and vectors.
We propose to use binary operations instead as a parameters for functions over matrices and vectors. 
Using proposed types we always know that identity is always \texttt{None}, so we do not need specify identity separately as a part of semiring or monoid.
Additionally, we often do not require operations actually satisfy semiring or monoid properties, so usage of correctly typed functions should be more clear and less confusing than usage of mathematical object in non-convenient settings.

For example, function for matrix-matrix multiplication should has the following type:
\begin{alignat*}{2}
    \texttt{mXm} & : & \\ 
        &   & \texttt{ mlt: AtLeastOne} \langle T_1, T_2 \rangle \to \texttt{Option} \langle T_3 \rangle \\
        & \to & \texttt{ add: AtLeastOne} \langle T_3, T_3 \rangle \to \texttt{Option} \langle T_3 \rangle \\
        & \to & \texttt{m}_1: \texttt{Matrix} \langle \texttt{Option} \langle T_1\rangle \rangle \\
        & \to & \texttt{m}_2: \texttt{Matrix} \langle \texttt{Option} \langle T_2 \rangle \rangle \\
        & \to & \texttt{result}: \texttt{Matrix} \langle \texttt{Option} \langle T_3\rangle \rangle
\end{alignat*}

In this settings we can predefine a set of widely used binary operations, and allows user to specify own ones, and combine all of them freely and safely.
Moreover, this way allows one to introduce monoids and semirings as an additional level of abstraction if necessary.


\subsection{Fusion [in progress]}

Runtime metaprogramming allows us to implement runtime fusion for kernels: having an expression over matrices and vectors we can build an optimized F\# function from predefined building blocs, and after that translate this optimized version to OpenCL C.

This allows us to define \textbf{mask} as a partial case of generic element-wise function (respective operation is presented in listing~\ref{lst:opMask}), not an optional parameter of other functions.
This makes API more homogeneous and clear. 
