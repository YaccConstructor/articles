\chapter{Задача о поиске путей с ограничениями в терминах формальных языков}\label{chpt:CFPQ}



В данной главе сформулируем постановку задачи о поиске путей в графе с ограничениями. 
А также приведём несколько примеров областей, в которых применяются алгоритмы решения этой задачи.

\section{Постановка задачи }


Пусть нам дан конечный ориентированный помеченный граф $\mathcal{G}=\langle V,E,L \rangle$.
Функция $\omega(\pi) = \omega((v_0, l_0, v_1),(v_1,l_1,v_2),\dots,(v_{n-1},l_{n-1},v_n)) = l_0 \cdot l_1 \cdot \ldots \cdot l_{n-1} $ строит слово по пути посредством конкатенации меток рёбер вдоль этого пути.
Очевидно, для пустого пути данная функция будет возвращать пустое слово, а для пути длины $n  > 0$ --- непустое слово длины $n$.

Если теперь рассматривать задачу поиска путей, то окажется, что то множество путей, которое мы хотим найти, задаёт множество слов, то есть язык.
А значит, критерий поиска мы можем сформулировать следующим образом: нас интересуют такие пути, что слова из меток вдоль них принадлежат заданному языку.
\begin{definition} \label{def1}
    \textit{Задача поиска путей с ограничениями в терминах формальных языков} заключается в поиске множества путей $\Pi = \{\pi \mid \omega(\pi) \in \mathcal{L}\}$.
    
\end{definition}

В задаче поиска путей мы можем накладывать дополнительные ограничения на путь (например, чтобы он был простым, кратчайшим или Эйлеровым~\cite{kupferman2016eulerian}), но это уже другая история.

Другим вариантом постановки задачи является задача достижимости.

\begin{definition} \label{def2}
    \textit{Задача достижимости} заключается в поиске множества пар вершин, для которых найдется путь с началом и концом в этих вершинах, что слово, составленное из меток рёбер пути, будет принадлежать заданному языку.
    $\Pi' = \{(v_{i}, v_{j}) \mid \exists v_{i} \pi v_{j}, \omega(\pi) \in \mathcal{L}\}$.
    
\end{definition}

При этом, множество $\Pi$ может являться бесконечным, тогда как $\Pi'$ конечно, по причине конечности графа $\mathcal{G}$.

Язык $\mathcal{L}$ может принадлежать разным классам и быть задан разными способами. Например, он может быть регулярным, или контекстно-свободным, или многокомпонентным контекстно-свободным.

Если $\mathcal{L}$ --- регулярный, $\mathcal{G}$ можно рассматривать как недетерминированный конечный автомат (НКА), в котором все вершины и стартовые, и конечные.
Тогда задача поиска путей, в которой $\mathcal{L}$ --- регулярный, сводится к пересечению двух регулярных языков.

Более подробно мы рассмотрим случай, когда $\mathcal{L}$ --- контекстно-свободный язык.

Путь $G = \langle \Sigma, N, P \rangle$ --- контекстно-свободная граммтика.
Будем считать, что $L \subseteq \Sigma$.
Мы не фиксируем стартовый нетерминал в определении грамматики, поэтому, чтобы описать язык, задаваемый ей, нам необходимо отдельно зафиксировать стартовый нетерминал.
Таким образом, будем говорить, что $L(G,N_i) = \{ w | N_i \xRightarrow[G]{*} w  \}$ --- это язык задаваемый граммтикой $G$ со стартовым нетерминалом $N_i$.

\begin{example}
    Пример задачи поиска путей.
    
    Дана грамматика  $G:$
    \begin{align*}
    S   &\to a b \\ 
    S   &\to a S b
    \end{align*}
    
    Эта грамматика задаёт язык $\mathcal{L} = a^n b^n$.
    
    И дан граф $\mathcal{G}:$
    
    \begin{center}
        \begin{tikzpicture}[node distance=3cm, shorten >=1pt,on grid,auto]
        \node[state] (q_0)   {$0$};
        \node[state] (q_1) [above right=of q_0] {$1$};
        \node[state] (q_2) [right=of q_0] {$2$};
        \node[state] (q_3) [right=of q_2] {$3$};
        \path[->]
        (q_0) edge  node {a} (q_1)
        (q_1) edge  node {a} (q_2)
        (q_2) edge  node {a} (q_0)
        (q_2) edge[bend left, above]  node {b} (q_3)
        (q_3) edge[bend left, below]  node {b} (q_2);
        \end{tikzpicture}
        
    \end{center}
    
    Тогда примерами путей, принадлежащих множеству $\Pi = \{\pi \mid \omega(\pi) \in \mathcal{L}\}$, являются:
    
    \begin{center}
        \begin{tikzpicture}[node distance=2cm, shorten >=1pt,on grid,auto]
        \node[state] (q_1) {$1$};
        \node[state] (q_2) [right=of q_1] {$2$};
        \node[state] (q_3) [right=of q_2] {$3$};
        \path[->]
        (q_1) edge  node {a} (q_2)
        (q_2) edge  node {b} (q_3);
        \end{tikzpicture}
        
    \end{center}
    
    \begin{center}
        \begin{tikzpicture}[node distance=2cm,shorten >=1pt,on grid,auto]
        \node[state] (q_0)   {$0$};
        \node[state] (q_1) [right=of q_0] {$1$};
        \node[state] (q_2) [right=of q_1] {$2$};
        \node[state] (q_3) [right=of q_2] {$3$};
        \node[state] (q_4) [right=of q_3] {$2$};
        \path[->]
        (q_0) edge  node {a} (q_1)
        (q_1) edge  node {a} (q_2)
        (q_2) edge  node {b} (q_3)
        (q_3) edge  node {b} (q_4);
        \end{tikzpicture}
        
    \end{center}
    
\end{example}


\section{О разрешимости задачи}

Задачи из определения \ref{def1} и \ref{def2} сводятся к построению пересечения языка $\mathcal{L}$ и языка, задаваемого путями графа, $R$. 
А мы для обсуждения разрешимости задачи рассмотрим более слабую постановку задачи:

\begin{definition}
    Необходимо проверить, что существует хотя бы один такой путь $\pi$ для данного графа, для данного языка $\mathcal{L}$, что $\omega(\pi) \in \mathcal{L}$.
    
\end{definition}

Эта задача сводится к проверке пустоты пересечения языка $\mathcal{L}$ c $R$ --- регулярным языком, задаваемым графом. От класса языка $\mathcal{L}$ зависит её разрешимость:

\begin{itemize}
    \item Если $\mathcal{L}$ регулярный, то получаем задачу пересечения двух регулярных языков: 
    
    $\mathcal{L} \cap R = R'$.
    $R'$ --- также регулярный язык.
    Проверка регулярного языка на пустоту --- разрешимая проблема.
    
    \item Если $\mathcal{L}$ контекстно-свободный, то получаем задачу
    
    $\mathcal{L} \cap R = CF$ --- контекстно-свободный.
    Проверка контекстно-свободного языка на пустоту --- разрешимая проблема.
    
    \item Помимо иерархии Хомского существуют и другие классификации языков.
    Так например, класс конъюнктивных (Conj)
    языков~\cite{DBLP:journals/jalc/Okhotin01}
    является строгим расширением контекстно-свободных языков и все так же позволяет полиномиальный синтаксический анализ.
    
    Пусть $\mathcal{L}$ --- конъюнктивный. При пересечении конъюнктивного и регулярного языков получается конъюнктивный ($\mathcal{L} \cap R = Conj$), а проблема проверки Conj на пустоту не разрешима~\cite{DBLP:journals/tcs/Okhotin03a}.
    
    \item Ещё один класс языков из альтернативной иерархии, не сравнимой с Иерархией Хомского, --- MCFG (multiple context-free grammars)~\cite{SEKI1991191}.
    Как его частный случай --- TAG (tree adjoining grammar)~\cite{Joshi1997}.
    
    Если $\mathcal{L}$ принадлежит классу MCFG, то $\mathcal{L} \cap R$ также принадлежит MCFG. Проблема проверки пустоты MCFG разрешима~\cite{SEKI1991191}.
    
\end{itemize}

Существует ещё много других классификаций языков, но поиск универсальной иерархии до сих пор продолжается.

Далее, для изучения алгоритмов решения, нас будет интересовать задача $R \cap CF$.

\section{Области применения}
\begin{itemize}
    \item Статанализ. 
    Введено Томасом Репсом~\cite{Reps}.
    \item Социальные сети~\cite{Hellings2015PathRF}.
    \item RDF обработка~\cite{10.1007/978-3-319-46523-4_38}.
    \item Биоинформатика~\cite{cfpqBio}.
    \item Применяется для различных межпроцедурных задач~\cite{LabelFlowCFLReachability,specificationCFLReachability,Zheng}.
    \item Графовые БД
    Впервые предложил Михалис Яннакакис~\cite{Yannakakis}.
    
\end{itemize}

\begin{itemize}
    \item OpenCypher~\cite{Kuijpers:2019:ESC:3335783.3335791}
    \item J.Hellings. CFPQ~\cite{hellingsRelational,hellings2015querying,Hellings2015PathRF}
    \item Zhang. CFPQ on rdf graphs~\cite{10.1007/978-3-319-46523-4_38}
    \item Bradford~\cite{bradford2007quickest,ward2008distributed,bradford2016fast,Bradford:2008:LCG:1373936.1373946}
\end{itemize}


\section{Вопросы и задачи}
\begin{enumerate}
    \item Пусть есть граф. Задайте грамматику для поиска всех путей, таких, что....
    \item Существует ли в графе !!! путь из А в Б, такой что!!!
    \item Для графа !!! постройте все пути, удовлетворяющие !!!!
    
    \item Задача 1
    \item Задача 2
\end{enumerate}
